# Лабораторная работа 6 "Тракт данных"

Микроархитектуру можно разделить на две части: тракт данных и устройство управления. По тракту данных перемещаются данные (из памяти инструкций, регистрового файла, АЛУ, памяти данных, мультиплексоров), а устройство управления (основной дешифратор команд) получает текущую инструкцию из тракта и в ответ говорит ему как именно выполнить эту инструкцию, то есть управляет тем, как эти данные будут через тракт данных проходить.


## Цель

Описать на языке **Verilog** процессор с архитектурой **RISC-V**, реализовав его тракт данных, использую ранее разработанные блоки, и подключив к нему устройство управления. В рамках этого трека лабораторных работ требуется реализовать только поддержку обработки слов (то есть БЕЗ инструкций связанных с байтами и полусловами: `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`).


## Ход работы

1. Изучить дополнительные материалы по микроархитектуре ([#теория](#особенности-реализации-упрощенной-однотактной-микроархитектуры-risc-v))
2. Изучить особенности реализации сброса регистров ([#инструменты](#инструменты))
3. Исправить память программ и память данных ([#задание](#задание))
4. Реализовать тракт данных ([#задание](#задание))
5. Подготовить программу и загрузить ее в память программ ([`Индивидуальные задания по RISC-V`](../../Tests/Problems%20RISC-V.md))
6. Сравнить результат работы процессора на модели в **Vivado** и в симуляторе программы ассемблера


## Особенности реализации упрощенной однотактной микроархитектуры RISC-V

Более подробно о архитектуре и базовом наборе команд, псевдоинструкциях и способах кодирования **RISC-V** можно прочитать в [`RV32I`](../../Other/rv32i.md).

Архитектура **RISC-V** предполагает использование побайтовой адресации памяти, то есть, должна использоваться память, в которой каждый байт информации имеет свой уникальный адрес. При считывании байта из памяти обращение происходит по одному адресу, при использовании полуслов – сразу к двум последовательным адресам, при использовании слов – сразу к 4 последовательным адресам. При этом процессорное ядро оперирует только словами, хотя при доступе к памяти могут быть запрошены байты и полуслова, в этом случае они (байты и полуслова) должны быть расширены до 32 бит нулями или знаком, в зависимости от операции (в этом треке не делается). В рамках этой лабораторной работы ранее разработанная память инструкций (**Instruction Memory**) будет "притворяться" побайтовой, но по факту будет являться пословной. Благодаря этому получится временно упростить интерфейс к памяти, саму память и не придется расширять байты и полуслова.

Чтобы пословная память смогла "притвориться" побайтовой нужно:

- запрашивать только слова, то есть не использовать инструкции `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`. С памятью инструкций такой проблемы нет, потому что в **RV32I** от туда всегда считываются только слова, так как инструкция имеет размер 32 бита
- правильно обрабатывать адреса, превращая их внутри пословной памяти из побайтовых в пословные. Так как на одно слово приходится 4 байта (в 32 битах 4 раза по 8 бит), значит оно занимает 4 адреса, значит побайтовый адрес надо разделить на 4, чтобы получить пословный адрес.

В побайтовой адресации последовательно лежащие слова имели бы адреса 0, 4, 8, 12, 16, 20 и так далее (по 4 адреса на слово, но указывается только адрес младшего байта). В пословной адресации нужно разделить их адреса на 4, тогда получим адреса 0, 1, 2, 3, 4, 5 и так далее. Это ровно то, что нужно, так как в создаваемой ранее памяти инструкций все слова лежат по последовательным адресам: 0, 1, 2, 3 и так далее.

Если записать число в десятичной системе счисления, например – 563, то чтобы целочисленно разделить его на 10 (основание системы счисления) достаточно откинуть его младший разряд (сдвинуть на один вправо), получится 56. Для деления на 100 (на 10 в квадрате) нужно откинуть два младших разряда, получится 5. Математика работает аналогичным образом и в других системах счисления. Для деления двоичного числа на 2 (основание системы счисления) достаточно сдвинуть его на один бит вправо. Для деления на 4 (на 2 в квадрате) – сдвинуть на два бита вправо. Следовательно, для преобразования побавйтового адреса в пословный необходимо сдвинуть адрес на 2 бита вправо.

Реализации микроархитектуры потребует модификации ранее разработанных блоков памяти и будет выглядеть следующим образом:

![Микроархитектура](../../../technical/Labs/Pic/uarch_dp.png)


## Инструменты

Особенность регистровой памяти заключается в том, что при подаче питания нельзя достоверно предсказать какое значение будет в ней лежать. Это связано с особенностями строения регистров. Поэтому к регистрам подводят сигналы сброса, которые активируются при включении аппаратуры. При появлении сигнала сброса регистр перезаписывается в значение по-умолчанию.

Существует два способа реализации сброса регистра: синхронный и асинхронный. При синхронном сбросе перезапись осуществляется в момент возникновения фронта тактирующего сигнала. Для следующего примера сброс произойдет, когда `reset` равен единице. То есть, например, если `reset` кратковременно станет единицей, а потом снова нулем, а фронт `clk` произойти не успел, то сброса не будет.

``` verilog
// какой-то код

  input       clk,
  input       reset,
  input [3:0] d,

// какой-то код

  reg   [3:0] q;

  always @ (posedge clk) begin
    if (reset)
      q <= 4'b0;  // что записывается в случае сброса
    else
      q <= d;     // что происходит в обычной ситуации
  end
```

![d-trigger-sync](../../../technical/Labs/Pic/d_reset_sync.png)

При асинхронном сбросе перезапись происходит в момент возникновения сигнала сброса не дожидаясь фронта `clk`.

``` verilog
// какой-то код

  input       clk,
  input       reset,
  input [3:0] d,

// какой-то код

  reg   [3:0]   q;

  always @ (posedge clk or posedge reset) begin // добавляется условие для сигнала сброса
    if (reset)
      q <= 4'b0;  // что записывается в случае асинхронного сброса
    else
      q <= d;     // что происходит в обычной ситуации
  end
```

![d-trigger-async](../../../technical/Labs/Pic/d_reset_async.png)

Для счетчика команд (регистр **Program Counter**, `PC`) необходимо реализовать асинхронный сброс.


## Задание

1. Доработать ранее разработанный блок памяти инструкций (**Instruction Memory**) так, чтобы он мог работать в процессоре с побайтовой адресацией

![Память команд](../../../technical/Labs/Pic/im_dp.png)

2. Подобным образом доработать ранее реализованную память данных (**Data Memory**) так, чтобы она могла работать в процессоре с побайтовой адресацией. При этом она должна иметь видимость ограничения доступных адресов `0xNN000000 – 0xNN0003FC`, где `NN` это последние две цифры студенческого. Например, если мой студенческий `001905`, то 256 слов памяти должны быть расположены по адресам `0x05000000 – 0x05003FC`. Реализация такого функционала подобна реализации регистра `x0` в регистровом файле. В случае обращения к памяти за рамками указанных границ должен выдаваться ноль

3. Реализовать тракт данных процессора **RISC-V** с подключенным к нему устройством управления (основной дешифратор команд)
![Микроархитектура](../../../technical/Labs/Pic/uarch_dp.png)

Для верификации полученного устройства необходимо поместить в память программ ранее разработанную программу (согласно [`индивидуальному заданию по RISC-V`](../../Tests/Problems%20RISC-V.md)) и, создав тестовое окружение, генерирующее тактовый сигнал для процессора, сравнить результаты работы в симуляторе **Vivado** и в программе ассемблера. Если результаты совпадают, то полагаем, что процессор работает правильно. Для коммерческого процессора такой проверки недостаточно, но для студенческого – вполне.

---

<details>
  <summary>Прочти меня, когда выполнишь.</summary>
  Поздравляю, ты сделал(а) свой первый взрослый процессор! Теперь ты можешь говорить:
  
 >Я способен(на) на всё! Я сам(а) полностью, с нуля, сделал(а) процессор с архитектурой RISC-V! Что? Не знаешь, что такое архитектура? Пф, щегол! Подрастешь – узнаешь

</details>
