# Лабораторная работа 3 "Регистровый файл и память"

[`Список лабораторных`](../README.md) [`СОДЕРЖАНИЕ`](../../README.md)

Процессор – это программно-управляемое устройство выполняющее обработку информации и управление этим процессом. Очевидно, программа, которая управляет процессором, должна где-то храниться. Данные, с которыми процессор работает, тоже должны быть в доступном месте. Нужна память!

## Цель

Описать на языке verilog элементы памяти для будущего процессора: память команд (Instruction Memory), память данных (Data Memory) и регистровый файл (Register File)

## Допуск к лабораторной работе

Изучить [способы описания регистров на языке Verilog](../../Other/Basic%20Verilog%20structures/Registers.md), а так же познакомиться с [конкатенацией](../../Other/Basic%20Verilog%20structures/Concatenation.md).

## Ход работы

1. Изучить способы организации памяти (раздел [#теория про память](#теория-про-память))
2. Изучить конструкции verilog для реализации запоминающих элементов (раздел [#инструменты](#инструменты-для-реализации-памяти))
3. В проекте с прошлой лабораторной реализовать модули: Instruction Memory, Data Memory и Register File ([#задание](#задание-по-реализации-памяти))
4. Проверить с помощью тестового окружения корректность их работы
5. Проверить работу регистрового файла в ПЛИС

## Теория про память

Память – это устройство для упорядоченного хранения и выдачи информации. Различные запоминающие устройства отличаются способом и организацией хранения данных. Более подробно о видах памяти можно будет узнать на лекции `15. Память`. Базовыми характеристиками памяти являются:

- V – объем (количество бит данных, которые единовременно может хранить память)
- a – разрядность адреса (ширина шины адреса, определяет адресное пространство – количество адресов отдельных ячеек памяти)
- d – разрядность хранимых данных (разрядность ячейки памяти, как правило совпадает с разрядностью входных/выходных данных)

В общем случае `V = 2^a * d`

Для объема памяти в 1 KiB ([кибибайт](https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D0%B1%D0%B8%D0%B1%D0%B0%D0%B9%D1%82), 1024 байта или 8192 бита) разрядность адреса может быть, например, 10 бит (что покрывает 2^10 = 1024 адреса), тогда разрядность хранимых данных должна быть 8 бит. 1024 * 8 = 8192, то есть 1 кибибайт. Если разрядность адреса, например, 8 бит (что покрывает 2^8 = 256 адресов), то разрядность данных `d = V / 2^a` это 8192 / 256 = 32 бита.

Однако, может быть такое, что не все ячейки памяти реально реализованы на кристалле микросхемы, то есть некоторые адреса существуют, но по ним не имеет смысла обращаться, а объем памяти, соответственно, не равен `V ≠ 2^a * d` – он меньше. Подобные случаи будут рассмотрены отдельно.

Память можно разделить на категории: ПЗУ (постоянное запоминающее устройство) и ОЗУ (оперативное запоминающее устройство). Из ПЗУ можно только считывать информацию, которая попадает в ПЗУ до начала использования памяти и не может изменяться в процессе работы. Из ОЗУ можно считывать и записывать информацию. В самом простом случае ПЗУ имеет один вход адреса `A` и один выход считываемых данных `RD`. На вход `A` подается адрес требуемой ячейки памяти, на выходе `RD` появляются данные, которые хранятся по этому адресу.

Для ОЗУ требуется больше сигналов. Кроме входного `A` и выходного `RD` добавляются: входные данные для записи `WD`, сигнал синхронизации `CLK`, который определяет момент записи данных и сигнал разрешения на запись `WE`, который контролирует нужно ли записывать данные или только считывать. Для того, чтобы записать информацию в такую память необходимо:

- выставить адрес `A` в который планируется запись данных,
- выставить сами данные для записи на вход `WD`,
- установить сигнал `WE` в состояние разрешения записи (как правило это 1) и
- дождаться нужного фронта `CLK` – в этот момент данные будут записаны по указанному адресу. При этом, на выходе `RD` будут старые данные, хранящиеся по адресу `A`. На одном такте происходит одновременное считывание информации и запись новой.

Так же возможна реализация, в которой вход `RD` и выход `WD` объединены в единый вход/выход `D`. В этом случае операции чтения и записи разделены во времени и используют для этого один единый порт ввода-вывода (`inout`, двунаправленный порт) `D`.

![ОЗУ и ПЗУ](../../../technical/Labs/Pic/ram_rom.png)

Еще одной характеристикой памяти является количество доступных портов. Количество портов определяет к скольким ячейкам памяти можно обратиться одновременно. Проще говоря, сколько входов адреса существует. Все примеры памяти рассмотренные выше являются **однопортовыми**, то есть у них один порт. Например, если у памяти 2 входа адреса `A1` и `A2` — это **двухпортовая память**. При этом не важно, можно ли по этим адресам только читать/писать или выполнять обе операции.

Регистровый файл, который будет реализован в рамках данной работы, является **трехпортовым**, и имеет 2 порта на чтение и 1 порт на запись.

С точки зрения аппаратной реализации память в ПЛИС может быть **блочной**, **распределенной** или **регистровой**. **Блочная память** – это аппаратный блок памяти, который можно сконфигурировать под свои нужды. **Распределенная** и **регистровая** память (в отличие от блочной) реализуется на **конфигурируемых логических блоках** (см. [как работает ПЛИС](../../Other/How%20FPGA%20works.md)). Такая память привязана к расположению конфигурируемых логических блоков ПЛИС и как бы равномерно распределена по всему кристаллу. Вместо реализации логики конфигурируемые логические блоки используются для нужд памяти. Чтобы понять почему это возможно, рассмотрим структуру логического блока:

<img src="../../../technical/Labs/Pic/reg_FPGA_cell_example.png" alt="структура логического блока" width="600"/>

В логическом блоке есть LUT, которые представляют собой не что иное как память, которая переконфигурируется под нужды хранения, а не реализацию логики. Таким образом, трехвходовой LUT может выступать в роли восьмиразрядной памяти.  
Однако LUT будет сложно приспособить под многопортовую память: посмотрим на схему еще раз: три входа LUT формируют адрес одной из восьми ячеек. Это означает, что среди этих восьми ячеек нельзя обратиться к двум из них одновременно.
Для реализации многопортовой памяти небольшого размера лучше воспользоваться расположенным в логическом блоке D-триггере (DFF на схеме логического блока). Не смотря на то, что D-триггер позволяет воспроизвести 1 разряд элемента памяти, он не ограничивает реализацию по портам.
Таким образом, плюс распределенной памяти относительно регистровой заключается в лучшей утилизации ресурсов: на восемь разрядов памяти у нас уйдет один трехвходовой LUT, в то время как для восьми разрядов регистровой памяти у нас уйдет 8 D-триггеров.  
Минусом является ограниченность в реализации многопортовой памяти.
Сравним блочную память с распределенной/регистровой: поскольку большой объем памяти съест много логических блоков при реализации распределенной/регистровой памяти, такую память лучше делать в виде блочной.
В то же время, к плюсам распределенной/регистровой памяти можно отнести возможность синтезировать память с асинхронным портом на чтение, чем мы и воспользуемся при реализации однотактного процессора (если бы порт чтения памяти был синхронным, нам потребовалось ждать один такт, чтобы получить инструкцию из памяти инструкций или данные из регистрового файла, что затруднило бы реализацию однотактного процессора, где каждая инструкция должна выполняться ровно за один такт).

Обычно синтезатор сам понимает, какой вид памяти подходит под описанную схему на языке Verilog.
В случае, если под описанную схему подходит несколько видов памяти, есть возможность выбрать конкретную вручную, причем способы могут различаться от производителя к производителю, поэтому за подробностями лучше обращаться к документации. Например у Xilinx за это отвечает [следующий раздел](https://docs.xilinx.com/r/en-US/ug901-vivado-synthesis/RAM-HDL-Coding-Techniques) документации по синтезу.


## Инструменты для реализации памяти

### Описание памяти на языке Verilog

Память на языке verilog объявляется [подобно регистрам](../../Other/Basic%20Verilog%20structures/Registers.md), используя слово `reg`. Но, кроме разрядности (разрядности ячеек памяти, в данном случае) после имени регистра (памяти, в данном случае) указывается количество создаваемых ячеек в виде последовательности от какого адреса к какому они будут привязаны. В примере ниже `reg [19:0] RAM [0:15];` создается память с шестнадцатью (от 0-го до 15-го адреса) 20-битными ячейками памяти. В таком случае говорят, что ширина памяти 20 бит, а глубина 16. Для адресации такой памяти потребуется адрес с разрядностью ceil(log2(16)) = 4 бита (`ceil` – операция округления вверх). Поэтому `A` в примере ниже имеет разрядность 4 – `[3:0]`. Это однопортовая память.

Для обращения к конкретной ячейке памяти используются квадратные скобки с указанием нужного адреса `RAM[A]`. Грубо говоря, то, что указывается в квадратных скобках будет подключено ко входу адреса памяти `RAM`.

Подключение к выходу чтения `RD` осуществляется оператором `assign`. Но, если требуется создать память с синхронным чтением, то выход `RD` требуется сделать регистровым `reg [19:0] RD`, а подключение к нему описать внутри `always`.

Так как запись в память является синхронным событием, то описывается она в конструкции `always`. `if (WE) ...` реализует подключение сигнала `WE` ко входу разрешения на запись.

``` verilog
module mem16_20 (         // создать блок с именем mem16_20
  input           CLK,    // вход синхронизации
  input   [3:0]   A,      // 4-битный адресный вход
  input   [19:0]  WD,     // 20-битный вход данных для записи
  input           WE,     // сигнал разрешения на запись
  output  [19:0]  RD      // 20-битный выход считанных данных
);

  reg [19:0] RAM [0:15];  // создать память с 16-ю 20-битными ячейками

  // чтение
  assign RD = RAM[A];     // подключить к выходу RD ячейку памяти по адресу A

  // запись
  always @ (posedge CLK)  // каждый раз, когда произойдет фронт (0 → 1) CLK
    if (WE)               // если сигнал WE == 1, то
      RAM[A] <= WD;       // в ячейку по адресу A будут записаны данные WD

endmodule                 //  конец описания модуля
```

В случае реализации ПЗУ нет необходимости в описании входов для записи. В таком случае описание памяти занимает всего пару строк. Чтобы инициализировать такую память (то есть поместить в нее начальные значения, чтобы было что из нее читать), требуемое содержимое нужно добавить к прошивке, вместе с которой данные попадут в ПЛИС. Для этого в проект добавляется текстовый файл с содержимым памяти (более подробно об этом в [`Как добавить файл с содержимым памяти в проект`](../../Other/Vivado%20Basics/How%20to%20add%20a%20mem-file.md)). Для того, чтобы отметить данный файл в качестве инициализирующего память, необходимо использовать одну из двух системных функций: `$readmemh` и `$readmemb`. `$readmemh` используется для файлов, описывающих содержимое памяти 16-ричными цифрами, в то время как `$readmemb` используется для файлов, описывающих содержимое памяти двоичными цифрами. Любую из этих системных функций необходимо поместить внутрь блока `initial`. У этих системных функций есть два обязательных аргумента:

- имя инициализирующего файла
- имя инициализируемой памяти

и два опциональных:

- стартовый адрес, начиная с которого память будет проинициализирована данным файлом (по-умолчанию равен нулю)
- конечный адрес, на котором инициализация закончится (даже если в файле были ещё какие-то данные).

Пример полного вызова одной из этих системных функций выглядит так:  
`$readmemb("<data file name>",<memory name>,<start address>,<end address>);`  
Однако на деле обычно используются только обязательные аргументы:  
`$readmemb("<data file name>",<memory name>);`

Пример описанной выше памяти:

``` verilog
module rom16_8 (          // создать блок с именем rom16_8
  input   [3:0]   A1,     // первый 4-битный адресный вход
  input   [3:0]   A2,     // второй 4-битный адресный вход
  output  [7:0]   RD1,    // первый 8-битный выход считанных данных
  output  [7:0]   RD2     // второй 8-битный выход считанных данных
);

  initial $readmemh("mem.txt", RAM);  // поместить при запуске микросхемы в
                                      // память RAM содержимое файла mem.txt

  reg [7:0] RAM [0:15];   // создать память с 16-ю 8-битными ячейками

  assign RD1 = RAM[A1];   // реализация первого порта на чтение
  assign RD2 = RAM[A2]    // реализация второго порта на чтение

endmodule                 //  конец описания модуля
```

Содержимое файла `mem.txt`, к примеру может быть таким (каждая строка соответствует значению отдельной ячейки памяти, начиная со стартового адреса):

``` hex
  FA
  E6
  0D
  15
  A7
```

Как видно из примера, не обязательно заполнять все ячейки памяти, которых должно быть 16, но обязательно соблюдать разрядность ячеек памяти, которая в данном случае равна 8 (две 16-ричные цифры).

## Задание по реализации памяти

Необходимо описать на языке Verilog следующие три вида памяти:

### 1. Память инструкций

У данной памяти будет два порта:

- 32-битный вход адреса
- 32-битный выход данных

```verilog
mоdulе instr_mеm(
  inрut [31:0] addr,
  оutрut[31:0] rеаd_dаtа
);

```

Из [теории про память](#теория-про-память) вы могли догадаться, что такой модуль описывает память ёмкостью `4 GiB`. Однако в реальности, наша память будет куда меньше (в ПЛИС попросту не хватит ресурсов на реализацию памяти подобного объёма).

На практике, внутри данного модуля вы должны будете реализовать память с 1024-мя 8-битными ячейками.

Как так вышло, что разрядность ячеек отличается от разрядности выходного сигнала?
Дело в том, что по спецификации процессор RISC-V должен работать с памятью с побайтовой адресацией. Байтовая адресация означает, что процессор способен обращаться к отдельным байтам в памяти (за каждым байтом памяти закреплен свой индивидуальный адрес).

Именно поэтому, ячейки памяти должны быть восьмибитными.

Однако в то же время, инструкции процессора будут 32-битными (состоящими из 4 подряд идущих байт), поэтому выходной сигнал данной памяти будет 32-разрядным.
Как сделать так, чтобы подавать на выход 4 подряд идущих байта? С помощью [конкатенации](../../Other/Basic%20Verilog%20structures/Concatenation.md).

На вход реализуемого вами модуля приходит адрес младшего байта инструкции, которую вы должны вернуть (этот адрес всегда будет кратен четырем, поскольку в наших лабах инструкции всегда будут состоять из 4 байт).

На выход необходимо подать 32-разрядную склейку:

```text
<третий байт инструкции (старший, счет идет с нуля)>
<второй байт инструкции>
<первый байт инструкции>
<нулевой байт инструкции (адрес которого пришел на вход)>
```

![Память инструкций](../../../technical/Labs/Pic/instr_mem.drawio.png)

### 2. Память данных

У данной памяти будет 5 портов:

- вход тактового синхроимпульса
- вход сигнала разрешения записи
- 32-битный вход адреса
- 32-битный вход данных записи
- 32-битный выход данных чтения

```verilog
mоdulе data_mеm(
  inрut         clk,
  inрut         WE,
  inрut  [31:0] addr,
  inрut  [31:0] write_data,
  оutрut [31:0] rеаd_dаtа
);

```

Идея этой памяти полностью повторяет идею памяти инструкций: несмотря на разрядность адреса и данных, внутри будет память, состоящая из 1024-х 8-битных ячеек.

При чтении, на выход read_data так же будет идти склейка из 4-х байт, а при записи, данные будут писаться одновременно в 4 ячейки памяти:

```text
<третий байт записываемых данных (старший, счет идет с нуля)>
<второй байт записываемых данных>
<первый байт записываемых данных>
<нулевой байт записываемых данных (адрес которого пришел на вход)>
```

![Память данных](../../../technical/Labs/Pic/data_mem.drawio.png)

### 3. Регистровый файл

У данного модуля будет 8 портов:

- вход тактового синхроимпульса
- вход сигнала разрешения записи
- 5-битный вход первого адреса чтения
- 5-битный вход второго адреса чтения
- 5-битный вход адреса записи
- 32-битный вход данных записи
- 32-битный выход данных чтения по первому адресу
- 32-битный выход данных чтения по второму адресу

```verilog
mоdulе rf_r𝚒sсv(
  inрut         сlk,
  inрut         WЕ,

  inрut  [ 4:0] А1,
  inрut  [ 4:0] А1,
  inрut  [ 4:0] А3,

  inрut  [31:0] WD3,
  оutрut [31:0] RD1,
  оutрut [31:0] RD2
);

```

На языке Verilog необходимо реализовать модуль регистрового файла (`rf_r𝚒sсv`) для процессора с архитектурой RISC-V, представляющего собой трехпортовую ОЗУ с двумя портами на чтение и одним портом на запись и состоящей из 32-х 32-битных регистров.

При этом по адресу `0` должно всегда считываться значение `0` вне зависимости от того, какое значение в этой ячейке памяти, и есть ли она вообще. Такая особенность обусловлена тем, что при выполнении операций очень часто используется ноль (сравнение с нулем, инициализация переменных нулевым значением, копирование значения одного регистра в другой посредством сложения с нулем и записи результата и т.п.).

Для подобной особенности можно использовать мультиплексоры, стоящие между регистровым файлом и выходными портами на чтение, и определяющие по адресам чтения, какие данные пойдут на выход: `0` или данные из регистрового файла.

Либо же можно проинициализировать нулевую ячейку памяти нулем с запретом записи в неё каких-либо значений. В этом случае в ячейке всегда будет ноль, а значит и считываться с нулевого адреса будет только он.

![Регистровый файл](../../../technical/Labs/Pic/rf_riscv.drawio.png)

### 4. Проверка в ПЛИС

Последним этапом будет проверка работоспособности вашего регистрового файла в ПЛИС (файлы для прошивки как обычно расположены в папке [board files](board%20files)).

Разработанные блоки будут использованы при реализации процессора `CYBERcobra 3000 Pro 2.0` и последующих лабораторных для реализации системы с процессором с архитектурой RISC-V.

## Порядок выполнения работы

1. Внимательно ознакомьтесь с заданием. В случае возникновения вопросов, проконсультируйтесь с преподавателем.
2. Реализуйте память инструкций. Для этого:
   1. В `Design Sources` проекта с предыдущих лаб, создайте `Verilog`-файл `instr_mem.v`.
   2. Опишите в нем модуль памяти инструкций с таким же именем и портами, как указано в задании.
      1. Сперва необходимо создать память (массив регистров). Как это сделать, сказано в разделе [описание памяти на языке verilog](#описание-памяти-на-языке-verilog). Разрядность ячеек памяти должна быть 8 бит, количество ячеек — 1024.
      2. К созданной памяти необходимо подключить выход модуля `read_data`. При подключении должен быть использован вход модуля `addr` и оператор [конкатенации](../../Other/Basic%20Verilog%20structures/Concatenation.md).
   3. После описания памяти инструкций, её необходимо проверить с помощью [`тестового окружения`](../../Other/Testbench.md).
      1. Тестовое окружение находится [`здесь`](tb_instr_mem.v).
      2. Для запуска симуляции воспользуйтесь [`этой инструкцией`](../../Other/Vivado%20Basics/Run%20Simulation.md).
      3. Перед запуском симуляции убедитесь, что в качестве top-level модуля выбран корректный (`tb_instr_mem`).
      4. **Во время симуляции, вы должны прожать "Run All" и убедиться, что в логе есть сообщение о завершении теста!**
3. Реализуйте память данных. Для этого:
   1. В `Design Sources` проекта создайте `Verilog`-файл `data_mem.v`.
   2. Опишите в нем модуль памяти данных с таким же именем и портами, как указано в задании.
      1. Описание модуля будет схожим с описанием модуля памяти инструкций, но дополнительно потребуется описать логику записи данных в память.
      2. Запись в ячейки памяти описывается подобно записи данных в [регистры](../../Other/Basic%20Verilog%20structures/Registers.md), только при этом, происходит доступ к конкретной ячейке памяти с помощью входа `addr` (как осуществляется доступ к ячейкам памяти сказано в разделе [описание памяти на языке verilog](#описание-памяти-на-языке-verilog)).
      3. Необходимо помнить, что запись будет вестись в 4 ячейки памяти одновременно: ту, на которую указывает адрес и следующие за ней три ячейки.
   3. После описания памяти данных, её необходимо проверить с помощью [`тестового окружения`](../../Other/Testbench.md).
      1. Тестовое окружение находится [`здесь`](tb_data_mem.v).
      2. Для запуска симуляции воспользуйтесь [`этой инструкцией`](../../Other/Vivado%20Basics/Run%20Simulation.md).
      3. Перед запуском симуляции убедитесь, что в качестве top-level модуля выбран корректный (`tb_data_mem`).
      4. **Во время симуляции, вы должны прожать "Run All" и убедиться, что в логе есть сообщение о завершении теста!**
4. Реализуйте регистровый файл. Для этого:
   1. В `Design Sources` проекта создайте `Verilog`-файл `rf_riscv.v`.
   2. Опишите в нем модуль памяти данных с таким же именем и портами, как указано в задании.
      1. В отличии от памяти инструкций и данных, ячейки памяти регистрового файла должны быть 32-битными (а на 8-битными). Это означает, что реализация портов чтения и записи будет проще.
      2. Не забывайте, что у вас 2 порта на чтение и 1 порт на запись, при этом каждый порт не зависит от остальных (в модуле 3 независимых входа адреса).
      3. Чтение из нулевого регистра (чтение по адресу 0) всегда должно возвращать нулевое значение. Этого можно добиться двумя путями:
         1. Путем добавления мультиплексора перед выходным сигналом чтения (мультиплексор будет определять, пойдут ли на выход данные из ячейки регистрового файла, либо в случае если адрес равен нулю, на выход пойдет константа ноль).
         2. Путем инициализации нулевого регистра нулевым значением и запретом записи в этот регистр (при записи и проверки WE добавить дополнительную проверку на адрес).
      4. Каким образом будет реализована эта особенность регистрового файла не важно, выберите сами.
   3. После описания регистрового файла, его необходимо проверить с помощью [`тестового окружения`](../../Other/Testbench.md).
      1. Тестовое окружение находится [`здесь`](tb_rf_riscv.v).
      2. Для запуска симуляции воспользуйтесь [`этой инструкцией`](../../Other/Vivado%20Basics/Run%20Simulation.md).
      3. Перед запуском симуляции убедитесь, что в качестве top-level модуля выбран корректный (`tb_rf_riscv`).
      4. **Во время симуляции, вы должны прожать "Run All" и убедиться, что в логе есть сообщение о завершении теста!**
5. Добавьте в проект модуль верхнего уровня ([nexys_rf_riscv.v](board%20files/nexys_rf_riscv.v)), соединяющий регистровый файл с периферией в ПЛИС. Описание модуля находится [здесь](board%20files)
6. Подключите к проекту файл ограничений ([nexys_a7_100t.xdc](board%20files/nexys_a7_100t.xdc)), если тот еще не был подключен, либо замените его содержимое данными из файла к этой лабораторной работе.
7. Проверьте работу АЛУ в ПЛИС.
