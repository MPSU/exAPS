# Лабораторная работа 3 "Основной дешифратор команд"

[`Список лабораторных`](../README.md) [`СОДЕРЖАНИЕ`](../../README.md)

Устройство управления – один из базовых блоков процессора, функцией которого является декодирование инструкций и выдача управляющих сигналов для всех блоков процессора. 

## Цель

Описать на языке **Verilog** блок основного дешифратора команд (модуль **Main Decoder**) для однотактного процессора с архитектурой **RISC-V**.

## Ход работы

1. Изучить особенности архитектуры **RISC-V** ([#теория](#архитектура-risc-v-и-предлагаемая-микроархитектура))
2. Изучить конструкции **Verilog**, с помощью которых будет описан дешифратор ([#инструменты](#инструменты))
3. Реализовать на языке **Verilog** модуль основного дешифратора команд – **Main Decoder** ([#задание](#задание))
4. Верифицировать разработанное устройство с помощью предлагаемого **testbench** (в том же [#задании](#задание))


## Архитектура RISC-V и предлагаемая микроархитектура

Архитектура системы команд (**Instruction Set Architecture**, **ISA**) включает в себя систему команд процессора (то есть все команды, выполнение которых поддерживается на аппаратном уровне) и средства для выполнения этих команд (доступные форматы данных, наборы регистров, модель памяти).
**ISA RISC-V** является представителем **RISC**-архитектуры (**Reduced Instruction Set Computer**), то есть архитектуры с сокращенным набором команд. Такие процессоры поддерживают относительно небольшой набор инструкций, которые имеют фиксированную длину, за счет чего устройство управления получается очень простым. Каждая команда из базового набора инструкций **RISC-V** кодируется 32-битным числом (словом).

Процессор **RISC-V** обладает регистровым файлом с 32 регистрами по 32 бита каждый. Нулевой регистр (x0) при чтении всегда возвращает ноль (вне зависимости от того, что в него запишут). Остальные регистры (x1-x31) являются регистрами общего назначения.

Из основной памяти, подключенной к процессору, можно считывать и записывать байты, полуслова (16-битные числа) и слова (32-битные числа). Память имеет побайтовую адресацию и 32-битный адресный вход. **RISC-V** является **load/store** архитектурой, это значит, что для выполнения операций над данными их надо предварительно разместить в регистровом файле, для чего используются специальные команды загрузки данных из основной памяти. Результат вычисления также может быть записан только в регистровый файл, поэтому предусмотрены специальные команды сохранения данных из регистрового файла в основную память.

### Набор инструкций **RISC-V** и способы их кодирования

Все инструкции архитектуры **RISC-V** можно условно разделить на три категории:

- Вычислительные инструкции (операции выполняются на АЛУ)
  - Использующие в качестве операндов два регистра
  - Использующие в качестве операндов регистр и непосредственный операнд из инструкции (константу)
- Инструкции для доступа к памяти
  - Загрузки из основной памяти в регистровый файл
  - Сохранения данных из регистрового файла в основную память
- Инструкции управления программой (управляют тем, как изменится счетчик команд `PC`)
  - Условный переход
  - Безусловный переход

Более подробно о архитектуре и базовом наборе команд, псевдоинструкциях и способах кодирования **RISC-V** можно прочитать в [`RV32I`](../../Other/RV32I.md) и обязательно прочитать в том случае, если не были прослушаны лекции 6 и 7 настоящего курса.

В таблице ниже приводятся 39 команд стандартного набора целочисленных инструкций `RV32I`: мнемоники языка ассемблера, функции, описания, форматы кодирования и значения соответствующих полей при кодировании. В **RISC-V** предусмотрено несколько форматов кодирования инструкций (следующий рисунок, еще ниже), то есть существует договоренность о том, какая информация в каком месте 32-битной инструкции хранится, и как она представлена. У всех операций есть поле `opcode` (**operation code** — код операции), в котором закодировано "что нужно сделать". По полю `opcode` устройство управления понимает что требуется сделать процессору и каким именно способом закодирована инструкция (**R**, **I**, **S**, **B**, **U** или **J**). В 32-битных инструкциях два младших бита всегда равны `11` (эта особенность связана  с расширением для сжатых инструкций, когда их длина равна 16 бит). Все инструкции, которые будут использоваться в этой лабораторной работе, являются 32-битными, т.е. у них младших бита будут равны `11`.

Почти все инструкции имеют поле `Func3`, и некоторые – поле `Func7`. Их названия определены их разрядностью: 3 и 7 бит, соответственно. В этих полях (если они есть у инструкции) закодировано уточнение операции. Например, код операции `0010011` указывает на то, что будет выполняться некоторая операция на АЛУ между значением из регистрового файла и константой. Поле `Func3` уточняет операцию, для данного примера, если оно будет равно 0x0, то АЛУ выполнит операцию сложения между значением из регистра и константой из инструкции. Если `Func3` равно 0x6, то логическое ИЛИ. Внимательно изучи представленные инструкции: 

![](../../../technical/Other/Pic/rv32i.png)

Обратите внимание на операции `slli`, `srli` и `srai`, это операции сдвига на константную величину. У этих инструкций немного измененный формат кодирования **I\***. Формат кодирования **I** предоставляет 12-битную константу. Сдвиг 32-битного числа более, чем на 31 не имеет смысла. Для кодирования числа 31 требуется всего 5 бит. Выходит, что из 12 бит константы используется только 5 бит для операции сдвига, а оставшиеся 7 бит – не используются. А, главное ("о, какое совпадение"), эти 7 бит находятся ровно в том же месте, где у других инструкций находится поле `Func7`. Поэтому, чтобы у инструкций `slli`, `srli` и `srai` использующих формат **I** не пропадала эта часть поля, к ней относятся как к полю `Func7`.

На рисунке ниже приводится фрагмент из [`оригинальной спецификации RISC-V`](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf). Сверху приводятся 6 форматов кодирования инструкций: **R**, **I**, **S**, **B**, **U** и **J**, а ниже приводятся конкретные значения полей внутри инструкции. Под `rd` подразумевается 5-битный адрес регистра назначения (**r**egister **d**estination), `rs1` и `rs2` - 5-битные адреса регистров источников (**r**egister **s**ource), `imm` - константа (immediate), расположение и порядок битов которой указывается в квадратных скобках. Обратите внимание, что в разных форматах кодирования константы имеют различную разрядность, а их биты упакованы по-разному. Для знаковых операций константу предварительно знаково расширяют до 32 бит. Для беззнаковых расширяют нулями до 32 бит.

![](../../../technical/Other/Pic/rv32i_spec.png)

Как видно из таблицы выше, базовый набор целочисленных инструкций использует шесть форматов кодирования команд. Младшие 7 бит любой инструкции – это поле `opcode` (код операции). По значению этого поля устройство управления (в частности декодер инструкций) определяет какая именно инструкция должна быть выполнена и каким из шести способов она закодирована.

Некоторые инструкции также имеют поля `Func3` и `Func7`, в которых кодируется уточняющая информацию касательно выполняемой операции. Некоторые форматы инструкций кодируют адреса регистров: `rs1` и `rs2` – адреса регистров-операндов, `rd` – адрес регистра назначения.

Поле `imm` кодирует в себе непосредственное значение операнда – константу, просто число, которое может быть использовано в вычислении выражения или адреса операнда в памяти. Обратите внимание, что в разных форматах кодирования биты константы могут быть перемешанными.

| Кодирование |                                              Описание                                                           |
|-------------|-----------------------------------------------------------------------------------------------------------------|
|    R-тип    | Арифметические и логические операции над двумя регистрами с записью результата в третий                         |
|    I-тип    | Инструкции с 12-битным непосредственным операндом                                                               |
|    S-тип    | Инструкции записи в память (типа store)                                                                         |
|    B-тип    | Инструкции ветвления                                                                                            |
|    U-тип    | Инструкции с 20-битным «длинным» непосредственным операндом, сдвинутым влево на 12                              |
|    J-тип    | Единственная инструкция jal, осуществляющая безусловный переход по адресу относительно текущего счетчика команд |


### Неподдерживаемые инструкции

В базовом наборе инструкций **RISC-V** к операциям `SYSTEM` относятся `ECALL` и `EBREAK`, к операциям `MISC-MEM` – операция `FENCE`. В реализуемом процессорном ядре эти инструкции не должны приводить ни к каким изменениям. Иначе говоря, они должны быть реализованы как инструкция `NOP` (**no operation**).
Инструкция `FENCE` в **RISC-V** необходима при работе с несколькими аппаратными потоками, или хартами (hart – «hardware thread»). В **RISC-V** используется расслабленная модель памяти (**relaxed memory model**): потоки «видят» все инструкции чтения и записи, которые исполняются другими потоками, однако видимый порядок этих инструкций может отличаться от реального. Инструкция `FENCE`, использованная между двумя инструкциями чтения и/или записи гарантирует, что остальные потоки увидят первую инструкцию перед второй. Реализация `FENCE` является опциональной в **RISC-V** и в данном случае в ней нет необходимости, так как в системе не предполагается наличия нескольких аппаратных потоков.
Инструкции `ECALL` и `EBREAK` должны вызывать исключение с последующим переходом в обработчик исключения (вызова операционной системы и перехода в привилегированный режим работы). Помимо этого, их вызов должен обновить содержимое некоторых управляющих регистров (**Control & Status Registers** – **CSR**). В рамках данного курса лабораторных работ эти инструкции не будут использоваться, а потому могут быть реализованы как `NOP`.


### Предлагаемая микроархитектура процессора RISC-V

Ниже приводится микроархитектура процессора RISC-V. Регистр `PC` (Program Counter – счетчик команд) подключен к адресному входу памяти инструкций. Считываемая инструкция декодируется основным декодером, вследствие чего он выставляет управляющие сигналы для всех блоков процессора (мультиплексоры, АЛУ, интерфейс взаимодействия с памятью).

![Микроархитектура](../../../technical/Labs/Pic/uarch_md.png)

Предложенная микроархитектура процессора `CYBERcobra 3000 Pro 2.0` из прошлой лабораторной имеет схожую структуру, за исключением нескольких дополнительных блоков, среди которых:

- память данных (**Data Memory**)
  - хранит данные с которыми работает программа, 
  - использует косвенно-регистровую адресацию, то есть на вход адреса подается результат сложения значения какого-либо регистра и константы из инструкции,
  - использует более сложный интерфейс управления;
- блоки знакорасширения (**SE**, **Sign Extend**) – получают на вход 12 или 20-битную константу и расширяют её до 32-битного числа путем **клонирования** старшего бита во все недостающие старшие биты числа;
- устройство управления aka основной дешифратор команд, или просто основной дешифратор (**Main Decoder**) – комбинационная схема, которая получает на вход инструкции и в зависимости от их кода операции `opcode` и полей `funct3`, `funct7` выдает всем блокам процессора управляющие сигналы (синие на рисунке) приводящие к выполнению требуемых инструкций. Например, если основной дешифратор получает `opcode = 0110011`, `funct3 = 000`, `funct7 = 0100000`, что соответствует операция вычитания между значениями регистров, значит дешифратору нужно сделать так, чтобы на АЛУ попали значения из регистрового файла, значит управляющие сигналы мультиплексоров будут переключены в положение `ex_op_a_sel = 00` и `ex_op_b_sel = 000`, а код операции АЛУ `alu_op_o = 01000`. И тому подобное для всех остальных выходных сигналов дешифратора команд.

На представленном рисунке сигналы `mem_size_o` и `mem_req_o` объединены в единый сигнал, однако, при описании модуля это будут два разных сигнала. Это связано с тем, что в следующей лабораторной работе эти сигналы будут игнорироваться


### Интерфейс памяти

Интерфейс памяти использует несколько сигналов для взаимодействия с памятью: `mem_req_o` (этот выход должен быть выставлен в 1 каждый раз, когда необходимо обратиться к памяти – считать или записать), `mem_we_o` (выставляется в 1, если необходимо записать данные в память, и 0 – если считать из памяти) и `mem_size_o` (указывающий размер порции данных необходимых для передачи; возможные значения указаны в таблице ниже). Перечисленных сигналов достаточно для того, чтобы основная память понимала: обращаются ли к ней в данный момент, нужно ли записывать или считывать данные, и о какой порции данных идет речь.

|Название|Значение `mem_size_o`|          Пояснение           |
|--------|---------------------|------------------------------|
|LDST_B  |         3'd0        |Знаковое 8-битное значение    |
|LDST_H  |         3'd1        |Знаковое 16-битное значение   |
|LDST_W  |         3'd2        |32-битное значение            |
|LDST_BU |         3'd4        |Беззнаковое 8-битное значение |
|LDST_HU |         3'd5        |Беззнаковое 16-битное значение|


### Main Decoder - Основной дешифратор команд RISC-V

Как говорилось ранее, дешифратор инструкций в процессоре служит для преобразования инструкции в набор управляющих сигналов, необходимых для ее исполнения. Еще один пример: для выполнения инструкции загрузки слова из памяти данных в регистровый файл **lw**, дешифратор должен направить в АЛУ два операнда и код операции АЛУ (сложение) для вычисления адреса. Для модуля загрузки-выгрузки из памяти (**load-store unit** – интерфейс взаимодействия с памятью) декодер передает запрос на считывание данных (`mem_req_o`) и размер слова (`mem_size_o`). Наконец, декодер решает, будут ли записаны данные в регистровый файл (`gpr_we_a_o`).

Управляющие сигналы на выходе декодера зависят от трех полей инструкции: `opcode`, `funct3` и `funct7`. Обратите внимание, что расположение этих полей одинаково для всех типов инструкций. Это сделано для удобства декодирования. При этом поля `funct3` и `funct7` могут отсутствовать для некоторых инструкций.

|Название сигнала|                                            Пояснение                                           |
|----------------|------------------------------------------------------------------------------------------------|
|fetched_instr_i |Инструкция для декодирования, считанная из памяти инструкций                                    |
|ex_op_a_sel_o   |Управляющий сигнал мультиплексора для выбора первого операнда АЛУ                               |
|ex_op_b_sel_o   |Управляющий сигнал мультиплексора для выбора второго операнда АЛУ                               |
|alu_op_o        |Операция АЛУ                                                                                    |
|mem_req_o       |Запрос на доступ к памяти (часть интерфейса памяти)                                             |
|mem_we_o        |Сигнал разрешения записи в память, «write enable» (при равенстве нулю происходит чтение)        |
|mem_size_o      |Управляющий сигнал для выбора размера слова при чтении-записи в память (часть интерфейса памяти)|
|gpr_we_a_o      |Сигнал разрешения записи в регистровый файл                                                     |
|wb_src_sel_o    |Управляющий сигнал мультиплексора для выбора данных, записываемых в регистровый файл            |
|illegal_instr_o |Сигнал о некорректной инструкции (на схеме не отмечен)                                          |
|branch_o        |Сигнал об инструкции условного перехода                                                         |
|jal_o           |Сигнал об инструкции безусловного перехода jal                                                  |
|jalr_o          |Сигнал об инструкции безусловного перехода jalr                                                 |

Единственным входным сигналом этого модуля является `fetched_instr_i` (поэтому у него суффикс `_i`). Остальные сигналы являются выходными (поэтому у них суффикс `_o`).

В системе команд **RV32I** два младших бита поля opcode всегда равны `11`, таким образом декодер понимает, что будут исполняться именно 32-битные инструкции, а не 16-битные, например. **Main decoder** должен выдать единицу на выходе `illegal_instr_o` в случае:

- неравенства двух младших битов opcode значению `11`;
- некорректного значения `funct3` или `funct7` для данной операции;
- если значение `opcode` не совпадает ни с одним из известных и следовательно операция не определена.

При реализации декодера его удобнее описывать разбив все инструкции на однотипные группы, как это сделано ниже. Коды операций в таблице 5-битные потому, что 2 младших бита полноценного 7-битного кода операции должны отдельно проверяться и быть равны `11`

|Операция|Opcode|                                       Описание операции                                      |          Краткая запись            |
|--------|------|----------------------------------------------------------------------------------------------|------------------------------------|
|OP      |01100 |Записать в `rd` результат вычисления АЛУ над `rs1` и `rs2`                                    |`rd = alu_op(rs1, rs2)`             |
|OP_IMM  |00100 |Записать в `rd` результат вычисления АЛУ над `rs1` и `imm`                                    |`rd = alu_op(rs1, imm)`             |
|LUI     |01101 |Записать в `rd` значение непосредственного операнда U-типа `imm_u`                            |`rd = imm << 12`                    |
|LOAD    |00000 |Записать в `rd` данные из памяти по адресу `rs1+imm`                                          |`rd = Mem[rs1 + imm]`               |
|STORE   |01000 |Записать в память по адресу `rs1+imm` данные из `rs2`                                         |`Mem[rs1 + imm] = rs2`              |
|BRANCH  |11000 |Увеличить счетчик команд на значение `imm`, если верен результат сравнения `rs1` и `rs2`      |`if cmp_op(rs1, rs2) then PC += imm`|
|JAL     |11011 |Записать в `rd` следующий адрес счетчика команд, увеличить счетчик команд на значение `imm`   |`rd = PC + 4; PC += imm`            |
|JALR    |11001 |Записать в `rd` следующий адрес счетчика команд, в счетчик команд записать `rs1`              |`rd = PC + 4; PC = rs1`             |
|AUIPC   |00101 |Записать в `rd` результат сложения непосредственного операнда U-типа `imm_u` и счетчика команд|`rd = PC + (imm << 12)`             |
|MISC-MEM|00011 |Не производить операцию `illegal_instr_o = 0`                                                 | `-`                                |
|SYSTEM  |11100 |Не производить операцию `illegal_instr_o = 0`                                                 | `-`                                |


## Инструменты

В первую очередь язык описания аппаратуры **Verilog** – это язык. С помощью этого языка человек объясняет либо синтезатору какое он хочет получить устройство, либо симулятору – как он хочет это устройство проверить. Синтезатор – это программа, которая создает из логических элементов цифровое устройство по описанию предоставляемому человеком. Синтезатору внутри **Vivado** нужно объяснить что ты от него хочешь. Например, чтобы спросить дорогу у испанца, придется делать это на испанском языке, иначе он ничем не сможет помочь. Если ты знаешь испанский, то это можно сделать еще и разными способами. В **Verilog** точно также – одно и то же устройство можно описать разным кодом, но результат синтеза будет одним и тем же. Однако, часто два разных кода одинаковые по смыслу могут синтезироваться в разную аппаратуру, хотя функционально они будут идентичны, но могут отличаться, например, скоростью работы. Или одни и те же специальные языковые конструкции могут применяться для синтезирования разных цифровых элементов.

Основной дешифратор – это комбинационная схема, то есть, для каждой комбинации входных сигналов существует только одна комбинация выходных сигналов, потому что комбинационные схемы не содержат элементов памяти.

Можно по-разному описывать комбинационные схемы, например, через конструкцию `assign`. Для основного дешифратора отлично подойдет конструкция `case`, которая превратится не в мультиплексор, а в комбинационную схему с оптимальными параметрами критического пути. В доверилоговую эпоху разработчикам пришлось бы строить гигантские таблицы истинности и какие-нибудь [карты Карно](https://ru.wikipedia.org/wiki/Карта_Карно), искать оптимальные схемы реализации. Сегодня эту задачу решает синтезатор, по описанию устройства сам находит наиболее эффективное решение.

Разница с реализацией мультиплексора в том, что в этом случае справа от знака равно всегда стоит константа. Получается это такой способ описать таблицу истинности. В такой код легко вносить правки и искать интересующие фрагменты.

Рассмотрим пример ниже. Внутри конструкции `always`, перед конструкцией `case` указываются значения по-умолчанию. Благодаря этому пропадает необходимость указывать все сигналы внутри каждого обработчика `case`, достаточно указать только те, что имеют значение отличное от значения по-умолчанию. Представленный пример реализует комбинационную схему, которая при `cucumber == 4'b1100` будет выставлять сигнал `c == 1'b0`, то есть отличное, от значения по-умолчанию. Сигнал `a` никак не меняется, поэтому он не указан в соответствующем обработчике. Если сигнал `size == 1'b0`, то `b` будет равен 1, а `d` равен 0. Если сигнал `size == 1'b1`, то наоборот – `b` будет равен 0, а `d` равен 1.


``` verilog
`define   PICCOLI   4'b1100

// ... какие-то еще дефайны

module tequila (
  input       [3:0] cucumber;
  input             size;
  output reg        a, b, c, d;       // reg, потому что будет внутри always
);

  always @ * begin                    // * - значит комбинационная схема
    a = 1'b0;                         // значения по-умолчанию
    b = 1'b0;
    c = 1'b1;
    d = 1'b0;
    case(cucumber)
      // ... какие-то еще обработчики
      `PICCOLI: begin                 // если на cucumber значение `PICCOLI
                  c = 1'b0;
                  case (size)
                    1'b0: b = 1'b1;   // если на size значение 1'b0
                    1'b1: d = 1'b1;   // если на size значение 1'b1
                  endcase
                end
      // ... какие-то еще обработчики
      default:  begin                 // так как описаны не все значения
                  a = 1'b0;           // cucumber, то чтобы case не было  
                  b = 1'b0;           // защелки (latch) на выходе
                  c = 1'b1;           // нужно обязательно добавлять 
                  d = 1'b0;           // default
                end
    endcase
  end

endmodule
```


## Задание

Необходимо реализовать на языке **Verilog** модуль основного дешифратора команд однотактного процессора RISC-V в соответствии с предложенной микроархитектурой. Далее приводится прототип разрабатываемого модуля.

``` verilog
module decoder_riscv (
  input       [31:0]  fetched_instr_i,
  output  reg [1:0]   ex_op_a_sel_o,      // выходы сделаны регистрами,
  output  reg [2:0]   ex_op_b_sel_o,      // потому что всё устройство 
  output  reg [4:0]   alu_op_o,           // будет комбинационной схемой
  output  reg         mem_req_o,          // описанной внутри блока 
  output  reg         mem_we_o,           // always, а слева от знака равно
  output  reg [2:0]   mem_size_o,         // внутри always должны стоять
  output  reg         gpr_we_a_o,         // всегда только регистры,
  output  reg         wb_src_sel_o,       // даже если в итоге схема
  output  reg         illegal_instr_o,    // превратится в
  output  reg         branch_o,           // комбинационно устройство
  output  reg         jal_o,              // без памяти
  output  reg         jalr_o              // 
);

// тут твой код декодера

endmodule
```

После реализации модуля основного дешифратора его требуется верифицировать с помощью предложенного (в этой папке репозитория) тестовым окружением [`tb_decode_riscv_obf.v`](./tb_decode_riscv_obf.v). Для его работы также потребуется скачать файл [`defines_riscv.v`](./defines_riscv.v). Название вашего модуля и его входных-выходных сигналов должны строго соответствовать названиям в предложенном прототипе. Модуль `decode_riscv` уже подключен внутри тестового окружения. После добавления файлов в проект останется только запустить на симуляцию `tb_decode_riscv_obf.v` и дождаться вердикта в терминале. В случае правильной работы модуля в конце симуляции будет выведено сообщение `SUCCESS`. В случае неправильной работы, в терминал будет выведен машинный код инструкции с названиями сигналов, которые выдают неправильный значения. Чтобы отладить свое устройство потребуется дешифровать инструкцию (определить что она делает), понять что она должна делать и сравнить с тем как реализовано в коде. Исправить ошибки и повторить симуляцию.

Существует также третий вариант результата симуляции – нет ошибок, и не написано `SUCCESS`. Это значит, что установлено недостаточное время симуляции, другими словами – она не закончилась. В таком случае симуляцию просто нужно продолжить.

В зависимости от стиля оформления, модуль может занимать больше сотни строк кода, но это не делает его реализацию сложной. По сути, дешифратор – это просто большой `case` с описанием того, в каком случае, какие сигналы и чему должны быть равны. Работа требует внимательности, немного усидчивости и понимания выполняемых действий. С огромной вероятностью в коде будут ошибки и их нужно будет исправлять. Ошибки это нормально – все ошибаются, а исправление ошибок дает бесценный опыт разработки. Возможно реализация этого модуля в какой-то момент покажется рутинной, но поверь, по окончании следующей лабораторной работы удовольствие от результата покажет, что оно того стоило.

Дерзай!
