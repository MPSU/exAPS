# Лабораторная работа 1 "Сумматор"

[\[Список лабораторных\]](../README.md) [\[СОДЕРЖАНИЕ\]](../../README.md)

## Цель

Познакомиться с САПР Vivado и научиться реализовывать в нём схемотехнические модули, с помощью конструкций языка Verilog, а также писать к ним тестовое окружение на примере одноразрядного и многоразрядного сумматора.

## Допуск к лабораторной работе

Изучить [описание модулей на языке Verilog](../../Other/Basic%20Verilog%20structures/Modules.md).

## Ход работы

1.	Тренинг по созданию проекта в Vivado;
2.	Изучение, реализация и проверка полного однобитного сумматора;
3.  Изучение реализации полного четырехбитного сумматора;
4.	Реализация полного четырехбитного сумматора;
5.	Реализация 32-битного сумматора.
 
## Теория

Итогом лабораторной работы будет создание устройства, способного складывать два числа. Но перед тем, как учиться создавать подобное устройство, необходимо немного освоиться в самом процессе складывания чисел.

Давайте начнем с примера, и сложим в столбик какую-нибудь пару чисел, например 42 и 79:

![](../../../technical/Labs/Pic/dec_column.png)

2 + 9 = 11	➨ 1 пишем, 1 "в уме".

4 + 7 = 11	➨ +1 "в уме" = 12 — 2 пишем, 1 "в уме".

0 + 0 = 0	➨ +1 "в уме" = 1.

Итого, 121.

Назовём то, что мы звали "1 в уме", переносом разряда.

Теперь попробуем сделать то же самое, только в двоичной системе исчисления. К примеру, над числами 3 и 5. Три в двоичной системе записывается как 011, Пять записывается как 101.

![](../../../technical/Labs/Pic/bin_column.png)

Поскольку в двоичной системе всего две цифры: 0 и 1, один разряд не может превысить 1. Складывая числа 1 и 1, вы получаете 2, что не умещается в один разряд, поэтому мы пишем 0 и 1 в уме. Это снова перенос разряда. Поскольку в двоичной арифметике разряд называют битом, перенос разряда называют переносом бита, а сам разряд, который перенесли — битом переноса.

### Полный однобитный сумматор

Полный однобитный сумматор — это цифровое устройство с тремя входными сигналами: операндами a, b и входным битом переноса, которое складывает их между собой, возвращая два выходных сигнала: однобитный результат суммы и выходной бит переноса. Что такое входной бит переноса? Давайте вспомним второй этап сложения чисел 42 и 79:

4 + 7 = 11, ➨ **+1 в уме** = 12 — 2 пишем, 1 в уме.

**+1 в уме** — это разряд, перенесённый с предыдущего этапа сложения.

Входной бит переноса — это разряд, перенесённый с предыдущего этапа сложения двоичных чисел. Имея этот сигнал, мы можем складывать многоразрядные двоичные числа путём последовательного соединения нескольких однобитных сумматоров: выходной бит переноса сумматора младшего разряда передастся на входной бит переноса сумматора старшего разряда.

### Реализация одноразрядного сложения

Можно ли как-то описать сложение двух одноразрядных двоичных чисел с помощью логических операций? Давайте посмотрим на таблицу истинности подобной операции

<img src="../../../technical/Labs/Pic/tt1.png" alt="Таблица истинности одноразрядного сложения" width="150"/>

<!-- |a|b| |<b>P</b>|<b>S</b>|
|-|-|-|--------|--------|
| | | |        |        |
|0|0| |<b>0</b>|<b>0</b>|
|0|1| |<b>0</b>|<b>1</b>|
|1|0| |<b>0</b>|<b>1</b>|
|1|1| |<b>1</b>|<b>0</b>| -->

*Таблица истинности одноразрядного сложения*

S — это цифра, записываемая непосредственно в столбце сложения под числами a и b. P — это цифра, записываемая левее, которая обычно записывается, если произошел перенос разряда. Как мы видим, перенос разряда происходит только в случае, когда оба числа одновременно равны единице. При этом в этот момент значение S обращается в 0, и результат записывается как 10, что в двоичной системе означает 2. Кроме того, S = 0 и в случае, когда оба операнда одновременно равны нулю. Вы можете заметить, что S = 0 в тех случаях, когда а и b равны, и не равно нулю в противоположном случае. Подобное свойство описывается логической операцией исключающее или:

<img src="../../../technical/Labs/Pic/tt2.png" alt="Таблица истинности операции Исключающее ИЛИ (XOR)" width="190"/>

*Таблица истинности операции Исключающее ИЛИ (XOR)*

Для бита переноса всё ещё проще — он описывается операцией логическое И:

<img src="../../../technical/Labs/Pic/tt3.png" alt="Таблица истинности операции И" width="160"/>

*Таблица истинности операции И*

Давайте нарисуем цифровую схему, связывающую входные и выходные сигналы с помощью логических элементов, соответствующих ожидаемому поведению:

![](../../../technical/Labs/Pic/1_fig-1.png) 

*Рисунок 1. Цифровая схема устройства, складывающего два операнда с сохранением переноса (полусумматора)*

Вроде все замечательно, но есть проблема. В описании полного однобитного сумматора сказано, что у него есть три входа, а в наших таблицах истинности и на схеме выше их только два. На самом деле, на каждом этапе сложения в столбик мы всегда складывали три числа: цифру верхнего числа, цифру нижнего числа, и единицу в случае переноса разряда из предыдущего столбца или ноль, в случае отсутствия переноса. Таким образом, таблицы истинности немного усложняются:

<img src="../../../technical/Labs/Pic/tt4.png" alt="Таблица истинности сигналов полного однобитного сумматора" width="250"/>

*Таблица истинности сигналов полного однобитного сумматора*

Поскольку теперь у нас есть и входной и выходной биты переноса, для их различия добавлены индексы “in” и “out”.

Как в таком случае описать S? Например, как `а ^ b ^ Ріn`, где `^` — операция исключающего ИЛИ. Давайте сравним такую операцию с таблицей истинности. Сперва вспомним, что Исключающее ИЛИ — ассоциативная операция [`(a^b)^c = a^(b^с)`], т.е. нам не важен порядок вычисления. Предположим, что Pin равен нулю. Исключающее ИЛИ с нулем дает второй операнд (`a^0=a`), значит `(a^b)^0 = a^b`. Это соответствует верхней половине таблицы истинности для сигнала S.

Предположим, что Pin равен единице. Исключающее ИЛИ с единицей дает нам отрицание второго операнда (`a^1=!a`), значит `(a^b)^1=!(a^b)`. Это соответствует нижней половине таблицы истинности.

Для выходного бита переноса, всё гораздо проще. Он равен единице, когда хотя бы два из трех операндов равны единице, это значит что необходимо попарно сравнить все операнды, и если найдется хоть одна такая пара, он равен единице. Это утверждение можно записать следующим образом:

`Роut = (a&b) | (а&Pіn) | (b&Ріn)`, где `&` — логическое И, `|` — логическое ИЛИ.

Цифровая схема устройства с описанным поведением выглядит следующим образом:

![](../../../technical/Labs/Pic/1_fig-2.png)

*Рисунок 2. Цифровая схема полного однобитного сумматора*

## Практика

Реализуем схему полусумматора (рис.1) в виде модуля, описанного на языке Verilog.

Модуль half_adder имеет два входных сигнала и два выходных. Входы `А` и `В` идут на два логических элемента - `А` И `В` (А & В), `А` Исключающее ИЛИ `В` (А ^ В).

```systemverilog
module half_adder(
  input      A,   // Входные сигналы
  input      B,

  output     S,    // Выходной сигнал
  output     P

  );
  
  assign S = A ^ B;
  assign P = A & B;

  endmodule

```
*Листинг 1. Verilog-код модуля half_adder*

По данному коду, САПР сможет реализовать следующую схему:

![](../../../technical/Labs/Pic/example_vivado.png)

*Рисунок 3. Цифровая схема модуля half_adder, сгенерированная САПР Vivado*

Схема похожа на ту, что мы сделали сами, но как проверить, что эта схема не содержит ошибок и делает именно то, что от нее ожидается?

Для этого, необходимо провести моделирование этой схемы. Во время моделирования, на вход схемы подаются входные воздействия. Каждое изменение входных сигналов схемы приводит к каскадному изменению состояния внутренних цепей, которые в итоге меняют выходные сигналы.

Подаваемые на схему входные воздействия формируются верификационным окружением. Верификационное окружение (или тестбенч) — это особый несинтезируемый модуль, который не имеет входных или выходных сигналов. Ему не нужны входные сигналы, поскольку он сам является генератором всех своих внутренних сигналов, и ему не нужны выходные сигналы, поскольку этот модуль ничего не вычисляет, только подает входные воздействия на проверяемый модуль. Внутри тестбенча можно использовать конструкции из несинтезируемого подмножества языка Verilog, в частности программный блок `initial`, в котором команды выполняются последовательно, что делает тестбенч чем-то отдаленно похожим на проверяющую программу. Поскольку изменение внутренних цепей происходит с некоторой задержкой относительно изменений входных сигналов, при моделировании есть возможность делать паузы между командами. Это делается с помощью специального символа #, после которого стоит количество отсчётов времени симуляции, которое нужно пропустить перед следующей командой.

Перед тем как писать верификационное окружение, необходимо составить план того, как будет проводиться проверка устройства (составить верификационный план).

Поскольку устройство настолько простое, что число всех его возможных входных наборов воздействий равно восьми, и не имеет памяти (т.е. каждый раз, когда модулю подаются на вход одни и те же значения, оно вернет тот же результат), мы можем проверить его работу, перебрав все возможные варианты его работы.

```systemverilog
module testbench();             // <- Не имеет ни входов, ни выходов!
  reg a, b, p, s;

  mod2 DUT(                   // <- Подключаем проверяемый модуль
    .A    (a),
    .B    (b),
    .P    (p),
    .S    (s)
);

  initial begin
    s1 = 'd0; s2 = 'd0;            // <- Подаём на входы модуля тестовые
    #10;                           //    воздействия
    s1 = 'd0; s2 = 'd1; 
    #10;                           // <- Делаем паузу в десять отсчётов
    s1 = 'd1; s2 = 'd0;            //    времени симуляции перед очередным
    #10;                           //    изменением входных сигналов
    s1 = 'd1; s2 = 'd1; 
  end
endmodule
```
*Листинг 2. Verilog-код тестбенча для модуля example*

![](../../../technical/Labs/Pic/example_simulation.png)

*Рисунок 4. Временная диаграмма, моделирующая работу схемы с рис.3*

В данной лаборатной работе вам предстоит реализовать схему полного однобитного сумматора (_рис. 2_).

### Полный четырехбитный сумматор

Складывать несколько однобитных чисел не сильно впечатляет, поэтому сейчас мы займемся по-настоящему крутыми вещами — будем складывать пары четырехбитных чисел! Четырехбитные числа — это сила, они позволяют выбрать любое число от 0 до 15, а если сложить два числа с сохранением переноса, то вы получите диапазон результатов вплоть до 31! И вся эта вычислительная мощь будет у вас прямо под рукой — бери и пользуйся!
До этого мы реализовали только сложение одного столбца в столбик, теперь мы хотим реализовать всю операцию сложения в столбик. Как это сделать? Сделать ровно то, что делается при сложении в столбик: сначала сложить младший столбец, получить бит переноса для следующего столбца, сложить следующий и т.д. Давайте посмотрим, как это будет выглядеть на схеме (для простоты, внутренняя логика однобитного сумматора скрыта, но вы должны помнить, что каждый прямоугольник — это та же самая схема, что была представлена выше).

![](../../../technical/Labs/Pic/1_fig-5.png)

*Рисунок 5. Схема четырехбитного сумматора*

Фиолетовой линией на схеме показаны провода, соединяющие выходной бит переноса сумматора предыдущего разряда, с входным битом переноса сумматора следующего разряда.
Как же реализовать модуль, состоящий из цепочки других модулей? Половину этой задачи, мы уже сделали, когда писали тестбенч к однобитному полусумматору в _Листинге 2_ — мы создавали модуль внутри другого модуля и подключали к нему провода. Теперь надо сделать тоже самое, только с чуть большим числом модулей.

```systemverilog
module fulladder4(
    input [3:0] А,
    input [3:0] В,
    input       Ріn,
    output[3:0] S,
    output      Роut
);

    wire [2:0] Р;     // Обратите внимание на то, как подключены
                      // входы и выходы Pin/Pout во всех модулях!
    fulladder a0(
        .a(А[0]),
        .b(В[0]),
        .Pin(Ріn),
        .S(S[0]),
        .Pout(Р[0])
    );

    fulladder a1(
        .a(А[1]),
        .b(В[1]),
        .Pin(Р[0]),
        .S(S[1]),
        .Pout(Р[1])
    );

    fulladder a2(
        .a(А[2]),
        .b(В[2]),
        .Pin(Р[1]),
        .S(S[1]),
        .Pout(Р[2])
    );

    fulladder a3(
        .a(А[3]),
        .b(В[3]),
        .Pin(Р[2]),
        .S(S[3]),
        .Pout(Роut)
    );

endmodule
```
*Листинг 3. Verilog-код модуля fulladder4*

![](../../../technical/Labs/Pic/1_fig-6.png)

*Рисунок 7. Схема четырехбитного сумматора, сгенерированная САПР Vivado*

Схема может показаться запутанной, но если присмотреться, вы увидите, как от шин A, B и S отходят линии к каждому из сумматоров, а бит переноса передается от предыдущего сумматора к следующему.

## Задание

Вам необходимо реализовать полный 32-битный сумматор. Соединять вручную 32 однотипных модуля чревато усталостью и ошибками, поэтому можно, например, сначала создать 4-битный сумматор (либо другой разрядности), а затем из него сделать 32-битный. 

### Порядок выполнения задания

1. Согласно [руководству по созданию проекта в Vivado](../../Other/Vivado-trainer.md):
	1. Создайте проект;
	2. В `Design Sources` проекта создайте `Verilog`-файл `fulladder.v`.
2. Опишите в файле модуль `fulladder`, схема которого представлена на _Рис. 2_.
3. В `Design Sources` проекта создайте `Verilog`-файл `fulladder32`.
4. Опишите модуль `fulladder32` так, чтобы в нем выполнялось поразрядное сложение двух 32-битных чисел. Его можно реализовать как через последовтаельное соединение 32-х однобитных сумматоров `fulladder.v` (как было сделано для 4-битного сумматора), так и через последовательное соединение восьми 4-битных сумматоров (тогда перед этим необходимо описать 4-битный сумматор в отдельном модуле) 
5. Обратите внимание, что входной бит переноса должен подаваться на сумматор, выполняющий сложение нулевого разряда, выходной бит переноса соединяется с выходным битом переноса сумматора, выполняющего сложение 31-го разряда (см. реализацию четырехбитного сумматора в _Листинге 3_).
6. В `Simulation Sources` проекта создайте `Verilog`-файл `testbench`.
7. Вставьте содержимое файла `tb_fulladder.v`, расположеного рядом с данным документом.
8. Запустите моделирование.
9. Убедитесь, что модуль работает корректно.
