# Лабораторная работа 4 "Примитивное программируемое устройство"

[`Список лабораторных`](../README.md) [`СОДЕРЖАНИЕ`](../../README.md)

В этой лабораторной работе на основе ранее разработанных блоков памяти и АЛУ ты соберешь простой учебный процессор с архитектурой `CYBERcobra 3000 Pro 2.0`. Это нужно для более глубокого понимания принципов работы программируемых устройств, чтобы проще было понять архитектуру RISC-V в будущем.


## Цель

Реализовать простейшее программируемое устройство с архитектурой `CYBERcobra 3000 Pro 2.0`


## Ход работы

1. Изучить принцип работы процессоров (соответствующий раздел [#теории](#теория-про-программируемое-устройство))
2. Познакомиться с архитектурой и микроархитектурой `CYBERcobra 3000 Pro 2.0` (раздел про эту [#архитектуру](#архитектура-cybercobra-3000-pro-20-и-ее-микроархитектура))
3. Изучить необходимые для описания процессора конструкции verilog (раздел [#инструменты](#инструменты-для-реализации-процессора))
4. Реализовать процессор с архитектурой `CYBERcobra 3000 Pro 2.0` ([#задание по разработке аппаратуры](#задание-по-реализации-процессора))
5. Написать программу для процессора и на модели убедиться в правильности ее выполнения ([#задание по разработке программы](#задание-по-проверке-процессора))

[ниже идет необязательный пункт для тех, кто успевает и хочет проверить работу на стенде]

6. Проверить работу процессора на ПЛИС (подключить переключатели и светодиоды ко входам и выходам устройства)



## Теория про программируемое устройство

В обобщенном виде, процессор включает в себя память, АЛУ, устройство управления и интерфейсную логику для организации ввода/вывода. Также, в процессоре есть специальный регистр PC (Program Counter – счетчик команд), который хранит в себе число – адрес ячейки памяти, в которой лежит инструкция, которую нужно выполнить. Инструкция тоже представляет собой число, в котором закодировано что нужно сделать и с чем это нужно сделать.

Алгоритм работы процессора следующий: из памяти считывается инструкция по адресу PC, устройство управление дешифрует полученную инструкцию (то есть определяет какую операцию нужно сделать, где взять операнды и куда разместить результат) и выполняет ее, выдавая всем блокам процессора (АЛУ, регистровый файл, мультиплексоры) управляющие сигналы, после чего значение PC изменяется и все снова повторяется для новой инструкции.

Любая инструкция приводит к изменению состояния памяти. В случае процессора с архитектурой `CYBERcobra 3000 Pro 2.0`, который будет рассмотрен далее, инструкции изменяют либо содержимое регистрового файла, либо значение PC. В первом случае используются вычислительные инструкции. Во-втором случае используются инструкции ветвления. Если процессор обрабатывает вычислительную инструкцию, то PC в следующий раз будет на 1 больше (`PC = PC + 1`), а регистровый файл сохранит результат некоторой операции на АЛУ или данные со входного порта. Если же обрабатывается инструкция ветвления, то значение PC, в случае безусловного перехода или успешного условного перехода, увеличится на значение константы закодированной внутри инструкции `PC = PC + const`.


## Архитектура CYBERcobra 3000 Pro 2.0 и ее микроархитектура

В качестве первого разрабатываемого программируемого устройства предлагается использовать архитектуру специального назначения `CYBERcobra 3000 Pro 2.0`, которая была разработана в МИЭТ. Главным достоинством данной архитектуры является простота ее понимания. Главным ее минусом является неоптимальность в ввиду неэффективной реализации кодирования инструкций, что приводит к наличию неиспользуемых битов в программах. Но это неважно, так как основная цель разработки процессора с архитектурой `CYBERcobra 3000 Pro 2.0` это более глубокое понимание принципов работы программируемых устройства, которое поможет при разработке более сложного процессора с архитектурой RISC-V.

![logo](../../../technical/Labs/Pic/logoCC3000.svg)

Простота архитектуры `CYBERcobra 3000 Pro 2.0` проявляется, в том числе, за счет отсутствия памяти данных, то есть данные над которыми выполняется программа могут быть расположены только в регистровом файле. Также в таком процессоре почти полностью отсутствует устройство управления (формально оно существует, но состоит только из проводов и пары логических вентилей). Архитектурой предусмотрена поддержка 19 инструкций (5 типов команд): 16 инструкций выполняются на АЛУ (10 вычислительных и 6 операций сравнения для условного перехода), одна инструкция безусловного перехода, инструкция загрузки константы и инструкция загрузки данных с внешнего устройства.

Будем рассматривать архитектуру (функции процессора) и микроархитектуру (реализация процессора) одновременно, прослеживая рассуждения их разработчика. Для начала реализуем базовый функционал, подключив счетчик команд PC к памяти инструкций IM и к сумматору, прибавляющему 1 к PC, выход которого подключен ко входу PC. Каждый раз, когда будет происходить тактовый импульс значение PC будет увеличиваться на 1, тем самым указывая на следующую инструкцию. Последовательное считывание программы из памяти готово. Так как операции будут выполняться только над данными в регистровом файле, то его можно сразу подключить к АЛУ, соединив порты чтения со входами операндов АЛУ, а результат операции АЛУ подключив к порту на запись. Полученный результат изображен на картинке ниже.

![Переключение инструкций](../../../technical/Labs/Pic/ppd_1.png)

Чтобы добавить поддержку каких-либо инструкций необходимо договориться как они будут кодироваться (относится к вопросам архитектуры). Вычислительные инструкции требуют информацию о том по каким адресам регистрового файла лежат операнды, по какому адресу будет сохранен результат и какая операция должна быть выполнена. Для этого в инструкции выделяются соответствующие поля: 5 бит ([27:23]) для кодирования операции для АЛУ, два раза по 5 бит для кодирования адресов операндов в регистровом файле ([22:18] и [17:13]) и 5 бит для кодирования адреса результата ([4:0]). Ниже демонстрируется деление 32-битной инструкции на поля ALUop, RA1, RA2 и WA.

![Вычислительные инструкции](../../../technical/Labs/Pic/ppd_code_1.png)

``` C
  reg[WA] ← reg[RA1] {ALUop} reg[RA2]
```

Чтобы процессор правильно реагировал на эти инструкции требуется подключить биты выхода RD памяти инструкции IM (на котором после считывания появляется очередная инструкция) к соответствующим входам адреса регистрового файла и управляющему входу АЛУ. В таком случае, когда PC будет указывать на ячейку памяти, в которой лежит, например, следующая 32-битная инструкция:

> 0000 00111 00100 01000 00000000 11100

будет выполнена операция `reg[28] = reg[4] | reg[8]`, потому что ALUop = 00111, что соответствует операции логического ИЛИ, WA = 11100, то есть 28-ой регистр, RA1 = 00100 (4-ый регистр) и RA2 = 01000 (8-ой регистр). Ниже иллюстрируется фрагмент микроархитектуры, поддерживающий вычислительные операции на АЛУ. Так как пока что другие инструкции не поддерживаются, то вход WE3 регистрового файла всегда равен 1 (это временно).

![Поддержка вычислительных инструкций](../../../technical/Labs/Pic/ppd_2.png)

Информация как-то должна попадать в регистровый файл, для этого добавим инструкцию загрузки константы по адресу WA. Чтобы аппаратура могла различать, когда ей нужно выполнять операцию на АЛУ, а когда загружать константу, назначим один бит инструкции определяющим "что именно будет записано в регистровый файл": результат с АЛУ или константа из инструкции. За это будет отвечать 28-ой бит инструкции WS (Write Source). Если WS == 1, значит выполняется вычислительная инструкция, а если WS == 0, значит нужно загрузить константу в регистровый файл. Сама константа имеет разрядность 23 бита ([27:5] биты инструкции) и должна быть знакорасширена до 32-х бит, то есть к 23-битной константе нужно приклеить слева 9 раз 23-ий знаковый бит константы. Нет ничего страшного в том, что биты константы попадают на те же поля, что и ALUop, RA1 и RA2, потому что когда выполняется инструкция загрузки константы не важно что будет выдавать АЛУ в этот момент (ведь на вход регистрового файла приходит константа). Аначит не важно и что приходит на АЛУ в качестве операндов и кода операции. Ниже демонстрируется деления 32-битной инструкции на поля ALUop, RA1, RA2, WA, WS и const, который нарисован с перекрытием полей.

![Плюс константа](../../../technical/Labs/Pic/ppd_code_2.png)

``` C
  reg[WA] ← const
```

Так как вход записи уже занят результатом операции АЛУ, его потребуется мультиплексировать со значением константы из инструкции, которая предварительно знакорасширяется в блоке SE. На входе WD3 регистрового файла появляется мультиплексор, управляемый 28-м битом инструкции, который и определяет что будет записано: константа или результат вычисления на АЛУ. Например, в такой реализации следующая 32-битная инструкция поместит константу –1 в регистр по адресу 5:

> 000 0 11111111111111111111111 00101

Далее приводится фрагмент микроархитектуры, поддерживающий вычислительные операции на АЛУ и загрузку констант из инструкции в регистровый файл.

![Поддержка добавления константы](../../../technical/Labs/Pic/ppd_3.png)

Чтобы процессор мог взаимодействовать с внешним миром добавим возможность загрузки данных с внешних устройств в регистр по адресу WA. Появляется третий тип инструкции, который определяет третий источник ввода для регистрового файла. Одного бита WS для выбора одного из трех источников будет недостаточно, поэтому расширим это поле до 2 бит. Теперь, когда `WS == 0` будут загружаться данные с внешних устройств, когда `WS == 1` – будет загружаться константа, а при `WS == 2` будет загружаться результат вычисления АЛУ. Остальные поля в данной инструкции не используются.

![Плюс внешние устройства](../../../technical/Labs/Pic/ppd_code_3.png)

``` C
  reg[WA] ← IN
```

По аналогии с загрузкой констант увеличиваем входной мультиплексор до 3 входов и подключаем к нему управляющие сигналы – [29:28] биты инструкции. Выход OUT подключается к первому порту на чтение регистрового файла. Значение на выходе OUT будет определяться содержимым ячейки памяти по адресу RA1. Ниже приводится фрагмент микроархитектуры, поддерживающий вычислительные операции на АЛУ, загрузку констант из инструкции в регистровый файл и загрузку данных с внешних устройств.

![Поддержка внешних устройств](../../../technical/Labs/Pic/ppd_4.png)

С реализованным набором инструкций полученное устройство нельзя назвать процессором – пока что это продвинутый калькулятор. Добавим поддержку инструкции безусловного перехода, при выполнении которой программа будет перепрыгивать через заданное количество команд. Чтобы аппаратура отличала эту инструкцию от других будем использовать 31-ый бит B. Если B == 1, значит это инструкция безусловного перехода, и надо прибавить к PC константу. Если B == 0, значит это какая-то другая инструкция и надо прибавить к PC единицу. Так как PC 8-битный, то в качестве константы используются 8 бит инструкции [12:5]. Инструкция с новым полем B демонстрируется ниже.

![Плюс безусловный переход](../../../technical/Labs/Pic/ppd_code_4.png)

``` C
  PC ← PC + const
```

Так как второй вход сумматора счетчика команд занят числом 1, то для реализации безусловного перехода этот вход надо мультиплексировать с константой. Мультиплексор при этом управляется 31-ым битом B, который и определяет, что будет прибавляться к PC. Кроме этого, так как теперь не любая инструкция приводит к записи в регистровый файл, появляется необходимость управлять входом WE3 так, чтобы при операциях безусловного перехода запись в регистровый файл не производилась. Для этого можно было бы выделить еще один бит инструкции, но в целях экономии можно провернуть следующий фокус. Изменим адреса мультиплексора на входе WD3 регистрового файла с 0, 1, 2, на 1, 2, 3, а ко входу WE3 подключим логическое ИЛИ между битами инструкции 29 и 28. Тогда, если сигнал WS равен 1, 2 или 3 (01, 10 или 11 в двоичной записи), то логическое ИЛИ между битами WS будет равняться 1, то есть будет происходить запись в регистровый файл. Выставляя поле WS == 0 запись происходить не будет. Так как не все входы мультиплексора задействованы не забывай использовать `default` в `case` при его описании на Verilog. Итого, чтобы произвести безусловный переход необходимо выставить сигнал `B == 1`, чтобы к PC прибавлялась константа, а `WS == 0`, чтобы в регистровый файл на этой инструкции не происходила запись. Микроархитектура с добавлением новой инструкции представлена ниже.

![Поддержка безусловного перехода](../../../technical/Labs/Pic/ppd_5.png)

Осталось добавить поддержку инструкции условного перехода, для идентификации которой используется оставшийся 30-ый бит C. Если бит `C == 1`, то АЛУ, в соответствии с кодом операции ALUop, должен сравнить операнды по адресам RA1 и RA2, и в случае, если условие дает результат true, то к значению PC прибавляется константа из инструкции `PC = PC + const`, а если false, то `PC = PC + 1`.

![Плюс условный переход](../../../technical/Labs/Pic/ppd_code_5.png)

``` C
  if (reg[RA1] {ALUop} reg[RA2])
    PC ← PC + const
  else
    PC ← PC + 1
```

Сигнальные линии, которые управляют АЛУ и подают на его входы операнды уже существуют. Поэтому на схему необходимо добавить только логику управления мультиплексором на входе сумматора счетчика команд так, чтобы во время безусловного перехода мультиплексор всегда переключался на константу, а во время условного только в том случае, если возникает флаг на выходе АЛУ. С помощью логического ИЛИ подключается бит безусловного перехода (тогда, если `B == 1`, то переход в любом случае произойдет). С помощью логического И перемножается бит C и значение флага flag, благодаря чему переход будет только тогда, когда и 30-ый бит равен 1, и флаг на выходе АЛУ равен 1. Ниже приводится итоговый вариант микроархитектуры процессора `CYBERcobra 3000 Pro 2.0`.

![Поддержка условного перехода](../../../technical/Labs/Pic/ppd_6.png)

Итого, архитектура `CYBERcobra 3000 Pro 2.0` поддерживает 5 типов инструкций, которые кодируются следующим образом (иксами помечены биты, которые не задействованы в данной инструкции):

1. 10 вычислительных инструкций `0 0 11 ALUop RA1 RA2 xxxx xxxx WA`
2. Инструкция загрузки константы `0 0 10 const WA`
3. Инструкция загрузки из внешних устройств `0 0 01 xxx xxxx xxxx xxxx xxxx xxxx WA`
4. Безусловный переход `1 0 00 xxx xxxx xxxx xxxx const xxxx xxxx`
5. 6 инструкций условного перехода `0 1 00 ALUop RA1 RA2 const x xxxx`

При кодировании инструкций используются следующие поля:

- B – однобитный сигнал указывающий на выполнение безусловного перехода
- C – однобитный сигнал указывающий на выполнение условного перехода
- WS – двухбитный сигнал указывающий источник данных для записи в регистровый файл:  
  - 0 – не пишем
  - 1 – с внешних устройств
  - 2 – константа
  - 3 – результат с АЛУ
- ALUop – 5-битный сигнал кода операции АЛУ (в соответствии с таблицей из прошлой лабораторной)
- RA1 и RA2 – 5-битные адреса операндов из регистрового файла
- const – 8-битная константа для условного/безусловного перехода (или 23-битная константа для загрузки в регистровый файл)
- WA – 5-битный адрес регистра, в который будет записан результат

Напишем простую программу для этого процессора, которая в бесконечном цикле увеличивает значение регистра по адресу 5 на 1. Сначала напишем программу на псевдоассемблере (используя предложенную мнемонику):

``` C
  reg[5] ← 0                // загрузить константу 0 в регистр 5
  reg[6] ← 1                // загрузить константу 1 в регистр 6
  reg[5] ← reg[5] + reg[6]  // сложить регистр 5 с регистром 6 и поместить результат в регистр 5
  PC ← PC – 1               // перейти к предыдущей инструкции
```

Теперь в соответствии с кодировкой инструкций переведем программу в машинные коды:

```
  0 0 10   00000000000000000000000  00101
  0 0 10   00000000000000000000001  00110
  0 0 11 00000 00101 00110 00000000 00101
  1 0 00  000000000000000  11111111 00000
```

Полученную программу можно помещать в память программ и выполнять на процессоре.


## Инструменты для реализации процессора

Так как все модули процессора написаны, основная часть кода описания процессора будет связана с подключением этих модулей друг к другу. Рассмотрим пример подключения модулей. Ниже приводится описание трех модулей, два из которых будут подключены в третьем. Модуль `and_3` реализует логическое И между тремя входными сигналами.

``` verilog
module and_3 (
  input   a, b, c,
  output  y
); 

  assign y = a & b & c;

endmodule
```

![and_3](../../../technical/Labs/Pic/and_3.png)

Модуль `inv` подает на выход `y` инверсию входного сигнала.

``` verilog
module inv (
  input	  a,
  output  y
); 

  assign y = ~a;

endmodule
```

![inv](../../../technical/Labs/Pic/inv.png)

В модуле `dut` модули `and_3` и `inv` соединяются друг с другом. Для того, чтобы подключить модуль внутри другого модуля требуется написать имя подключаемого модуля, например `and_3`, после этого указать название примитива, допустим `and_3 andgate`. Например, нам может понадобиться 3 копии модуля `and_3`, тогда мы сможем подключить 3 экземпляра модуля `and_3`, используя различные наименования для прототипов (`andgate_1`, `andgate_2` и тому подобное). После имени прототипа в скобках указываются внутренние имена модулей и названия сигналов, которые к этим входам подключаются. Символ точка, перед наименованием порта отсылает к реальному порту подключаемого модуля. В скобках обозначается куда будут подключаться сигналы в top-модуле (в данном случае top-модуль это `dut`). 

У модуля `andgate` выход `y` подключается к проводу `n1`, который вторым концом подключается ко входу `a` модуля `inverter`. Ко входу `a` модуля `andgate` подключается входной сигнал `a` модуля `dut`, и так далее.

``` verilog
module dut (
  input   a, b, c,
  output  y
); 

  wire n1;  // создаем однобитный провод n1

  and_3 andgate ( // подключаем блок and_3 и даем этому примитиву имя andgate
    .a(a),  // подключаем ко входу a блока andgate сигнал a со входа блока dut
    .b(b),  // подключаем ко входу b блока andgate сигнал b со входа блока dut
    .c(c),  // подключаем ко входу c блока andgate сигнал c со входа блока dut
    .y(n1)  // подключаем к выходу y блока andgate провод n1
  );

  inv inverter (
    .a(n1), // подключаем ко входу a блока inverter провод n1
    .y(y)   // подключаем к выходу y блока inverter выход y блока dut
  );

endmodule
```

![modules](../../../technical/Labs/Pic/modules.png)

Для реализации блоков знакорасширения подходит использование оператора объединения `{}`, с помощью которого можно объединить несколько отдельных сигналов, в том числе многократно дублируя некоторые из них. В примере ниже проводу `out_o` будут подключены следующие сигналы: `{in[1], in[0], in[3], in[3], in[3], in[4], in[3], in[2], in[1], in[0]}`.

``` verilog
  wire [9:0] out;
  wire [4:0] in;

  assign out = {in[1:0], {3{in[3]}}, in};
```

## Задание по реализации процессора

На языке Verilog необходимо собрать процессор из ранее разработанных блоков. В главном модуле `CYBERcobra` необходимо объединить ранее разработанные модули памяти инструкций (Instruction Memory), с помещенной внутрь программой (следующее задание), регистрового файла (Register File) и арифметико-логического устройства (ALU), добавив регистр счетчика команд (program counter) и  логику его работы, в соответствии с ранее представленной микроархитектурой.

``` verilog
module CYBERcobra (
  input           CLK,
  input           rst,
  input   [31:0]  IN,
  output  [31:0]  OUT
);

reg [7:0] pc; // создание регистра счетчика команд

// ваш код с подключенными IM, RF и ALU

endmodule
```

![Микроархитектура CYBERcobra 3000 Pro 2.0](../../../technical/Labs/Pic/ppd_6.png)

## Задание по проверке процессора

Для проверки работоспособности разработанного процессора с архитектурой `CYBERcobra 3000 Pro 2.0` необходимо написать программу в машинных кодах в соответствии с одним из индивидуальных заданий (вариант берется у преподавателя) и продемонстрировать ее корректную работу в симуляции или на стенде.

В качестве входных данных используются либо данные со входа `sw_i`, который поступает с 16-ти переключателей на плате `sw_i[31:0] = {16{SW[15]}, SW[15:0]}`, либо через константы, передаваемые внутри инструкции, которые будут именоваться в заданиях, как `a`, `b` и так далее.

Для демонстрации результата используется выходной сигнал `out_o[31:0]` – подключается к 16 светодиодам на плате {16'h0000, LED[15:0]} = OUT[31:0], то есть старшие 16 бит результата не отображаются. Однако, используя тернарный оператор ` ? : ` можно легко реализовать управление выводом `out_o` в зависимости от нажатия на кнопку (кнопка зажата – на светодиоды выводятся старшие 16 битов, кнопка не нажата – выводятся младшие 16 битов).

Так как `out_o` подключен к выходу регистрового файла, то во время работы программы на нем будут отображаться какие-то случайные промежуточные результаты. Для постоянного вывода в `out_o` в конце программы необходимо последней инструкцией поставить безусловный переход со смещением 0, то есть чтобы переход был к `PC + 0`, а в биты, соответствующие адресу регистра источника 1, установить адрес регистра с ответом.

Сигнал `rst` можно подключить к одной из кнопок. Для того, чтобы сброс (rst == 1) работал корректно необходимо инициализировать (задавать начальные значения при старте программы) используемые в программе регистры.

1. Вычислить [циклический сдвиг](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) вправо `a` >> `sw_i`. Вывести результат в `out_o`.
Пример: `a` = `01011`, `sw_i` = `10`. Результат вычислений: `out_o = 11010`.    

2. Вычислить `a - IN` без использования операции вычитания. Вывести результат в `out_o`.
Пример: `sw_i = 011`, `a = 100`. Результат вычислений: `001`.   

3. Вычислить [циклический сдвиг](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) влево `a` << `sw_i`. Вывести результат в `out_o`.
Пример: `a` = `01011`, `sw_i` = `10`. Результат вычислений: `out_o = 01101`.    
---
4. Вычислить `a * IN` посредством суммы `sw_i` значений `a`. Вывести результат в `out_o`.
Пример: `a = 5`, `sw_i = 4`. `5 * 4 == 5 + 5 + 5 + 5 = 20`.    

5. Если `sw_i[1:0] == 00`, то в `out_o` выводится `a`,  если `sw_i[1:0] == 01`, то `b`,  если `sw_i[1:0] == 10`, то `c`,  если `sw_i[1:0] == 11`, то `d`.
Пример: `a = 00`, `b = 10`, `c = 11`, `d = 01`, `sw_i = 01`. Результат вычислений: `out_o = 10`.  

6. Если `sw_i` является степенью двойки, то вывести `out_o =  1`, в противном случае, `out_o = 0`.
Пример 1: `sw_i = 100`. Результат вычислений: `out_o = 1`.   
Пример 2: `sw_i = 110`. Результат вычислений: `out_o = 0`.     

7. Найти количество нулей в двоичном представлении числа `sw_i`. Вывести результат в `out_o`.
Пример: `sw_i` = `0110_0010`. Результат вычислений: `out_o = 101`.   

8. Найти наибольший двоичный разряд числа `sw_i`, значение которого равно `1`. Если такого нет, вывести `32`. Вывести результат в `out_o`.
Пример: `sw_i = 0110`. Результат вычислений: `out_o = 10`.    

9. Сформировать число, состоящее из чётных двоичных разрядов числа `sw_i`. Вывести результат в `out_o`.
Пример: `sw_i = 11_1011_1000`, результат вычислений `out_o = 1_0100`.  

10. Найти количество единиц в двоичном представлении числа `sw_i` (обрати внимание, `sw_i` – знаковое число). Вывести результат в `out_o`.
Пример: `sw_i = 0101_0110`. Результат вычислений: `out_o = 100`. 

11. Найти количество двоичных разрядов, в которых различаются числа `sw_i` и `a`. Вывести результат в `out_o`.
Пример: `sw_i = 0110`, `a = 1110`. Результат вычислений: `out_o = 01`.   

12. Вывести в `out_o` подряд все единицы входного числа `sw_i`. 
Пример: `sw_i = 1011011011`. Результат вычислений:`out_o` = `1111111`.   
---

13. Найти остаток от деления `sw_i` на `a`. Вывести результат в `out_o`.
Пример: `sw_i = 101`, `a = 10`. Результат вычислений: `out_o = 01`.   

14. Найти и вывести в `out_o` количество вхождений `a[2:0]` в `sw_i` без пересечений.
Пример: `a[2:0] = 010`, `sw_i = 1101_0101`. Результат вычислений: `out_o = 01`.   

15. Определить, сколько раз встречается `11` в двоичном представлении `sw_i` без пересечений. Вывести результат в `out_o`.
Пример: `sw_i = 01110`. Результат вычислений: `out_o = 01`.   

16. Вывести в `out_o` результат целочисленного деления `a`/`sw_i`.
Пример: `sw_i = 10`, `a = 111`. Результат вычислений: `out_o = 11`.   

17. Вывести в `out_o` сумму `sw_i[3:0]` + `sw_i[7:4]` + `sw_i[11:8]` + `sw_i[15:12]`.
Пример: `sw_i = 0001_0010_00011_0000`. Результат вычислений: `out_o = 110`.   

18. В числе `sw_i` заменить справа-налево каждое `00` на `11`. Вывести результат в `out_o`.
Пример: `sw_i = 101000`. Результат вычислений: `out_o = 101011`.   
---

19. Поменять местами чётные биты числа `sw_i` с нечётными битами этого числа (то есть соседние биты поменять местами). Вывести результат в `out_o`.
Пример: `sw_i = 1010_0111`. Результат вычислений: `out_o = 0101_1011`.   

20. Инвертировать первые `sw_i` бит числа `a`. Вывести результат в `out_o`.
Пример: `sw_i = 11`, `a = 1010_0011`. Результат вычислений: `out_o = 1010_0100`.   

21. Вывести n-ый член [последовательности Фибоначчи](https://ru.wikipedia.org/wiki/Числа_Фибоначчи) Fn. n = `sw_i`. Вывести результат в `out_o`.
Пример: `sw_i = 100`. Результат вычислений: `out_o = 10`.   

22. Поменять в числе `a` разряды `i = IN[4:0]` и `j = IN[9:5]`. Вывести результат в `out_o`.
Пример: `a = 1001`, `sw_i[9:0] = 00000_00001`. Значит, в числе `а` необходимо поменять местами `а[0]` и `a[1]`. Результат вычислений: `out_o = 1010`.
---

23. Вычислить `a * IN` с использованием операций сложений и сдвига ("в столбик"). Вывести результат в `out_o`. [Пример](https://studfile.net/preview/8921792/page:5/)   

24. Вывести в `out_o` n-ый член [арифметической прогрессии](https://ru.wikipedia.org/wiki/Арифметическая_прогрессия) aN, где a1 = `a`, d = `sw_i[15:8]`, n = `sw_i[7:0]` (d и n неотрицательные).
Пример: `sw_i[15:8] = 0000_0010`, `sw_i[7:0] = 0000_0011`, `a = 01`. Результат вычислений: `out_o = 101`.    

25. *Зажечь все светодиоды на 50% яркости ([подсказка](http://wiki.amperka.ru/конспект-arduino:шим))   

26. Удалить все вхождения `sw_i[2:0]` из `a` со сдвигом вправо (заполняя удаленные области). 
Пример: `a = 10011010`, `sw_i[2:0] = 101`. Результат вычислений: `out_o = 10010`

Дерзай!
