# Лабораторная работа 1. Арифметико-логическое устройство

[`Список лабораторных`](../README.md) [`СОДЕРЖАНИЕ`](../../README.md)

Так как основной задачей процессора является обработка цифровых данных, одним из его основных блоков является арифметико-логическое устройство (АЛУ). Задача АЛУ производить над входными данным арифметические и поразрядно логические операции.

## Цель

На языке Verilog описать блок арифметико-логического устройство (АЛУ) и подтвердить правильность работы с помощью тестового окружения.


## Общий ход выполнения работы

1. При необходимости установить Vivado ([`Руководство по установке Vivado`](../../Other/Install%20Vivado.md))
2. Изучить устройство и принцип работы АЛУ (раздел [#теория](#теория))
3. Изучить языковые конструкции verilog для реализации АЛУ (раздел [#инструменты](#инструменты))
4. Внимательно ознакомиться с заданием (раздел [#задание](#задание))
5. Создать новый проект для всего цикла лабораторных работ (пример в [`Создание базового проекта с прошивкой ПЛИС в Vivado`](../../Other/Vivado-trainer.md))
6. Описать АЛУ на языке verilog (практическая работа)
7. Реализовать тестовое окружение для АЛУ (практическая работа, пример в [`Тестовые окружения`](../../Other/Testbench.md))

[ниже идут два необязательных пункта для тех, кто успевает и хочет проверить работу на стенде]

8. Подключить к проекту файл констрейнов (прописать какие входы/выходы АЛУ каким ножкам ПЛИС соответствуют)
9. Проверить работу АЛУ на ПЛИС (подключить переключатели и светодиоды ко входам и выходам)


## Теория

Арифметико-логическое устройство (АЛУ, Arithmetic Logic Unit – ALU) – это блок процессора, выполняющий арифметические и поразрядно логические операции. Разница между арифметическими и логическими операциями, в отсутствии у последних бита переноса, так как логические операции происходят между однобитными числами и дают однобитный результат, а в случае АЛУ (речь про эту лабу) одновременно между 32-мя однобитными парами чисел. В логических операциях результаты значений отдельных битов друг с другом никак не связаны.

Также, кроме результата операций АЛУ формирует флаги, которые показывают выполняется ли заданное условие. Например, выведет 1, если один операнд меньше другого.

АЛУ представляет собой комбинационную схему (то есть без элементов памяти), на входы которой поступают информационные (операнды) и управляющие (код операции) сигналы, в ответ на что на выходе появляется результат заданной операции. АЛУ бывает не комбинационной схемой, но это скорее исключение.

![АЛУ MIPS](../../../technical/Labs/Pic/alu_1.png)

На рисунке выше изображен пример АЛУ, используемый в книге "[Цифровая схемотехника и архитектура компьютера](../../README.md#цифровая-схемотехника-и-архитектура-компьютера-risc-v)" Харрис и Харрис. На входы `A` и `B` поступают операнды с разрядностью *N*. На трехбитный вход `F` подается код операции. Например, если туда подать 000, то на выходе `Y` появится результат операции *логическое И* между битами операндов `A` и `B`. Если на `F` подать 010, то на выходе появится результат сложения. Это лишь пример, разрядность и коды могут отличаться в зависимости от количества выполняемых операций и архитектуры.

Существует несколько подходов к реализации АЛУ, отличающиеся внутренней организацией. Некоторые из подходов освещаются на [`лекции 3`](../../Lectures/03.%20Digital%20arithmetics.md). В лабораторных работах применяется повсеместно используемый подход мультиплексирования операций, то есть, подключение нескольких операционных устройств (которые выполняют какие-то операции, например сложения, логическое И и т.п.) к мультиплексору, который будет передавать результат нужного операционного устройства на выходы АЛУ.

Рассмотрим на примере все того же АЛУ MIPS из книги Харрисов. На рисунке ниже, в левой его части, изображена внутренняя организация этого АЛУ предложенная Харрисами, справа – таблица соответствия кодов операциям. На выходе схемы (внизу) стоит четырехвходовый мультиплексор, управляемый двумя из трех битов `F`. К его входам подключены *N* логических И, *N* логических ИЛИ, *N*-разрядный сумматор и Zero Extend – устройство делающее из однобитного числа *N*-битное число, дополняя нулями слева.

К одному из входов этих операционных устройств подключен `A` без изменений, а ко второму подключен выход двухвходового мультиплексора управляемого оставшимся битом *F*. То есть `F[2]` определяет что будет вторым операндом: `B` или `~B`. Вдобавок `F[2]` подается на входной перенос сумматора, то есть, когда `F[2] == 1` на выходе сумматора появляется результат операции `A + ~B + 1`, что то же самое, что и `A – B` (о сумматорах, входных переносах и вычитании на [`лекции 3`](../../Lectures/03.%20Digital%20arithmetics.md)).

![АЛУ MIPS внутри](../../../technical/Labs/Pic/alu_2.png)

Посмотрим, что будет, если на вход `F` такого АЛУ подать 111. Будет выполняться операция SLT, что сокращение от Set Less Then – выдать 1, если `A` меньше `B` и 0 – в противном случае. Биты `F[1:0]` переключат мультиплексор на выход блока Zero Extend. На вход Zero Extend поступает старший бит выхода сумматора, этот бит отвечает за знак результата. Так как `F[2] == 1`, значит сумматор вычисляет `A + ~B + 1`, то есть `A – B`, значит, если `A` < `B`, то результат разницы будет отрицательный, а старший бит `Y[N-1] == 1`. Если `A` не меньше `B`, то разница будет неотрицательная, а `Y[N-1] == 0`, как и требуется от этой операции.

![АЛУ MIPS пример](../../../technical/Labs/Pic/alu_3.png)

Преимущество такой организации АЛУ в его простой модификации, настройке под нужные коды операций, читаемости кода и масштабируемости. Можно легко добавить или убрать требуемые операции.

## Инструменты

Основными инструментами для реализации проектов на лабораторных работах будут:
- FPGA, или по-русски ПЛИС (программируемая логическая интегральная схема), о них рассказывается на [`второй лекции`](../../Lectures/02.%20Instruments.md))
- Vivado - это система автоматизированного проектирования, которая позволяет общаться с ПЛИС и конфигурировать ее (как [`установить`](../../Other/Install%20Vivado.md), как [`создать проект`](../../Other/Vivado-trainer.md))
- Verilog HDL - язык описания аппаратуры, который позволяет "объяснить" Vivado (и не только), как должно "выглядеть" твое устройство. Грубо говоря, языки описания аппаратуры позволяют рисовать схемы цифровых устройств с помощью кода - описывать аппаратуру. Если твои познания о verilog около нулевые, то стоит прочитать "[`что такое языки описания аппаратуры`](../../Other/What%20is%20HDL.md)" и "[`базовые конструкции языка verilog`](../../Other/Verilog%20syntax.md)".

Как было сказано выше, АЛУ можно реализовать мультиплексируя результаты нескольких операционных устройств. На языке verilog можно описать мультиплексор с произвольным количеством входов используя несколько языковых конструкций. Рассмотрим пару таких: тернарный оператор `x ? t : f` и `case`.

С помощью тернарного оператора легко описываются двухвходовые мультиплексоры, управляемые однобитным сигналом управления.

![Мультиплексор2в1](../../../technical/Labs/Pic/alu_8.png)

``` verilog
  assign Y = S ? D[1] : D[0];
```

Тут используется [синтаксический сахар](https://ru.wikipedia.org/wiki/Синтаксический_сахар). На самом деле под `S` подразумевается `S == 1`, можно писать и так, и так. То есть, если сигнал `S` равен 1, то на выход `Y` подключается `D[1]`, в противном случае подключается `D[0]`. При этом сигналы `Y`, `D[1]` и `D[0]` могут иметь любую разрядность, но одинаковую друг с другом.

Если нужен мультиплексор с большим количеством входов, то можно использовать вложенные тернарные операторы, то есть вместо входов `D[1]` и `D[0]`, из прошлого примера, вставлять другие тернарные операторы. Однако, их аппаратная реализация будет представлять последовательно соединенные мультиплексоры, что увеличивает [критический путь](https://github.com/MPSU/APS/blob/technical/Other/Basic%20definitions.md) (говорится на [`лекции 2`](../../Lectures/02.%20Instruments.md)).

Альтернативный и более наглядный способ использовать конструкцию `case`, которая используется внутри блока `always @ *`. Блок `always` "выполняет" свое тело каждый раз по событию. `*` в качестве события подразумевает реакцию на выходе при любом изменении входного сигнала, то есть внутри такого `always` описывается комбинационная схема. 

Допустим нужно реализовать следующий мультиплексор:

![Мультиплексор](../../../technical/Labs/Pic/alu_6.png)

Опишем его на verilog в виде отдельного модуля со входами и выходами, для наглядности. Для этого нам потребуется 5 входов: 4 входа для четырехбитных мультиплексируемых сигналов и один двухбитный вход для управления, и один четырехбитный выход. Особенность языка такая, что конструкция `always` требует использования `reg` слева от знака равно внутри нее. Даже, если в результате такого описания не появится ни один регистр. Так как `y` слева от знака равно внутри `always`, то он должен быть помечен как `reg`, хотя, еще раз – он не будет регистром в этом случае, потому что `always @ *` это комбинационная схема. Такие вот особенности. В итоге, код ниже превратится в картинку выше. Оператор `case` выполняет ветку в соответствии со значением в скобках. Для данного примера, если `s == 2'b10`, то к выходу `y` подключается значение входа `d2`.

``` verilog
module mux4in1 (
  input       [1:0] s,
  input       [3:0] d0, d1, d2, d3,
  output  reg [3:0] y // отмечен reg, но он НЕ reg
);

  always @ * begin  // * - значит реакция на любые изменения,
                    // то есть, это комбинационная схема
    case (s)
      2'b00: y = d0;
      2'b01: y = d1;
      2'b10: y = d2;
      2'b11: y = d3;
    endcase
  end

endmodule
```

Рассмотрим еще один пример, в котором нет желания использовать все входы мультиплексора, которых должно быть 2 в степени "количества бит сигнала управления". В этом случае **ОБЯЗАТЕЛЬНО** использование конструкции `default:`. Если ее не добавить, то на выходе мультиплексора появится [защелка] `latch` (будет рассмотрена на [`лекции 5`](../../Lectures/05.%20Sequencial%20logic.md)), что в рамках лабораторных работ ни разу не применяется.

Так же в примере демонстрируется возможность описания сразу нескольких мультиплексоров, используя `begin`, `end`.

``` verilog
  //...
    input       [3:0]  ctrl,
    output reg  [7:0]  out1, out2
  //...

  always @ * begin
    case (ctrl)
      4'b0000:  begin
                  out1 = 8'b10101010;
                  out2 = 8'b10010101;
                end
      4'b1001:  begin
                  out1 = 8'b01010101;
                  out2 = 8'b11001100;
                end
		//...
      default:  begin
                  out1 = 8'b0;
                  out2 = 8'b0;
                end
    endcase
  end
  //...
```

Очень удобным на практике оказывается использование определений `define`, например если некоторая константа должна использоваться в нескольких местах кода, то определив ее через `define` можно будет менять ее в одном месте и она тут же поменяется везде. Перед тем как синтезировать verilog-код специальная программа препроцессор заменяет все `define` на их значения, то есть эта вещь исключительно для удобства человека. Обрати внимание на необычный штрих, который используется перед словом `define` и каждый раз у самого определения, когда оно используется.

``` verilog
`define WIDTH 32

module overflow (
  input   [`WIDTH-1 : 0]  a, b,
  output                  of
);

wire [`WIDTH : 0] sum;

assign sum = a + b;
assign of = sum[`WIDTH];

endmodule
```

В случае этого АЛУ, будет удобно использовать `define` для обозначения кодов команд. Во-первых, для того чтобы в `case` не допустить ошибок, а во-вторых – можно было легко менять управляющие коды для повторного использования АЛУ в других проектах (спойлер: это потребуется).

Сам сравни:

``` verilog
//`define SLT 5'b00011
//`define BEQ 5'b11000

//...

always @ *
  case(ALUOp)
  //...
  5'b00011: //...   // вообще же ничего не понятно
  5'b11000: //...   // никуда не годится
```

и

``` verilog
`define SLT 5'b00011
`define BEQ 5'b11000

//...

always @ *
  case(ALUOp)
  //...
  `SLT: //...   // очень понятно
  `BEQ: //...   // так лаконично и красиво
```

С `define` гораздо взрослее, серьезнее и понятнее смотрится. Кстати, сразу на заметку директива `include`. С помощью нее можно подключать файлы подобно `#include` на языке `C`.

``` verilog
`include "define.v" // в котором будут описаны все дефайны

module alu_riscv (  // бла бла бла
```

Кроме озвученного, на языке verilog тебе также потребуется использовать [операции сдвига](https://ru.wikipedia.org/wiki/Битовый_сдвиг), к которым относятся:
- <<  логический сдвиг влево
- \>\>  логический сдвиг вправо
- \>\>\>  арифметический сдвиг вправо

**Поскольку мы будем реализовывать АЛУ для процессора архитектуры rv32i (который работает с 32-битными целочисленными значениями), для операций сдвига мы должны брать только 5 младших бит операнда B. Сами посмотрите: пятью битами можно описать 32 комбинации [0-31], а у операнда А будет использоваться ровно 32 бита. Это обязательное требование, поскольку старшие биты в дальнейшем будут использоваться по другому назначению и если вы упустите это, ваш будущий процессор станет работать неправильно.**

А для явного указания на то, что используемое число является знаковым (то есть оно может быть и положительным и отрицательным), используется директива `$signed`. Пример использования:

``` verilog
  assign Result = $signed(A) >>> B[4:0];
```

В этом примере некоторому сигналу `Result` присваивают результат сдвига знакового числа `A` на значение количества бит получаемых из младших 5 бит сигнала `B`.

После реализации АЛУ также потребуется удостовериться в правильности его работы, для этого будет нужно создать тестовое окружение, пример которого описан в отдельной статье [`Тестовые окружения`](../../Other/Testbench.md).


## Задание

Необходимо на языке verilog реализовать АЛУ с соответствующими картинке разрядностями и логическим выходом Flag.

![АЛУ RISC-V](../../../technical/Labs/Pic/alu_4.png)

Для стандартного набора целочисленных операций архитектуры RISC-V требуется выполнять 16 различных операций. Для кодирования 16 операций было бы достаточно 4 бит, но в лабораторной работе предлагается использовать 5-битный код, что связано с особенностями кодирования инструкций (будет рассмотрено в лекциях 6 и 7). Видно, что старший бит кода операции указывает на то является ли операция вычислительной, или это операция сравнения.

|ALUOp|={flag, add/sub, aluop}|Result                             |Flag                               |Операция                                           |
|-----|-----------------------|-----------------------------------|-----------------------------------|---------------------------------------------------|
| ADD |         0 0 000       |Result = А + В                     | Flаg = 0                          | Сложение                                          |
| SUB |         0 1 000       |Result = А — В                     | Flаg = 0                          | Вычитание                                         |
| SLL |         0 0 001       |Result = А << В                    | Flаg = 0                          | Сдвиг влево                                       |
| SLT |         0 0 010       |Result = А < В (знаковое сравнение)| Flаg = 0                          | Знаковое сравнение                                |
| SLTU|         0 0 011       |Result = А < В                     | Flаg = 0                          | Беззнаковое сравнение                             |
| XOR |         0 0 100       |Result = А ^ В                     | Flаg = 0                          | Побитовое исключающее **ИЛИ**                     |
| SRL |         0 0 101       |Result = А >> В                    | Flаg = 0                          | Сдвиг вправо                                      |
| SRA |         0 1 101       |Result = А >>> В                   | Flаg = 0                          | Арифметический сдвиг вправо (операнд А — знаковый)|
| OR  |         0 0 110       |Result = А \| В                    | Flаg = 0                          | Побитовое логическое **ИЛИ**                      |
| AND |         0 0 111       |Result = А & В                     | Flаg = 0                          | Побитовое логическое **И**                        |
| BEQ |         1 1 000       |Result = 0                         | Flаg = (А == В)                   | Выставить флаг, если **равны**                    |
| BNE |         1 1 001       |Result = 0                         | Flаg = (А != В)                   | Выставить флаг, если **не равны**                 |
| BLT |         1 1 100       |Result = 0                         | Flаg = А < В (знаковое сравнение) | Знаковое сравнение **<**                          |
| BGE |         1 1 101       |Result = 0                         | Flаg = А ≥ В (знаковое сравнение) | Знаковое сравнение **≥**                          |
| BLTU|         1 1 110       |Result = 0                         | Flаg = А < В                      | Беззнаковое сравнение **<**                       |
| BGEU|         1 1 111       |Result = 0                         | Flаg = А ≥ В                      | Беззнаковое сравнение **≥**                       |

**Выражения в этой таблице приведены для примера. Не все из них можно просто переписать — часть этих выражений надо дополнить. Чтобы вы не копировали выражения, в них вставлены неподдерживаемые символы.**

Обратите внимание на инструкции сравнения. Во-первых, мы имеем две похожие пары инструкций:

* `SLT`
* `SLTU`
* `BLT`
* `BLTU`

Первые две инструкции используются для получения "математического" результата. Т.е. результат сравнения будет подан на выходной сигнал `Result` так же, как подается результат операции `ADD` и будет использован в неких вычислениях.  
Вторая пара инструкций вычисляет "логический" результат. Результат операции будет подан на выходной сигнал `Flag` и будет использован при ветвлении.  
Различие между `SLTU` и `SLTU` (или `BLT` и `BLTU`) заключается в том, как мы интерпретируем операнды: как знаковые числа, или как беззнаковые.  
Предположим мы сравниваем два двоичных числа: `1011` и `0100`. Если интерпретировать эти числа как беззнаковые, то это `11` и `4`, результат: `11 > 4`. Однако, если интерпретировать эти числа как знаковые, то теперь это числа `-5` и `4` и в этом случае `-5 < 4`.  
Как мы видим результат одной и той же операции над одними и теми же двоичными числами может зависеть от того, каким образом мы интерпретируем эти двоичные числа. Для большинства операций в АЛУ это не важно: например сложение будет работать одинаково в обоих случаях благодаря свойствам дополнительного кода, а побитовые операции работают с отдельными битами двоичного числа. А вот для операции арифметического сдвига это важно — **операнд А в арифметическом сдвиге должен интерпретироваться как знаковый**.  
По-умолчанию Verilog интерпретирует все сигналы как беззнаковые, если мы хотим изменить это поведение, необходимо воспользоваться конструкцией `$signed`.  
Давайте проговорим еще раз: конструкция `$signed` говорит САПР интерпретировать число, переданное в качестве операнда, как знаковое.

Так как используются не все возможные комбинации входа кода операции ALUOp, то при описании через `case` не забывай использовать `default`. Если описать АЛУ как задумано, то получится что-то похожее на картинку ниже. Но не обязательно, зависит от вашего описания.

![Готовое АЛУ](../../../technical/Labs/Pic/alu_7.png)

Далее идет пример того, как будет выглядеть заголовок модуля разрабатываемого устройства.

``` verilog
module alu_riscv (
  input       [31:0]  A,
  input       [31:0]  B,
  input       [4:0]   ALUOp,
  output  reg         Flag,   // reg потому что тебе потребуется мультиплексор
  output  reg [31:0]  Result  // описанный в case внутри always 
);                            // а в always, слева от "равно", всегда стоит reg

// тут твой код

endmodule
```

После реализации модуля АЛУ его нужно будет проверить с помощью [`тестового окружения`](../../Other/Testbench.md).

Дерзай!
