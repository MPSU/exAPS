# Лабораторная работа 4 "Тракт данных"

Микроархитектуру можно разделить на две части: тракт данных и устройство управления. По тракту данных перемещаются данные (из памяти инструкций, регистрового файла, АЛУ, памяти данных, мультиплексоров), а устройство управления (основной дешифратор команд) получает текущую инструкцию из тракта и в ответ говорит ему как именно выполнить эту инструкцию, то есть управляет тем, как эти данные будут через тракт данных проходить.


## Цель

Описать на языке **Verilog** процессор с архитектурой **RISC-V**, реализовав его тракт данных, использую ранее разработанные блоки, и подключив к нему устройство управления. На текущем этапе реализовать только поддержку обработки слов (то есть БЕЗ инструкций связанных с байтами и полусловами: `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`).


## Ход работы

1. Изучить дополнительные материалы по микроархитектуре ([#теория](#особенности-реализации-упрощенной-однотактной-микроархитектуры-risc-v))
2. Изучить особенности реализации сброса регистров ([#инструменты](#инструменты))
3. Исправить память программ и память данных ([#задание](#задание))
4. Реализовать тракт данных ([#задание](#задание))
5. Подготовить программу и загрузить ее в память программ ([`Индивидуальные задания по RISC-V`](../../Tests/Problems%20RISC-V.md))
6. Сравнить результат работы процессора на модели в **Vivado** и в симуляторе программы ассемблера


## Особенности реализации упрощенной однотактной микроархитектуры RISC-V

Более подробно о архитектуре и базовом наборе команд, псевдоинструкциях и способах кодирования **RISC-V** можно прочитать в [`RV32I`](../../Other/RV32I.md).

Чтобы упростить сборку процессора она будет разбита на две части:

- Первая часть (в рамках этой лабораторной работы) – реализация поддержки всех инструкций связанных с обработкой слов, то есть кроме инструкций связанных с доступом к байтам и полусловам в памяти данных:  `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`;
- Вторая часть (следующая лабораторная работа) – создание блока загрузки и сохранения (прослойки между внешней памятью и ядром процессора), благодаря которому будет реализована поддержка озвученных выше инструкций.

Архитектура **RISC-V** предполагает использование побайтовой адресации памяти, то есть, должна использоваться память, в которой каждый байт информации имеет свой уникальный адрес. При считывании байта из памяти обращение происходит по одному адресу, при использовании полуслов – сразу к двум последовательным адресам, при использовании слов – сразу к 4 последовательным адресам. При этом процессорное ядро оперирует только словами, хотя при доступе к памяти могут быть запрошены байты и полуслова, в этом случае они (байты и полуслова) должны быть расширены до 32 бит нулями или знаком, в зависимости от операции. Упрощение первой части сборки процессора происходит за счет временного отказа от использования байтов и полуслов. В рамках этой лабораторной работы ранее разработанная память инструкций (**Instruction Memory**) будет переработана на  побайтовую, но будет возвращать только слова.

Чтобы пословная память смогла стать побайтовой нужно:

- изменить разрядность ячейки памяти с 32 бит на 8 (таким образом память "дробится" в 4 раза меньшие ячейки, однако имейте в виде, что если оставить такое же количество ячеек памяти, то ее общий объем так же уменьшится в 4 раза)
- запрашивать только слова, то есть не использовать инструкции `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`. С памятью инструкций такой проблемы нет, потому что в **RV32I** от туда всегда считываются только слова, так как инструкция имеет размер 32 бита
- правильно формировать адреса. За одно обращение к памяти инструкций, мы будем обращаться сразу к четырем последовательно лежащим байтам — это значит, что мы пройдем сразу через четыре адреса. Если мы пройдем сразу через четыре адреса, то для перехода к следующей инструкции, счетчик программ PC должен быть увеличен на 4, а не на 1, как это происходило в `CyberCobra`.

Первая часть реализации микроархитектуры потребует модификации ранее разработанных блоков памяти и будет выглядеть следующим образом:

![Микроархитектура](../../../technical/Labs/Pic/uarch_dp.png)


## Инструменты

Особенность регистровой памяти заключается в том, что при подаче питания нельзя достоверно предсказать какое значение будет в ней лежать. Это связано с особенностями строения регистров. Поэтому к регистрам подводят сигналы сброса, которые активируются при включении аппаратуры. При появлении сигнала сброса регистр перезаписывается в значение по-умолчанию.

Существует два способа реализации сброса регистра: синхронный и асинхронный. При синхронном сбросе перезапись осуществляется в момент возникновения фронта тактирующего сигнала. Для следующего примера сброс произойдет, когда `reset` равен единице. То есть, например, если `reset` кратковременно станет единицей, а потом снова нулем, а фронт `clk` произойти не успел, то сброса не будет.

``` verilog
// какой-то код

  input       clk,
  input       reset,
  input [3:0] d,

// какой-то код

  reg   [3:0] q;

  always @ (posedge clk) begin
    if (reset)
      q <= 4'b0;  // что записывается в случае сброса
    else
      q <= d;     // что происходит в обычной ситуации
  end
```

![d-trigger-sync](../../../technical/Labs/Pic/d_reset_sync.png)

При асинхронном сбросе перезапись происходит в момент возникновения сигнала сброса не дожидаясь фронта `clk`.

``` verilog
// какой-то код

  input       clk,
  input       reset,
  input [3:0] d,

// какой-то код

  reg   [3:0]   q;

  always @ (posedge clk or posedge reset) begin // добавляется условие для сигнала сброса
    if (reset)
      q <= 4'b0;  // что записывается в случае асинхронного сброса
    else
      q <= d;     // что происходит в обычной ситуации
  end
```

![d-trigger-async](../../../technical/Labs/Pic/d_reset_async.png)

Для счетчика команд (регистр **Program Counter**, `PC`) необходимо реализовать асинхронный сброс.


## Задание

1. Доработать ранее разработанный блок памяти инструкций (**Instruction Memory**) так, чтобы он мог работать в процессоре с побайтовой адресацией (см раздел [Особенности реализации упрощенной однотактной микроархитектуры RISC-V](#особенности-реализации-упрощенной-однотактной-микроархитектуры-risc-v)). Сохранить объём памяти, путем увеличения числа уменьшившихся ячеек.

### Как инициализировать обновленную память инструкций

При программировании CyberCobra, вы самостоятельно писали программу, вручную составляя каждый бит инструкции. Это было необходимо, чтобы вы прочувствовали, как работают машинные коды, а так же, потому что для CyberCobra не существует компилятора (но вы можете написать такой самостоятельно).  
Поскольку теперь ваш процессор почти полностью соответствует спецификации RISC-V, вы можете пользоваться существующими компиляторами, а значит, теперь для написании программы можно воспользоваться языком ассемблера RISC-V (помните, что пока вы не поддерживаете инструкции `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`).  
Обычно ассемблеры выдают код собранной программы в виде шестнадцатеричных строк. Ранее для инициализации памяти вы пользовались системной функцией `$readmemb`, которая интерпретировала каждый символ в файле инициализации как двоичную цифру. Теперь же, вы можете воспользоваться системной функцией `$readmemh`, которая будет интерпретировать каждый символ как шестнадцатеричный и таким образом не переводить результат работы компилятора из шестнадцатеричного формата в двоичный.  
При записи программы в файл инициализации, вы должны убрать префикс `0x`, если таковой имеется, поскольку `$readmemh` и так уже настроена читать в шестнадцатеричном формате.  
Кроме того, поскольку мы переделали память на побайтовую, каждая ячейка занимает теперь только 8 бит, а не 32. Это значит, что вам необходимо разбить строку на отдельные байты. Более того, после того как вы это сделаете, нарушится порядок байт. Дело в том, что когда инструкция была записана целиком и мы бы читали ее в одну 32-битную ячейку, проблем бы не было: допустим у нас есть инструкции `0xdeadc3b7` и `0xeaf38393`. В памяти со структурой, представленной ниже, они бы разместились следующим образом:

```text
----- 0 слово  --------- 1 слово -----
|[de][ad][c3][b7]|  |[ea][f3][83][93]|
   3   2   1   0       4   3   2   1
  |          нумерация байт          |
```
Слова нумеруются слева на право от младшего к старшему, однако разряды читаются наоборот: слева-направо от младшего к старшему. Когда используем побайтовую память, отдельные байты считаются так же как раньше считались слова, однако после разбиения пробелами, они будут расставлены не в том порядке (смотрите нумерацию байт внизу примера). Таким образом, нам необходимо обратить порядок байт.
Современные текстовые редакторы поддерживают режим множественных курсоров, что позволяет довольно быстро выполнить данную процедуру.

<details>
<summary> Пример такого редактирования </summary>
В VSCode дополнительные курсоры создаются либо через `alt+ЛКМ`, либо через `alt+ctrl+UP`, `alt+ctrl+DOWN`
![](../../../technical/Labs/Pic/multicursor_edit_example.gif)

</details>

2. Реализовать модуль памяти данных (Data Memory) для процессора с архитектурой RISC-V. Память представляет собой однопортовую ОЗУ с 1024-мя 32-битными ячейками, но имеющая 32-битную шину адреса.

![Память данных](../../../technical/Labs/Pic/dm.png)

Реально будет использоваться только [$ceil](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions)(log2(1024)) = 10 из 32 битов входного адреса `RAM[A]`. Для того, чтобы казалось, будто у нас больше памяти, чем есть на самом деле (ведь 32-битным адресом можно адресовать 4GiB памяти), мы сделаем следующее:  
Мы будем работать только с 1024-мя ячейками памяти, но из диапазона старших адресов. При попытке запроса в память по младшим адресам, либо старшим адресам, не входящих в наш диапазон, мы будем выдавать `32h0000_0000` при чтении и отсутствие операции при записи. Вашим диапазоном будет `0xNN000000 – 0xNN0003FF`, где `NN` это последние две цифры студенческого. Например, если мой студенческий `001905`, то 1024 байта памяти должны быть расположены по адресам `0x05000000 – 0x05003FF`. Почему `3FF`? Потому что `10'h3ff == 10'b11111_11111` иными словами, это 10 единиц. Однако помните, что в текущей лабораторной работе мы поддерживаем работу только со словами. Это означает, что обращаться в память можно только по адресам, кратным четырем. Таким образом, наш рабочий диапазон сокращается до `0xNN000000 – 0xNN0003FC` (`3FC` или `1020` — наибольшее среди чисел, меньших либо равных 1023, которое кратно четырем).  
Для создания подобного диапазона перед портом на чтение и сигналом разрешения записи поставим по мультиплексору. Этот мультиплексор будет смотреть на старшие `32 - 10 = 22` бита адреса, и сравнивать их со старшими битами диапазона. Если биты совпадают, значит адрес попадает в наш диапазон. В этом случае на порт чтения мы выдаем данные, подав младшие 10 бит входящего адреса на память. Кроме того, мы пропускаем сигнал разрешения записи.  
В случае если биты не совпадают, данные на порте чтения и сигнале разрешения записи становятся равны нулю.  
Реализацию диапазона можно сделать подобно реализации нулевого регистра регистрового файла.

3. Реализовать тракт данных процессора **RISC-V** с подключенным к нему устройством управления (основной дешифратор команд)

![Микроархитектура](../../../technical/Labs/Pic/uarch_dp.png)

Для верификации полученного устройства необходимо поместить в память программ ранее разработанную программу (согласно [`индивидуальному заданию по RISC-V`](../../Tests/Problems%20RISC-V.md)) и, создав тестовое окружение, генерирующее тактовый сигнал для процессора, сравнить результаты работы в симуляторе **Vivado** и в программе ассемблера. Если результаты совпадают, то полагаем, что процессор работает правильно. Для коммерческого процессора такой проверки недостаточно, но для студенческого – вполне.

Обратите внимание на способ размещения программы в памяти инструкций в разделе [Как инициализировать обновленную память инструкций](#как-инициализировать-обновленную-память-инструкций).

---

<details>
  <summary>Прочти меня, когда выполнишь.</summary>
  Поздравляю, ты сделал(а) свой первый взрослый процессор! Теперь ты можешь говорить:
  
 >Я способен(на) на всё! Я сам(а) полностью, с нуля, сделал(а) процессор с архитектурой RISC-V! Что? Не знаешь, что такое архитектура? Пф, щегол! Подрастешь – узнаешь

</details>




