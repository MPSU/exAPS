# Лабораторная работа 2 "Регистровый файл и память. Примитивное программируемое устройство"

[`Список лабораторных`](../README.md) [`СОДЕРЖАНИЕ`](../../README.md)

Процессор – это программно-управляемое устройство выполняющее обработку информации и управление этим процессом. Очевидно, программа, которая управляет процессором, должна где-то храниться. Данные, с которыми процессор работает, тоже должны быть в доступном месте. Нужна память!

В этой лабораторной работе ты научишься описывать память с различными параметрами на языке verilog, после чего на основе этих блоков и АЛУ из прошлой лабораторной соберешь простой учебный процессор с архитектурой `CYBERcobra 3000 Pro 2.0`. Это нужно для более глубокого понимания принципов работы программируемых устройств, чтобы проще было понять архитектуру RISC-V в будущем.


## Цель

1. Описать на языке verilog элементы памяти для будущего процессора: память команд (Instruction Memory), память данных (Data Memory) и регистровый файл (Register File)
2. Реализовать простейшее программируемое устройство с архитектурой `CYBERcobra 3000 Pro 2.0`


## Ход работы

[Цель #1. Реализация памяти]

1. Изучить способы организации памяти (раздел [#теория про память](#теория-про-память))
2. Изучить конструкции verilog для реализации запоминающих элементов (раздел [#инструменты](#инструменты-для-реализации-памяти))
3. В проекте с прошлой лабораторной реализовать модули: Instruction Memory, Data Memory и Register File ([#задание](#задание-по-реализации-памяти))
4. Проверить с помощью тестового окружения корректность их работы (пример [`тестового окружения`](../../Other/Testbench.md))

[Цель #2. Реализация программируемого устройства]

5. Изучить принцип работы процессоров (соответствующий раздел [#теории](#теория-про-программируемое-устройство))
6. Познакомиться с архитектурой и микроархитектурой `CYBERcobra 3000 Pro 2.0` (раздел про эту [#архитектуру](#архитектура-cybercobra-3000-pro-20-и-ее-микроархитектура))
7. Изучить необходимые для описания процессора конструкции verilog (раздел [#инструменты](#инструменты-для-реализации-процессора))
8. Реализовать процессор с архитектурой `CYBERcobra 3000 Pro 2.0` ([#задание по разработке аппаратуры](#задание-по-реализации-процессора))
9. Написать программу для процессора и на модели убедиться в правильности ее выполнения ([#задание по разработке программы](#задание-по-проверке-процессора))

[ниже идет необязательный пункт для тех, кто успевает и хочет проверить работу на стенде]

10. Проверить работу процессора на ПЛИС (подключить переключатели и светодиоды ко входам и выходам устройства)


## Теория про память

Память – это устройство для упорядоченного хранения и выдачи информации. Различные запоминающие устройства отличаются способом и организацией хранения данных. Более подробно о видах памяти можно будет узнать на лекции `15. Память`. Базовыми характеристиками памяти являются:

- V – объем (количество бит данных, которые единовременно может хранить память)
- a – разрядность адреса (ширина шины адреса, определяет адресное пространство – количество адресов отдельных ячеек памяти)
- d – разрядность хранимых данных (разрядность ячейки памяти, как правило совпадает с разрядностью входных/выходных данных)

В общем случае `V = 2^a * d`

Для объема памяти в 1 килобайт (1024 байта или 8096 бит) разрядность адреса может быть, например, 10 бит (что покрывает 2^10 = 1024 адреса), тогда разрядность хранимых данных должен быть 8 бит. 1024 * 8 = 8096, то есть 1 килобайт. Если разрядность адреса, например, 8 бит (что покрывает 2^8 = 256 адресов), то разрядность данных `d = V / 2^a` это 8096 / 256 = 32 бита.

Однако, может быть такое, что не все ячейки памяти реально реализованы на кристалле микросхемы, то есть некоторые адреса существуют, но по ним не имеет смысла обращаться, а объем памяти, соответственно, не равен `V ≠ 2^a * d` – он меньше. Подобные случаи будут рассмотрены отдельно.

Память можно разделить на категории ПЗУ (постоянное запоминающее устройство) и ОЗУ (оперативное запоминающее устройство). Из ПЗУ можно только считывать информацию, которая попадает в ПЗУ до начала использования памяти и не может изменяться в процессе работы. Из ОЗУ можно считывать и записывать информацию. В самом простом случае ПЗУ имеет один вход адреса `A` и один выход считываемых данных `RD`. На вход `A` подается адрес требуемой ячейки памяти, на выходе `RD` появляются данные, которые хранятся по этому адресу. 

Для ОЗУ требуется больше сигналов. Кроме входного `A` и выходного `RD` добавляются: входные данные для записи `WD`, сигнал синхронизации `CLK`, который определяет момент записи данных и сигнал разрешения на запись `WE`, который контролирует нужно ли записывать данные или только считывать. Для того, чтобы записать информацию в такую память необходимо:

- выставить адрес `A` в который планируется запись данных,
- выставить сами данные для записи на вход `WD`,
- установить сигнал `WE` в состояние разрешения записи (как правило это 1) и
- дождаться перепада из 0 в 1 (фронта) сигнала `CLK` – в этот момент данные будут записаны по указанному адресу. В этот момент на выходе `RD` будут старые данные, хранящиеся по адресу `A`. На одном такте происходит одновременное считывание информации и запись новой.

Так же возможна реализация, в которой вход `RD` и выход `WD` объединены в единый вход/выход `D`. В этом случае операции чтения и записи разделены во времени и используют для этого один единый порт ввода-вывода (`inout`) `D`.

![ОЗУ и ПЗУ](../../../technical/Labs/Pic/ram_rom.png)

Еще одной характеристикой памяти является количество доступных портов. Количество портов определяет к скольким ячейкам памяти можно обратиться одновременно. Проще говоря, сколько входов адреса существует. Все примеры памяти рассмотренные выше являются однопортовыми, то есть у них один порт. Например, если у памяти 2 входа адреса `A1` и `A2` — это двухпортовая память. При этом не важно, можно ли по этим адресам только читать/писать или выполнять обе операции.

Регистровый файл, который будет реализован в рамках данной работы, является трехпортовым, и имеет 2 порта на чтение и 1 порт на запись.

С точки зрения аппаратной реализации память в ПЛИС может быть блочной, распределенной или регистровой. Блочная память – это аппаратный блок памяти, который можно сконфигурировать под свои нужды. Распределенная память (в отличие от блочной) реализуется на конфигурируемых логических блоках. Такая память привязана к расположению конфигурируемых логических блоков ПЛИС и как бы равномерно распределена по всему кристаллу. Вместо реализации логики конфигурируемые логические блоки используются для нужд памяти — это возможно благодаря тому, что LUT'ы есть не что иное как память, которая переконфигурируется под нужды хранения, а не реализаций логики. Минусы – большой объем памяти съест много логики – не выгодно, большой объем выгоднее делать на блочной. Распределенная память есть не у всех семейств – например, у ПЛИС от Altera ее нет, там только блочная. Использование распределенной памяти в этих лабораторных работах не предусмотрено. Регистровая память строится из триггеров внутри конфигурируемых логических блоков. Это самый "дорогой" способ реализации памяти на ПЛИС.

Выбор требуемого типа памяти происходит с использованием языка verilog, что и будет рассмотрено далее.


## Инструменты для реализации памяти

Память на языке verilog объявляется подобно регистрам, используя слово `reg`. Но, кроме разрядности (разрядности ячеек памяти, в данном случае) после имени регистра (памяти, в данном случае) указывается количество создаваемых ячеек в виде последовательности от какого адреса к какому они будут привязаны. В примере ниже `reg [19:0] RAM [0:15];` создается память с шестнадцатью (от 0-го до 15-го адреса) 20-битными ячейками памяти. В таком случае говорят, что ширина памяти 20 бит, а глубина 16. Для адресации такой памяти потребуется адрес с разрядностью ceil(log2(16)) = 4 бита (`ceil` — операция округления вверх). Поэтому `A` в примере ниже имеет разрядность 4 – `[3:0]`. Это однопортовая память.

Для обращения к конкретной ячейке памяти используются квадратные скобки с указанием нужного адреса `RAM[A]`. Грубо говоря, то, что указывается в квадратных скобках будет подключено ко входу адреса памяти `RAM`.

Подключение к выходу чтения `RD` осуществляется оператором `assign`. Но, если требуется создать память с синхронным чтением, то выход `RD` требуется сделать регистровым `reg [19:0] RD`, а подключение к нему описать внутри `always`.

Так как запись в память является синхронным событием, то описывается она в конструкции `always`. `if (WE) ...` реализует подключение сигнала `WE` ко входу разрешения на запись.


``` verilog
module mem16_20 (         // создать блок с именем mem16_20
  input           CLK,    // вход синхронизации
  input   [3:0]   A,      // 4-битный адресный вход
  input   [19:0]  WD,     // 20-битный вход данных для записи
  input           WE,     // сигнал разрешения на запись
  output  [19:0]  RD      // 20-битный выход считанных данных
);

  reg [19:0] RAM [0:15];  // создать память с 16-ю 20-битными ячейками

  // чтение
  assign RD = RAM[A];     // подключить к выходу RD ячейку памяти по адресу A

  // запись
  always @ (posedge CLK)  // каждый раз, когда произойдет фронт (0 → 1) CLK
    if (WE)               // если сигнал WE == 1, то
      RAM[A] <= WD;       // в ячейку по адресу A будут записаны данные WD

endmodule                 //  конец описания модуля
```

В случае реализации ПЗУ нет необходимости в описании входов для записи. В таком случае описание памяти занимает всего пару строк. Чтобы инициализировать такую память (то есть поместить в нее начальные значения, чтобы было что из нее читать), требуемое содержимое нужно добавить к прошивке, вместе с которой данные попадут в ПЛИС. Для этого в проект добавляется текстовый файл с содержимым памяти (более подробно об этом в [`Как добавить файл с содержимым памяти в проект`](../../Other/How%20to%20add%20a%20mem-file.md)). Для того, чтобы отметить данный файл в качестве инициализирующего память, необходимо использовать одну из двух системных функций: `$readmemh` и `$readmemb`. `$readmemh` используется для файлов, описывающих содержимое памяти 16-ричными цифрами, в то время как `$readmemb` используется для файлов, описывающих содержимое памяти двоичными цифрами. Любую из этих системных функций необходимо поместить внутрь блока `initial`. У этих системных функций есть два обязательных аргумента:

* имя инициализирующего файла  
* имя инициализируемой памяти

и два опциональных:

* стартовый адрес, начиная с которого память будет проинициализирована данным файлом (по-умолчанию равен нулю)  
* конечный адрес, на котором инициализация закончится (даже если в файле были ещё какие-то данные).

Пример полного вызова одной из этих системных функций выглядит так:  
`$readmemb("<data file name>",<memory name>,<start address>,<end address>);`  
Однако на деле обычно используются только обязательные аргументы:  
`$readmemb("<data file name>",<memory name>);`

Пример описанной выше памяти:

``` verilog
module rom16_8 (          // создать блок с именем rom16_8
  input   [3:0]   A1,     // первый 4-битный адресный вход
  input   [3:0]   A2,     // второй 4-битный адресный вход
  output  [7:0]   RD1,    // первый 8-битный выход считанных данных
  output  [7:0]   RD2     // второй 8-битный выход считанных данных
);

  initial $readmemh("mem.txt", RAM);  // поместить при запуске микросхемы в
                                      // память RAM содержимое файла mem.txt

  reg [7:0] RAM [0:15];   // создать память с 16-ю 20-битными ячейками

  assign RD1 = RAM[A1];   // реализация первого порта на чтение
  assign RD2 = RAM[A2]    // реализация второго порта на чтение

endmodule                 //  конец описания модуля
```

Содержимое файла mem.txt, например, могло бы быть таким (каждая строка соответствует отдельной ячейке памяти, начиная со стартового адреса):

``` hex
  FA
  E6
  0D
  15
  A7
```

Как видно из примера, не обязательно заполнять все ячейки памяти, которых должно быть 16, но обязательно соблюдать разрядность ячеек памяти, которая в данном случае равна 8 (две 16-ричные цифры).

Для проверки модулей памяти в testbench оказывается удобным использование циклического оператора `for`, пример использования которого приводится ниже для проверки некоторой ПЗУ `mem8_4` с глубиной 8 и шириной 4.

``` verilog
module tb();

reg   [2:0] adr;                      // создаем регистр для управления входом адреса
wire  [3:0] rd;                       // создаем провод для подключения к выходу памяти

mem8_4 dut (.A(adr), .RD(rd));        // подключаем проверяемый модуль

integer       i;                      // переменная для цикла for
integer       file_mem;               // для сохранения дескриптора файла
reg     [3:0] new_data;               // для сохранения очередного значения из файла

initial
  file_mem = $fopen("mem.txt", "r");  // получение дескриптора файла для последующего чтения "r"

initial begin
  for (i = 0; i < 8; i = i + 1) begin // подобно синтаксису C – выполнить цикл 8 раз для i от 0 до 7
    adr = i;                          // подать на вход адреса текущее значение i
    $fscanf(file_mem, "%b", new_data);// считать очередную строку (одно значение) из файла в new_data 
    #10;                              // задержка 10 единиц времени симуляции
    if (new_data != rd) begin         // если значение выдаваемое блоком памяти не равно значению из файла, то
      $display($time, "BAD!  adr = %d, file = %h, memory = %h", adr, new_data, rd);  // сообщить об ошибке
    end                              
  end
  $fclose(file_mem);                  // закрыть файл
  $finish;                            // закончить симуляцию
end
```

## Задание по реализации памяти

1. На языке Verilog необходимо реализовать модуль памяти команд (Instruction Memory). Память представляет собой однопортовую ПЗУ с 256-ю 32-битными ячейками. Созданную память необходимо инициализировать любыми данными, после чего проверить в testbench, подавая случайные адреса на вход `A` и сравнивая данные на выходе `RD` с данными в файле инициализации.

**Примечание 1**: Под случайными адресами подразумевается просто набор любых адресов, разбросанных по всему объему памяти, который придёт вам в голову. Сравнение необходимо провести визуально.  

<details><summary> Примечания для любителей задачек со звездочкой:</summary>

  **Примечание 2:** если вы хотите воспринять задание буквально, для генерации случайных адресов можно воспользоваться системной функцией `$random`, генерирующей случайное знаковое целое 32-битное число. Для того, чтобы получить случайное число, лежащее в области допустимых значений адресов памяти, необходимо взять остаток от деления на старший адрес памяти +1. К примеру, для генерации случайного адреса из диапазона `[0:15]` необходимо можно использовать вызов `$random()%16`.  
  
  **Примечание 3:** вы можете воспринять задание еще более буквально и сравнивать данные на выходе `RD` с данными файлами инициализации автоматизировано, для этого вы можете воспльзоваться системными функциями `$fopen`, `$fread`, `$fclose`.

</details>

![Память инструкций](../../../technical/Labs/Pic/im.png)

2. На языке Verilog необходимо реализовать модуль памяти данных (Data Memory) для процессора с архитектурой RISC-V. Память представляет собой однопортовую ОЗУ с 256-ю 32-битными ячейками, но имеющая 32-битную шину адреса. То есть реально будет использоваться только ceil(log2(256)) = 8 из 32 битов входного адреса `RAM[A[9:2]]`, вместо `RAM[A]`. Созданную память необходимо проверить в testbench путем многократного выполнения последовательных операций: запись-чтение-сравнение. Разумеется что в пределах последовательности адрес должен быть одним и тем же, а между последовательностями адреса должны меняться.

> Необходимость использования 8 бит начиная со второго, а не нулевого бита `[9:2]` будет пояснена в 4-ой лабораторной работе. Если коротко, то это нужно для того, чтобы притвориться памятью размером в 4 гигабайта (на самом деле 1 килобайт) с побайтовой адресацией, будучи памятью с пословной адресацией (хранятся слова, а не байты). Так как в одно слово (32 бита) помещается 4 байта (по 8 бит), то на один адрес пословной памяти приходится по 4 адреса побайтовой. Значит для преобразования побайтового адреса в пословный его надо разделить на 4, что равносильно откидыванию 2 младших бит, поэтому `[9:2]`, а не `[7:0]`. Благодаря этому реализация первых 4-х лабораторных упрощается, но позже мы избавимся от этой памяти и заменим на соответствующую спецификации RISC-V.

![Память данных](../../../technical/Labs/Pic/dm.png)

3. На языке Verilog необходимо реализовать модуль регистрового файла (Register File) для процессора с архитектурой RISC-V, представляющего собой трехпортовую ОЗУ с двумя портами на чтение и одним портом на запись и состоящей из 32-х 32-битных регистров, при этом по адресу `0` не будет ячейки памяти и при чтении из нее всегда должен выдаваться 0. Для реализации такого функционала можно использовать тернарный оператор `A == 5'b0 ? /что-то/ : /что-то/`. Осуществить проверку модуля подобно проверке памяти данных.

![Регистровый файл](../../../technical/Labs/Pic/rf.png)

Вся разрабатываемая память должна реализовывать асинхронное чтение (других примеров не разбиралось), то есть, для того чтобы считать данные из памяти достаточно подать адрес и некоторое время спустя (меньше длительности такта) на выходе появятся считываемые данные. Если бы данные появлялись на следующем такте по сигналу синхроимпульса, то это называлось бы синхронное чтение.

Разработанные блоки будут использованы при реализации процессора `CYBERcobra 3000 Pro 2.0` и в последующих лабораторных для реализации системы с процессором с архитектурой RISC-V.


## Теория про программируемое устройство

В обобщенном виде, процессор включает в себя память, АЛУ, устройство управления и интерфейсную логику для организации ввода/вывода. Также, в процессоре есть специальный регистр PC (Program Counter – счетчик команд), который хранит в себе число – адрес ячейки памяти, в которой лежит инструкция, которую нужно выполнить. Инструкция тоже представляет собой число, в котором закодировано что нужно сделать и с чем это нужно сделать.

Алгоритм работы процессора следующий: из памяти считывается инструкция по адресу PC, устройство управление дешифрует полученную инструкцию (то есть определяет какую операцию нужно сделать, где взять операнды и куда разместить результат) и выполняет ее, выдавая всем блокам процессора (АЛУ, регистровый файл, мультиплексоры) управляющие сигналы, после чего значение PC изменяется и все снова повторяется для новой инструкции.

Любая инструкция приводит к изменению состояния памяти. В случае процессора с архитектурой `CYBERcobra 3000 Pro 2.0`, который будет рассмотрен далее, инструкции изменяют либо содержимое регистрового файла, либо значение PC. В первом случае используются вычислительные инструкции. Во-втором случае используются инструкции ветвления. Если процессор обрабатывает вычислительную инструкцию, то PC в следующий раз будет на 1 больше (`PC = PC + 1`), а регистровый файл сохранит результат некоторой операции на АЛУ или данные со входного порта. Если же обрабатывается инструкция ветвления, то значение PC, в случае безусловного перехода или успешного условного перехода, увеличится на значение константы закодированной внутри инструкции `PC = PC + const`.


## Архитектура CYBERcobra 3000 Pro 2.0 и ее микроархитектура

В качестве первого разрабатываемого программируемого устройства предлагается использовать архитектуру специального назначения `CYBERcobra 3000 Pro 2.0`, которая была разработана в МИЭТ. Главным достоинством данной архитектуры является простота ее понимания. Главным ее минусом является неоптимальность в ввиду неэффективной реализации кодирования инструкций, что приводит к наличию неиспользуемых битов в программах. Но это неважно, так как основная цель разработки процессора с архитектурой `CYBERcobra 3000 Pro 2.0` это более глубокое понимание принципов работы программируемых устройства, которое поможет при разработке более сложного процессора с архитектурой RISC-V.

![logo](../../../technical/Labs/Pic/logoCC3000.svg)

Простота архитектуры `CYBERcobra 3000 Pro 2.0` проявляется, в том числе, за счет отсутствия памяти данных, то есть данные над которыми выполняется программа могут быть расположены только в регистровом файле. Также в таком процессоре почти полностью отсутствует устройство управления (формально оно существует, но состоит только из проводов и пары логических вентилей). Архитектурой предусмотрена поддержка 19 инструкций (5 типов команд): 16 инструкций выполняются на АЛУ (10 вычислительных и 6 операций сравнения для условного перехода), одна инструкция безусловного перехода, инструкция загрузки константы и инструкция загрузки данных с внешнего устройства.

Будем рассматривать архитектуру (функции процессора) и микроархитектуру (реализация процессора) одновременно, прослеживая рассуждения их разработчика. Для начала реализуем базовый функционал, подключив счетчик команд PC к памяти инструкций IM и к сумматору, прибавляющему 1 к PC, выход которого подключен ко входу PC. Каждый раз, когда будет происходить тактовый импульс значение PC будет увеличиваться на 1, тем самым указывая на следующую инструкцию. Последовательное считывание программы из памяти готово. Так как операции будут выполняться только над данными в регистровом файле, то его можно сразу подключить к АЛУ, соединив порты чтения со входами операндов АЛУ, а результат операции АЛУ подключив к порту на запись. Полученный результат изображен на картинке ниже.

![Переключение инструкций](../../../technical/Labs/Pic/ppd_1.png)

Чтобы добавить поддержку каких-либо инструкций необходимо договориться как они будут кодироваться (относится к вопросам архитектуры). Вычислительные инструкции требуют информацию о том по каким адресам регистрового файла лежат операнды, по какому адресу будет сохранен результат и какая операция должна быть выполнена. Для этого в инструкции выделяются соответствующие поля: 5 бит ([27:23]) для кодирования операции для АЛУ, два раза по 5 бит для кодирования адресов операндов в регистровом файле ([22:18] и [17:13]) и 5 бит для кодирования адреса результата ([4:0]). Ниже демонстрируется деление 32-битной инструкции на поля ALUop, RA1, RA2 и WA.

![Вычислительные инструкции](../../../technical/Labs/Pic/ppd_code_1.png)

``` C
  reg[WA] ← reg[RA1] {ALUop} reg[RA2]
```

Чтобы процессор правильно реагировал на эти инструкции требуется подключить биты выхода RD памяти инструкции IM (на котором после считывания появляется очередная инструкция) к соответствующим входам адреса регистрового файла и управляющему входу АЛУ. В таком случае, когда PC будет указывать на ячейку памяти, в которой лежит, например, следующая 32-битная инструкция:

> 0000 00111 00100 01000 00000000 11100

будет выполнена операция `reg[28] = reg[4] | reg[8]`, потому что ALUop = 00111, что соответствует операции логического ИЛИ, WA = 11100, то есть 28-ой регистр, RA1 = 00100 (4-ый регистр) и RA2 = 01000 (8-ой регистр). Ниже иллюстрируется фрагмент микроархитектуры, поддерживающий вычислительные операции на АЛУ. Так как пока что другие инструкции не поддерживаются, то вход WE3 регистрового файла всегда равен 1 (это временно).

![Поддержка вычислительных инструкций](../../../technical/Labs/Pic/ppd_2.png)

Информация как-то должна попадать в регистровый файл, для этого добавим инструкцию загрузки константы по адресу WA. Чтобы аппаратура могла различать, когда ей нужно выполнять операцию на АЛУ, а когда загружать константу, назначим один бит инструкции определяющим "что именно будет записано в регистровый файл": результат с АЛУ или константа из инструкции. За это будет отвечать 28-ой бит инструкции WS (Write Source). Если WS == 1, значит выполняется вычислительная инструкция, а если WS == 0, значит нужно загрузить константу в регистровый файл. Сама константа имеет разрядность 23 бита ([27:5] биты инструкции) и должна быть знакорасширена до 32-х бит, то есть к 23-битной константе нужно приклеить слева 9 раз 23-ий знаковый бит константы. Нет ничего страшного в том, что биты константы попадают на те же поля, что и ALUop, RA1 и RA2, потому что когда выполняется инструкция загрузки константы не важно что будет выдавать АЛУ в этот момент (ведь на вход регистрового файла приходит константа). Аначит не важно и что приходит на АЛУ в качестве операндов и кода операции. Ниже демонстрируется деления 32-битной инструкции на поля ALUop, RA1, RA2, WA, WS и const, который нарисован с перекрытием полей.

![Плюс константа](../../../technical/Labs/Pic/ppd_code_2.png)

``` C
  reg[WA] ← const
```

Так как вход записи уже занят результатом операции АЛУ, его потребуется мультиплексировать со значением константы из инструкции, которая предварительно знакорасширяется в блоке SE. На входе WD3 регистрового файла появляется мультиплексор, управляемый 28-м битом инструкции, который и определяет что будет записано: константа или результат вычисления на АЛУ. Например, в такой реализации следующая 32-битная инструкция поместит константу –1 в регистр по адресу 5:

> 000 0 11111111111111111111111 00101

Далее приводится фрагмент микроархитектуры, поддерживающий вычислительные операции на АЛУ и загрузку констант из инструкции в регистровый файл.

![Поддержка добавления константы](../../../technical/Labs/Pic/ppd_3.png)

Чтобы процессор мог взаимодействовать с внешним миром добавим возможность загрузки данных с внешних устройств в регистр по адресу WA. Появляется третий тип инструкции, который определяет третий источник ввода для регистрового файла. Одного бита WS для выбора одного из трех источников будет недостаточно, поэтому расширим это поле до 2 бит. Теперь, когда `WS == 0` будут загружаться данные с внешних устройств, когда `WS == 1` – будет загружаться константа, а при `WS == 2` будет загружаться результат вычисления АЛУ. Остальные поля в данной инструкции не используются.

![Плюс внешние устройства](../../../technical/Labs/Pic/ppd_code_3.png)

``` C
  reg[WA] ← IN
```

По аналогии с загрузкой констант увеличиваем входной мультиплексор до 3 входов и подключаем к нему управляющие сигналы – [29:28] биты инструкции. Выход OUT подключается к первому порту на чтение регистрового файла. Значение на выходе OUT будет определяться содержимым ячейки памяти по адресу RA1. Ниже приводится фрагмент микроархитектуры, поддерживающий вычислительные операции на АЛУ, загрузку констант из инструкции в регистровый файл и загрузку данных с внешних устройств.

![Поддержка внешних устройств](../../../technical/Labs/Pic/ppd_4.png)

С реализованным набором инструкций полученное устройство нельзя назвать процессором – пока что это продвинутый калькулятор. Добавим поддержку инструкции безусловного перехода, при выполнении которой программа будет перепрыгивать через заданное количество команд. Чтобы аппаратура отличала эту инструкцию от других будем использовать 31-ый бит B. Если B == 1, значит это инструкция безусловного перехода, и надо прибавить к PC константу. Если B == 0, значит это какая-то другая инструкция и надо прибавить к PC единицу. Так как PC 8-битный, то в качестве константы используются 8 бит инструкции [12:5]. Инструкция с новым полем B демонстрируется ниже.

![Плюс безусловный переход](../../../technical/Labs/Pic/ppd_code_4.png)

``` C
  PC ← PC + const
```

Так как второй вход сумматора счетчика команд занят числом 1, то для реализации безусловного перехода этот вход надо мультиплексировать с константой. Мультиплексор при этом управляется 31-ым битом B, который и определяет, что будет прибавляться к PC. Кроме этого, так как теперь не любая инструкция приводит к записи в регистровый файл, появляется необходимость управлять входом WE3 так, чтобы при операциях безусловного перехода запись в регистровый файл не производилась. Для этого можно было бы выделить еще один бит инструкции, но в целях экономии можно провернуть следующий фокус. Изменим адреса мультиплексора на входе WD3 регистрового файла с 0, 1, 2, на 1, 2, 3, а ко входу WE3 подключим логическое ИЛИ между битами инструкции 29 и 28. Тогда, если сигнал WS равен 1, 2 или 3 (01, 10 или 11 в двоичной записи), то логическое ИЛИ между битами WS будет равняться 1, то есть будет происходить запись в регистровый файл. Выставляя поле WS == 0 запись происходить не будет. Так как не все входы мультиплексора задействованы не забывай использовать `default` в `case` при его описании на Verilog. Итого, чтобы произвести безусловный переход необходимо выставить сигнал `B == 1`, чтобы к PC прибавлялась константа, а `WS == 0`, чтобы в регистровый файл на этой инструкции не происходила запись. Микроархитектура с добавлением новой инструкции представлена ниже.

![Поддержка безусловного перехода](../../../technical/Labs/Pic/ppd_5.png)

Осталось добавить поддержку инструкции условного перехода, для идентификации которой используется оставшийся 30-ый бит C. Если бит `C == 1`, то АЛУ, в соответствии с кодом операции ALUop, должен сравнить операнды по адресам RA1 и RA2, и в случае, если условие дает результат true, то к значению PC прибавляется константа из инструкции `PC = PC + const`, а если false, то `PC = PC + 1`.

![Плюс условный переход](../../../technical/Labs/Pic/ppd_code_5.png)

``` C
  if (reg[RA1] {ALUop} reg[RA2])
    PC ← PC + const
  else
    PC ← PC + 1
```

Сигнальные линии, которые управляют АЛУ и подают на его входы операнды уже существуют. Поэтому на схему необходимо добавить только логику управления мультиплексором на входе сумматора счетчика команд так, чтобы во время безусловного перехода мультиплексор всегда переключался на константу, а во время условного только в том случае, если возникает флаг на выходе АЛУ. С помощью логического ИЛИ подключается бит безусловного перехода (тогда, если `B == 1`, то переход в любом случае произойдет). С помощью логического И перемножается бит C и значение флага flag, благодаря чему переход будет только тогда, когда и 30-ый бит равен 1, и флаг на выходе АЛУ равен 1. Ниже приводится итоговый вариант микроархитектуры процессора `CYBERcobra 3000 Pro 2.0`.

![Поддержка условного перехода](../../../technical/Labs/Pic/ppd_6.png)

Итого, архитектура `CYBERcobra 3000 Pro 2.0` поддерживает 5 типов инструкций, которые кодируются следующим образом (иксами помечены биты, которые не задействованы в данной инструкции):

1. 10 вычислительных инструкций `0 0 11 ALUop RA1 RA2 xxxx xxxx WA`
2. Инструкция загрузки константы `0 0 10 const WA`
3. Инструкция загрузки из внешних устройств `0 0 01 xxx xxxx xxxx xxxx xxxx xxxx WA`
4. Безусловный переход `1 0 00 xxx xxxx xxxx xxxx const xxxx xxxx`
5. 6 инструкций условного перехода `0 1 00 ALUop RA1 RA2 const x xxxx`

При кодировании инструкций используются следующие поля:

- B – однобитный сигнал указывающий на выполнение безусловного перехода
- C – однобитный сигнал указывающий на выполнение условного перехода
- WS – двухбитный сигнал указывающий источник данных для записи в регистровый файл:  
  - 0 – не пишем
  - 1 – с внешних устройств
  - 2 – константа
  - 3 – результат с АЛУ
- ALUop – 5-битный сигнал кода операции АЛУ (в соответствии с таблицей из прошлой лабораторной)
- RA1 и RA2 – 5-битные адреса операндов из регистрового файла
- const – 8-битная константа для условного/безусловного перехода (или 23-битная константа для загрузки в регистровый файл)
- WA – 5-битный адрес регистра, в который будет записан результат

Напишем простую программу для этого процессора, которая в бесконечном цикле увеличивает значение регистра по адресу 5 на 1. Сначала напишем программу на псевдоассемблере (используя предложенную мнемонику):

``` C
  reg[5] ← 0                // загрузить константу 0 в регистр 5
  reg[6] ← 1                // загрузить константу 1 в регистр 6
  reg[5] ← reg[5] + reg[6]  // сложить регистр 5 с регистром 6 и поместить результат в регистр 5
  PC ← PC – 1               // перейти к предыдущей инструкции
```

Теперь в соответствии с кодировкой инструкций переведем программу в машинные коды:

```
  0 0 10   00000000000000000000000  00101
  0 0 10   00000000000000000000001  00110
  0 0 11 00000 00101 00110 00000000 00101
  1 0 00  000000000000000  11111111 00000
```

Полученную программу можно помещать в память программ и выполнять на процессоре.


## Инструменты для реализации процессора

Так как все модули процессора написаны, основная часть кода описания процессора будет связана с подключением этих модулей друг к другу. Рассмотрим пример подключения модулей. Ниже приводится описание трех модулей, два из которых будут подключены в третьем. Модуль `and_3` реализует логическое ИЛИ между тремя входными сигналами.

``` verilog
module and_3 (
  input   a, b, c,
  output  y
); 

  assign y = a & b & c;

endmodule
```

![and_3](../../../technical/Labs/Pic/and_3.png)

Модуль `inv` подает на выход `y` инверсию входного сигнала.

``` verilog
module inv (
  input	  a,
  output  y
); 

  assign y = ~a;

endmodule
```

![inv](../../../technical/Labs/Pic/inv.png)

В модуле `dut` модули `and_3` и `inv` соединяются друг с другом. Для того, чтобы подключить модуль внутри другого модуля требуется написать имя подключаемого модуля, например `and_3`, после этого указать название примитива, допустим `and_3 andgate`. Например, нам может понадобиться 3 копии модуля `and_3`, тогда мы сможем подключить 3 экземпляра модуля `and_3`, используя различные наименования для прототипов (`andgate_1`, `andgate_2` и тому подобное). После имени прототипа в скобках указываются внутренние имена модулей и названия сигналов, которые к этим входам подключаются. Символ точка, перед наименованием порта отсылает к реальному порту подключаемого модуля. В скобках обозначается куда будут подключаться сигналы в top-модуле (в данном случае top-модуль это `dut`). 

У модуля `andgate` выход `y` подключается к проводу `n1`, который вторым концом подключается ко входу `a` модуля `inverter`. Ко входу `a` модуля `andgate` подключается входной сигнал `a` модуля `dut`, и так далее.

``` verilog
module dut (
  input   a, b, c,
  output  y
); 

  wire n1;  // создаем однобитный провод n1

  and_3 andgate ( // подключаем блок and_3 и даем этому примитиву имя andgate
    .a(a),  // подключаем ко входу a блока andgate сигнал a со входа блока dut
    .b(b),  // подключаем ко входу b блока andgate сигнал b со входа блока dut
    .c(c),  // подключаем ко входу c блока andgate сигнал c со входа блока dut
    .y(n1)  // подключаем к выходу y блока andgate провод n1
  );

  inv inverter (
    .a(n1), // подключаем ко входу a блока inverter провод n1
    .y(y)   // подключаем к выходу y блока inverter выход y блока dut
  );

endmodule
```

![modules](../../../technical/Labs/Pic/modules.png)

Для реализации блоков знакорасширения подходит использование оператора объединения `{}`, с помощью которого можно объединить несколько отдельных сигналов, в том числе многократно дублируя некоторые из них. В примере ниже проводу `out` будут подключены следующие сигналы: `{in[1], in[0], in[3], in[3], in[3], in[4], in[3], in[2], in[1], in[0]}`.

``` verilog
  wire [9:0] out;
  wire [4:0] in;

  assign out = {in[1:0], {3{in[3]}}, in};
```

## Задание по реализации процессора

На языке Verilog необходимо собрать процессор из ранее разработанных блоков. В главном модуле `CYBERcobra` необходимо объединить ранее разработанные модули памяти инструкций (Instruction Memory), с помещенной внутрь программой (следующее задание), регистрового файла (Register File) и арифметико-логического устройства (ALU), добавив регистр счетчика команд (program counter) и  логику его работы, в соответствии с ранее представленной микроархитектурой.

``` verilog
module CYBERcobra (
  input           CLK,
  input           rst,
  input   [31:0]  IN,
  output  [31:0]  OUT
);

reg [7:0] pc; // создание регистра счетчика команд

// ваш код с подключенными IM, RF и ALU

endmodule
```

![Микроархитектура CYBERcobra 3000 Pro 2.0](../../../technical/Labs/Pic/ppd_6.png)

## Задание по проверке процессора

Для проверки работоспособности разработанного процессора с архитектурой `CYBERcobra 3000 Pro 2.0` необходимо написать программу в машинных кодах в соответствии с одним из индивидуальных заданий (вариант берется у преподавателя) и продемонстрировать ее корректную работу в симуляции или на стенде.

В качестве входных данных используются либо данные со входа `IN`, который поступает с 16-ти переключателей на плате `IN[31:0] = {16{SW[15]}, SW[15:0]}`, либо через константы, передаваемые внутри инструкции, которые будут именоваться в заданиях, как `a`, `b` и так далее.

Для демонстрации результата используется выходной сигнал `OUT[31:0]` – подключается к 16 светодиодам на плате {16'h0000, LED[15:0]} = OUT[31:0], то есть старшие 16 бит результата не отображаются. Однако, используя тернарный оператор ` ? : ` можно легко реализовать управление выводом `OUT` в зависимости от нажатия на кнопку (кнопка зажата – на светодиоды выводятся старшие 16 битов, кнопка не нажата – выводятся младшие 16 битов).

Так как `OUT` подключен к выходу регистрового файла, то во время работы программы на нем будут отображаться какие-то случайные промежуточные результаты. Для постоянного вывода в `OUT` в конце программы необходимо последней инструкцией поставить безусловный переход со смещением 0, то есть чтобы переход был к `PC + 0`, а в биты, соответствующие адресу регистра источника 1, установить адрес регистра с ответом.

Сигнал `rst` можно подключить к одной из кнопок. Для того, чтобы сброс (rst == 1) работал корректно необходимо инициализировать (задавать начальные значения при старте программы) используемые в программе регистры.

1. Вычислить [циклический сдвиг](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) вправо `a` >> `IN`
2. Вычислить [циклический сдвиг](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) влево `a` << `IN`
3. Найти количество единиц в двоичном представлении числа `IN` (обрати внимание `IN` – знаковое число)
4. Сформировать число, состоящее из четных двоичных разрядов числа `IN`. Пример: `IN` = `11_1011_1000`, результат вычислений `OUT` = `1_0100`
5. Найти наибольший двоичный разряд числа `IN`, значение которого равно 1. Если такого нет, вывести 32
6. Поменять в числе `a` разряды `i = IN[4:0]` и `j = IN[9:5]`
7. Если `IN` является степенью двойки, то вывести `1`, в противном случае `0`
8. Найти количество нулей в двоичном представлении числа `IN`
9. Найти количество двоичных разрядов, в которых отличаются числа `IN` и `a`
10. Найти и вывести в `OUT` количество вхождений `a[2:0]` в `IN`
11. Определить, сколько раз встречается `11` в двоичном представлении `IN`, при этом в последовательности `01110` только одно вхождение `11`
12. Инвертировать первые `IN` бит числа `a`
13. Вычислить `a`*`IN` с использованием операций сложений и сдвига ("в столбик")
14. Вывести в `OUT` n-ый член [арифметической прогрессии](https://ru.wikipedia.org/wiki/Арифметическая_прогрессия) aN, где a1 = `a`, d = `IN[15:8]`, n = `IN[7:0]` (d и n неотрицательные)
15. Найти остаток от деления `IN` на `a`
16. Вычислить `a`-`IN` без использования операции вычитания
17. Вывести n-ый член последовательности Фибоначчи Fn. n = `IN`
18. Вывести сумму `IN[3:0]` + `IN[7:4]` + `IN[11:8]` + `IN[15:12]`
19. Если `IN[1:0] == 0`, то выводится `a`,  если `IN[1:0] == 1`, то `b`,  если `IN[1:0] == 2`, то `c`,  если `IN[1:0] == 3`, то `d`
20. Вывести результат целочисленного деления `a`/`IN`
21. *Зажечь все светодиоды на 50% яркости ([спойлер](http://wiki.amperka.ru/конспект-arduino:шим))
22. Вывести подряд все единицы входного числа `IN`. Например, на входе `IN` = `1011011011`, значит на выходе `OUT` = `1111111`
23. Поменять местами четные биты числа `IN` с нечетными битами этого числа (то есть соседние биты поменять местами). Например, `IN` = `1010_0111`, значит `OUT` = `0101_1011`
24. Удалить все вхождения `IN[2:0]` из `a` со сдвигом вправо (заполняя удаленные области). Например, если `a` == `10011010`, `IN[2:0]` == `101`, то `OUT` == `10010`
25. В числе `IN` заменить справа-налево каждое `00` на `11`

Дерзай!
