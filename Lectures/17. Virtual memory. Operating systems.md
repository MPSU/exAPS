# Лекция 17. Виртуальная память. Операционные системы.

### Содержание
* [Виртуальная память](#Виртуальная-память)
  * [Виды адресов](#Виды-адресов)
  * [Преобразование адреса](#Преобразование-адреса)
  * [Реализация виртуальной памяти в процессоре](#Реализация-виртуальной-памяти-в-процессоре)
  * [Физические и виртуальные страницы](#Физические-и-виртуальные-страницы)
  * [Сравнение кэш и виртуальной памяти](#Сравнение-кэш-и-виртуальной-памяти)
  * [Особенности виртуальной памяти](#Особенности-виртуальной-памяти)
    * [Защита и приватность](#Защита-и-приватность)
    * [Основная память используется как кэш для внешней памяти](#Основная-память-используется-как-кэш-для-внешней-памяти)
  * [Буфер ассоциативной трансляции](#Буфер-ассоциативной-трансляции-TLB)
    * [Использование TLB](#Использование-TLB)
  * [Метод ключей защиты](#Метод-ключей-защиты)
  * [Использование кэш и виртуальной памяти](#Использование-кэш-и-виртуальной-памяти)
  * [Стратегии замещения страниц](#Стратегии-замещения-страниц)
    * [Стратегия обратной записи (write-back)](#Стратегия-обратной-записи-write-back) 
    * [Стратегия вытеснения редко используемых страниц (LRU)](#Стратегия-вытеснения-редко-используемых-страниц-LRU)
  * [Многоуровневые таблицы страниц](#Многоуровневые-таблицы-страниц)
  * [Метод граничных регистров](#Метод-граничных-регистров)
* [Операционная система](#Операционная-система)
  * [Процесс vs. программа](#Процесс-vs-программа)
  * [Цели операционной системы](#Цели-операционной-системы)
  * [Управление процессами и ресурсами в ядре операционной системы](#Управление-процессами-и-ресурсами-в-ядре-операционной-системы)
  * [Виртуальные машины](#Виртуальные-машины)
  * [Прерывания и исключения](#Прерывания-и-исключения)
  * [Cистемные вызовы](#Cистемные-вызовы)
  * [Системные вызовы RISC-V](#Системные-вызовы-RISC-V)
  * [Жизненный цикл процесса](#Жизненный-цикл-процесса)

## Виртуальная память
**Виртуальная память** – это способ автоматического управления иерархической памятью, при котором для нескольких ее уровней организуется единое адресное пространство. Благодаря этому можно создать для программиста видимость памяти большого объема. При этом, при перемещении данных между уровнями для большинства обращений к памяти обеспечивается скорость доступа, равная скорости более быстрых типов памяти (благодаря такому свойству как **локальность по обращению**).

Когда основная (оперативная) память переполняется, операционная система переносит часть данных во вторичную память (hdd/sdd), освобождая основную память для других задач.

Виртуальная память разделяет "виртуальные" адреса, используемые приложениями, и "физические" адреса, по которым хранятся данные в реальности *(рис. 1)*. Соответствие между виртуальными и физическими адресами хранится в памяти: когда процессор запрашивает виртуальный адрес, ему предоставляется соответствующий физический адрес. Ячейка памяти может физически располагаться либо во внешней памяти (**Secondary Memory**), либо в оперативной (**Physical Memory**). Во время взаимодействия пользователя с приложением, оно подгружается в оперативную память, а неактивные части выгружаются во внешнюю память.
<div align="center">

![](https://sun9-28.userapi.com/impg/Ha9ceNw-_X6ISgdLuJPOZpU0ybOeyqczlBTRlQ/t-7ABhkvAes.jpg?size=750x328&quality=96&sign=95e35476e038352db2885f3ddaba0466&type=album)  
*Рис. 1. Схема работы виртуальной памяти, показывающая отображение виртуальных адресов на физические и перенос данных между оперативной и внешней памятью.*
</div>

### Виды адресов

Существует два вида адресов:

* **Виртуальный адрес**
  - Адрес генерируется процессом
  - Специфичное приватное адресное пространство процесса  
    _Представляет собой адрес в виртуальной памяти, который используется программами и операционной системой для идентификации данных или инструкций в памяти. Кроме того, виртуальные адреса предоставляют изоляцию между процессами. Благодаря тому, что каждый процесс работает в своем виртуальном адресном пространстве, один процесс не может случайно или намеренно повредить память другого процесса._
* **Физический адрес**
  - Адрес используется для доступа к физической памяти
  - Операционная система определяет отображение виртуальных адресов на физические  
    _Реальный адрес в оперативной памяти системы. Когда данные или инструкция должны быть
    получены или сохранены, процессор обращается к физическому адресу._

### Преобразование адреса

В основе процесса преобразования адреса *(рис. 2)* лежит структура данных, известная как таблица страниц. Она содержит информацию о том, как виртуальные страницы (блоки виртуальной памяти) соотносятся с физическими блоками в оперативной памяти.
<div align="center">

![](https://sun9-17.userapi.com/impg/0NGo7pB6xAl9jDGl8nbUmAlLpRW4f5YBRMCW-Q/xK_S17koeAw.jpg?size=859x225&quality=96&sign=d1c1d7be4bb251e6457c37f342c54717&type=album)  
*Рис. 2. Схема работы таблицы страниц, отображающая виртуальные страницы на физические блоки оперативной памяти.*
</div>

## Реализация виртуальной памяти в процессоре

На *(рис. 3)* представлен пример процессора с модифицированной гарвардской архитектурой без виртуальной памяти
<div align="center">

![](https://sun9-63.userapi.com/impg/0POFD_wM6vKD6ocPKT98s8pazGb7TRGSIh3PZw/gNzEIqRqQ0k.jpg?size=753x606&quality=96&sign=d0454cb6df333e15d903d31bf42cb4a9&type=album)  
*Рис. 3. Процессор на базе модифицированной гарвардской архитектуры без использования виртуальной памяти.*
</div>

На *(рис. 4)* представлен пример архитектуры того же процессора, но с использованием виртуальной памяти, в котором добавляется дополнительный блок **MMU (Memory Management Unit)** - устройство управление памятью, он преобразует **ФА** (Физические адреса) в **ВА** (Виртуальные Адреса)
<div align="center">

![](https://sun9-21.userapi.com/impg/k3jHLdIayICEBJzLgceD15WAvJco1O9q1NW1Zw/tVynGUUQkOY.jpg?size=753x689&quality=96&sign=e190eb2ff26e0e80de2332810dec639d&type=album)  
*Рис. 4. Архитектура процессора с виртуальной памятью и блоком MMU для преобразования ФА в ВА.*
</div>

Рассмотрим более детально работу MMU на *(рис. 5)*. Как мы можем увидеть, процессор с виртуальной памятью не обязан работать исключительно через виртуальную память. Это позволяет обеспечивать гибкость в обращении с ресурсами и оптимизировать производительность в зависимости от потребностей задачи.
<div align="center">

![](https://sun9-69.userapi.com/impg/wcXQ_V8ikUvcL-fYdYHzPqenaUh62z4XKPs5UQ/2CrKYi9_lZg.jpg?size=1359x513&quality=96&sign=862ff1b01730fd275dbfd9ffafc6fc10&type=album)
*Рис. 5. Блок-схема MMU.*
</div>

## Физические и виртуальные страницы

При работе с виртуальной памятью данные могут быть организованы двумя способами:
* **Страничная организация памяти**: Данные разбиваются на блоки одинакового размера, называемые страницами. В каждой странице смещение данных идентично, что соответствует смещению внутри виртуального адреса. Это можно сравнить с работой кэш-памяти.
* **Сегментная организация памяти**: Данные разделяются на сегменты разного размера, в зависимости от их характера и назначения.

Рассмотрим компьютерную систему с 128 МБ физической памяти и поддержкой виртуальной памяти размером 2 ГБ. На (рис. 6) представлена страничная таблица. В этой системе вся память поделена на равные блоки, обычно размером 4 КБ, которые называются страницами.
<div align="center">

![](https://sun9-77.userapi.com/impg/TZ8sU24QYziLDjPPcWJqfGVRsrWGQ8UACY5Z7A/jazqlHocDvw.jpg?size=444x326&quality=96&sign=4dd5e402125c50ff40f32dfa45750975&type=album)  
*Рис. 6. Как адреса из виртуальной памяти, ссылаются на адреса в физической памяти.*
</div>

В памяти системы находится часть страничной таблицы *(рис. 7)*. Каждая ячейка этой таблицы содержит число, указывающее на определенный блок физической памяти. В этой таблице также присутствует бит `V`. Если значение бита `V` равно **1**, это указывает, что страница находится в основной памяти. Если значение равно **0**, страница располагается во внешней памяти.
<div align="center">

![](https://sun9-35.userapi.com/impg/4c1SFjJ_vGaMlyC0BkQtZJyaFLaqOXb2-6AynQ/QjurfdmaOL4.jpg?size=343x441&quality=96&sign=b146042c22a5fdd3d8c5656c9814f4da&type=album)  
*Рис. 7. Страничная таблица.*
</div>

## Сравнение кэш и виртуальной памяти

Рассмотрим *(рис. 8)*. Слева представлены характеристики и параметры кэширования, включая размеры строк, время доступа и обработку промахов. Справа — аналогичные характеристики для виртуальной памяти, включая размеры страниц и время обработки различных операций.
<div align="center">

![](https://sun9-56.userapi.com/impg/KLUvmGsoTStifoksiJoECHDRB1VH53-qlGI5fw/xba3yRYSUho.jpg?size=1299x694&quality=96&sign=630bcc55f8d84c73faef3b7e9c3a82b6&type=album)  
*Рис. 8. Таблица сравнения работы кэш-памяти и виртуальной памяти*
</div>


## Особенности виртуальной памяти

### Защита и приватность

* Каждый процесс использует приватное адресное пространство.
  >Каждый запущенный процесс (или приложение) в системе получает свое уникальное адресное пространство, изолированное от других процессов. Таким образом, одно приложение не может напрямую обратиться к памяти другого приложения, что обеспечивает безопасность и стабильность системы.

* Подкачка страниц.
  > Это механизм, при котором операционная система перемещает данные между физической памятью и пространством подкачки (часто расположенным на жестком диске). Это позволяет ОС освобождать физическую память для активных процессов, отправляя менее активные или неактивные страницы в пространство подкачки.

### Основная память используется как кэш для внешней памяти

* Позволяет запускать программы большие, чем основная память.
  >Благодаря виртуальной памяти можно запускать программы, требующие больше памяти, чем фактически имеется в системе. Это достигается путем использования комбинации физической памяти и пространства подкачки.

* Скрывает разницу в машинных конфигурациях.
  >Виртуальная память позволяет программам работать на различных аппаратных конфигурациях, не заботясь о реальном объеме имеющейся памяти или спецификации жесткого диска. Это упрощает разработку и использование программ.

* Цена виртуализации – это трансляция каждого обращения к памяти.
  >  Эта дополнительная операция добавляет некоторую задержку, что делает доступ к виртуальной памяти медленнее по сравнению с прямым доступом к физической памяти.  
  Однако, существуют специализированные методы и технологии, призванные минимизировать эту задержку и оптимизировать процесс трансляции. Одним из таких методов является использование **Буфера Ассоциативной Трансляции или TLB**.

## Буфер ассоциативной трансляции (TLB)
Каждый раз, когда система обращается к памяти, необходимо перевести виртуальный адрес в физический. Этот процесс трансляции адреса может стать затратным, поскольку каждое такое обращение требует дополнительного обращения к страничной таблице, что фактически удваивает количество операций с памятью.

Чтобы оптимизировать этот процесс, было предложено решение в виде кэширования недавно транслированных страниц в специальной высокоскоростной памяти, называемой Буфером Ассоциативной Трансляции или Translation Lookaside Buffer (TLB).

Когда система обращается к странице, которая уже находится в TLB (**TLB hit**), трансляция адреса может быть выполнена всего за один системный такт. Но, если страница не находится в TLB (**TLB miss**), системе придется обратиться к страничной таблице для получения нужного адреса и обновления содержимого TLB.

Другими словами, TLB – это кэш-память с высокой степенью ассоциативности в которой хранятся последние записи страничной таблицы *(рис. 9)*.
<div align="center">

![](https://sun9-32.userapi.com/impg/DvA0lBsNOTReJxNNc1DPv6q0eA2LcKlH_dQwzg/PUFtCc_wrzE.jpg?size=796x355&quality=96&sign=c491a4417912b0be354bafdb2182b659&type=album)  
*Рис. 9. При обращении по виртуальному адресу 0x24C7 данные будут загружены из кэша. В то время как для адреса 0x5FB0 необходимо будет выполнить обращение к основной памяти.*
</div>

### Использование TLB
Буфер ассоциативной трансляции играет ключевую роль в современной системе управления памятью. Обычный TLB может содержать от 32 до 128 входов с степенью ассоциативности между 4 и 8. Современные процессоры часто используют иерархическую структуру TLB, что может включать в себя комбинацию, например, L1 TLB с 128 входами и L2 TLB с 2K входами.

Переключение между процессами является дорогостоящей операцией, главным образом из-за необходимости очистки TLB. Тем не менее можно включить ID процесса в TLB для  предотвращая потребность в очистке *(рис. 10.)*.

При промахе TLB, система обращается к страничной таблице в основной памяти. Если требуемая страница присутствует в основной памяти, система выполняет преобразование виртуального номера страницы (VPN) в физический номер страницы (PPN) и обновляет TLB. В противном случае происходит страничный сбой, который всегда обрабатывается программно.

Для навигации по страничной таблице обычно используется специальное аппаратное устройство, называемое блоком управления памятью (**MMU**). Некоторые популярные архитектуры, такие как `RISC-V` и `x86`, реализуют страничную таблицу на аппаратном уровне.

<div align="center">

![](https://sun9-24.userapi.com/impg/26Oeuvej1MSMc4CytHGTikSSzyIQS3LazBXUHg/Ob0PWYOH9Is.jpg?size=1094x790&quality=96&sign=20c371b05f6fb76eb6f839cc8629fe14&type=album)  
*Рис. 10. Виртуальный адрес разбивается на две части:  
ASID (ID процесса) – идентифицирует конкретный процесс, к которому относится данный адрес.  
VPN (номер виртуальной страницы) – указывает на конкретную виртуальную страницу в рамках выбранного процесса.*
</div>

Для обеспечения повышенной безопасности, необходимо реализовать дополнительную проверку по ASID. Этот момент приводит нас к управлению памятью — **Методу ключей защиты**.

### Метод ключей защиты
Рассмотрим *(рис. 11)*. Ключ защиты программы представляет собой уникальный ID, который хранится в специальном регистре. Операционная система, работая в привилегированном режиме, имеет возможность управлять данным регистром. При формировании адреса программой, часть этого адреса сравнивается с текущим ключом защиты. Если совпадение найдено, то обращение к памяти разрешено. В противном случае, доступ к памяти блокируется.
<div align="center">

![](https://sun9-13.userapi.com/impg/zd4p2aC_kTKCLVuTM4SYFJ1EXLbvGCUelmP2Pw/XTmZwkUA5dY.jpg?size=720x421&quality=96&sign=095b384359d23129e97452396c090107&type=album)  
*Рис. 11. Метод ключей защиты.*
</div>

## Использование кэш и виртуальной памяти
Для того чтобы использовать кэш память и виртуальную память одновременно есть несколько вариантов *(рис. 12.)*
<div align="center">

![](https://sun9-71.userapi.com/impg/I1uMXt-tUbTMmG42O1b2nWRbkab9IWDaZptKEw/GZsOQY6BDXA.jpg?size=799x157&quality=96&sign=f60bc41f395ac548f69892fdae238f51&type=album)  
*Рис. 12. Виртуально-адресуемый кэш — сначала кэш, потом TLB  
Физически-адресуемый кэш — сначала TLB, потом кэш.*
</div>

**Виртуально-адресуемый кэш (VAC)**  
Преимущества:
- **Быстрота**.  
  _Поскольку трансляция адресов  не требуется до проверки кэша, доступ к кэшу может быть быстрее._
- **Поддержка разделяемых страниц**.  
  _Если два процесса используют одну и ту же физическую страницу, VAC может эффективно кэшировать её для обоих процессов._

Недостатки:
- **Проблемы с однородностью (aliasing)**.  
  _Поскольку одна и та же физическая страница может быть отображена на несколько виртуальных адресов, это может привести к нежелательным промахам в кэше._
- **При переключении контекста часто требуется сбросить кэш**.

**Физически-адресуемый кэш**  
Преимущества:
- **Отсутствие проблем с однородностью**.  
  _Так как используются физические адреса, вероятность возникновения ситуации, когда два разных виртуальных адреса ссылаются на одну и ту же ячейку кэша, минимальна._
- **Стабильность при переключении контекста**.  
  _Нет необходимости очищать кэш при смене процесса._

Недостатки:
- **Задержка из-за трансляции**.  
  _Прежде чем можно проверить кэш, виртуальный адрес должен быть переведен в физический, что добавляет дополнительное время ожидания._

Но на практике чаще используется третий вариант — параллельное обращение к TLB и кэш-памяти *(рис. 13)*
<div align="center">

![](https://sun9-76.userapi.com/impg/i9jY7ClxuTOhBNqfZnM-W2jzAo408r43hTzg2A/PQDkgJS6qNs.jpg?size=554x262&quality=96&sign=e00445b3fd65ac7d39c79897427f6f59&type=album)  
*Рис. 13. Схема параллельного обращения процессора к TLB и кэш-памяти.*
</div>

## Стратегии замещения страниц
Стратегии замещения страниц в виртуальной памяти очень похожи на стратегии замещения в кэш-памяти. Они определяют, какую страницу следует вытеснить из основной памяти при необходимости загрузки новой страницы.

### Стратегия обратной записи (write-back)
Эта стратегия предполагает, что изменения записываются только в кэше. Данные в основной памяти обновляются только тогда, когда страница вытесняется из кэша.

Для поддержания работы с этой стратегией в таблице страниц используется дополнительное поле `D` (dirty bit). Если бит установлен, это указывает, что страница была изменена и требует обновления в основной памяти.

### Стратегия вытеснения редко используемых страниц (LRU)
LRU вытесняет страницы, которые не использовались дольше всех. Это обеспечивает предположение, что страницы, которые не использовались в недавнем прошлом, вероятно, не будут использоваться и в ближайшем будущем.

Для реализации этой стратегии в таблице страниц используется дополнительное поле `U` (use bit). Этот бит показывает, была ли страница использована в недавнем прошлом. Операционная система может периодически сбрасывать этот бит для всех страниц, а затем наблюдать, какие из них используются снова.

## Многоуровневые таблицы страниц
Вместо одной огромной таблицы страниц, которая бы отображала каждую возможную страницу виртуальной памяти на страницу физической памяти, многоуровневые таблицы разбивают эту информацию на несколько меньших таблиц *(рис. 14)*, что более рационально для многозадачных операционных систем

Каждый виртуальный адрес представляется тремя частями:  
**Page Tales Number** — запись в основной таблице, где мы найдем нашу вторую побочную таблицу.  
**Page Tales Offset** — указывают на строку во второй таблице.  
**Page Offset** — смещение, указывает на конкретную ячейку памяти внутри соответствующей таблицы.
<div align="center">

![](https://sun9-66.userapi.com/impg/SFQbXS6gXGXjVjQd7gS2CASnJPWd9QCaWy06VQ/5xWwVBhhDh4.jpg?size=844x698&quality=96&sign=0a7cd0743c7ef6aed92d838298232706&type=album)  
*Рис. 14. Пример многоуровневой таблицы страниц.*
</div>

Благодаря этому легко реализуется **приватное адресное пространство** *(рис. 15)* между процессами, где:
- Каждый процесс имеет собственную страничную таблицу
- Страничная таблица включает в себя все страницы процесса
- Страничные таблицы позволяют хранить страницы процесса не непрерывно
<div align="center">

![](https://sun9-52.userapi.com/impg/Amkbb__l_Sa2ERkECfl948kSd3DDIlpoD3jBBQ/uPcEtKdFyN4.jpg?size=1610x713&quality=96&sign=1ddda2b5543e2eebec397ac1851002a7&type=album)  
*Рис. 15. Приватное адресное пространство.*
</div>

## Метод граничных регистров
Существует так же другой подход - **сегментная реализация памяти**. В сегментной памяти вся память делится не на одинаковые страницы, а на сегменты разной величины. Для того чтобы операционная система могла регулировать чтобы процесс не выходил за свои сегменты используется подход который называется **метод граничных регистров** *(рис. 16)*.

При каждом обращении процесса к памяти операционная система проверяет, чтобы адрес был между значениями регистров базы и границы. Если адрес находится за пределами этого диапазона, генерируется ошибка, и процесс не может получить доступ к памяти вне своего выделенного блока.
<div align="center">

![](https://sun9-78.userapi.com/impg/cwcL3pR8CZ_IucngFOd-wgepD2tyLZZYNOCfHw/_PUxaAI9tEM.jpg?size=692x508&quality=96&rotate=90&sign=e5f183320508b0593cabdf8afc610129&type=album)  
*Рис. 16. Метод граничных регистров.*
</div>

## Операционная система
Когда на машине одновременно запущены несколько программ, каждая из них не имеет возможности прямого обращения к аппаратным ресурсам. Вместо этого именно операционная система определяет, как эти программы будут разделять доступ к оборудованию. Это осуществляется для обеспечения безопасности и эффективности, так как **только операционная система** имеет неограниченный доступ к аппаратным ресурсам. Когда программа хочет взаимодействовать с этими ресурсами, она обращается к программному интерфейсу, известному как **ABI (Application Binary Interface)**.

Этот интерфейс служит мостом между операционной системой и запущенной программой, обеспечивая гладкое взаимодействие между ними.
<div align="center">

![](https://sun9-80.userapi.com/impg/7IuraxAPaiPmLUojkSThNl6wIJ5bjdIRyB55Qg/4d2z28g50s4.jpg?size=740x168&quality=96&sign=17fd6a1ba3240e8cd51973301eef261c&type=album)  
*Рис. 17. Схема, демонстрирующая взаимодействие между запущенными программами, операционной системой и аппаратными ресурсами.*
</div>

### Процесс vs. программа

* Программа – это набор инструкций (только ее код)
* **Процесс** – это экземпляр программы, которая выполняется
  - Состоит из **кода программы** и **контекста** (регистры, содержимое памяти и другие ресурсы)
* Ядро операционной системы **(OS Kernel)** это привилегированный процесс

### Цели операционной системы

1. **Защита и приватность**: Операционная система обеспечивает строгую изоляцию между процессами, чтобы гарантировать, что один процесс не может вмешиваться в работу другого или получать доступ к его данным. Это обеспечивает безопасность данных и предотвращает возможные ошибки или злонамеренные действия. Процесс может взаимодействовать только со своим выделенным адресным пространством и ресурсами, исключая возможность несанкционированного доступа к данным других процессов.

2. **Абстракция**: Предоставление удобного и понятного интерфейса для работы с аппаратными ресурсами. Она скрывает сложные детали реализации аппаратного обеспечения, позволяя программам и пользователю взаимодействовать с системой на более высоком, абстрактном уровне. Это облегчает разработку приложений, так как разработчикам не нужно знать о всех нюансах работы аппаратуры.

3. **Управление ресурсами**: Действует как посредник между аппаратными ресурсами компьютера и запущенными на нем процессами. Она определяет, какие процессы будут выполняться, когда и сколько ресурсов (CPU, память или внешние устройства) они будут использовать. Этот контроль необходим для оптимизации производительности, обеспечения справедливого доступа к ресурсам и предотвращения конфликтов.

### Управление процессами и ресурсами в ядре операционной системы
Основная задача ядра операционной системы – это управление ресурсами компьютера и обеспечение стабильного взаимодействия между аппаратной и программной частями. **Каждому процессу** выделяется **приватное адресное пространство** в физической памяти, гарантируя, что процессы не могут вмешиваться в память друг друга. Этим обеспечивается **безопасность и изоляция** при выполнении приложений.

В области управления процессами, ядро операционной системы **планирует доступ к CPU**. Каждому процессу выделяется определенное **время работы на процессоре**, и приложение не может использовать больше этого времени.

Помимо управления ресурсами, ядро ОС также предоставляет интерфейс для взаимодействия программ с аппаратной частью. Этот интерфейс, известный как **системные вызовы (system calls)**, позволяет процессам получать доступ к таким службам, как файловая система или сетевое оборудование.

### Виртуальные машины
Виртуальные машины представляют собой эффективный инструмент, который позволяет операционной системе создавать изолированные среды для каждого процесса. **Каждый процесс** при этом "думает", что он выполняется на отдельной, независимой машине. На деле, конечно, эта машина не имеет реального аппаратного обеспечения, ведь она является лишь **эмуляцией** реального компьютера *(рис. 18)*.

Суть виртуальной машины заключается в том, чтобы предоставить программам иллюзию независимости и полного контроля над ресурсами, в то время как реальное аппаратное обеспечение делится между несколькими такими виртуальными средами. Эта концепция оказалась настолько мощной и универсальной, что сегодня она используется не только в рамках операционных систем, но и во многих других областях информационных технологий.

Процесс, исполняемый на **RISC-V**, интерпретируется через **RISC-V эмулятор**. В то время как **JavaScript** работает внутри **браузера**, который в свою очередь взаимодействует с **ABI OS**. Все это управляется **операционной системой**, которая напрямую работает с **x86 аппаратным обеспечением**.
<div align="center">

![](https://sun9-47.userapi.com/impg/xCaciNTlrXZ9pvZ355GYenm07A-H-LZFTLXLRA/DDGpz-k2Tn4.jpg?size=1016x473&quality=96&sign=ff0c3e684e07a1eaccd1dd1a67a643dc&type=album)  
*Рис. 18. Концепция виртуальных машин.*
</div>

### Прерывания и исключения
**Исключение** – событие которое требует обработки операционной системой (неподдерживаемая инструкция, системный вызов, деление на ноль…) *(рис. 19)*
<div align="center">

![](https://sun9-63.userapi.com/impg/OrH7jhmJr_LttwXQfxYVPeMyMoEdiDF3lCVVQg/ICQ01d-8RdQ.jpg?size=665x364&quality=96&sign=1ce4b1765f60743b168ea636b6b5d2c0&type=album)  
*Рис. 19. Схема работы с исключениями.*
</div>

**Прерывания** – асинхронные события, требующие обработки операционной системой (таймер, мышка, клавиатура…)

### Cистемные вызовы
Эти вызовы обеспечивают возможность программам обращаться к таким базовым функциям, как **доступ к файлам**, **использование сетевых ресурсов**, **управление памятью**, а также предоставляют информацию о системе, позволяют ожидать событий или создавать новые процессы.

Несмотря на важность системных вызовов, большинство программ редко работает с ними напрямую. Вместо этого они опираются на **библиотечные подпрограммы**, которые служат прослойкой между программой и ядром ОС. Отдельные системные вызовы могут блокировать выполнение процесса до тех пор, пока не будет выполнено определенное условие или событие.

### Системные вызовы RISC-V
В архитектуре `RISC-V` системные вызовы осуществляются с помощью инструкции `ecall`, которая инициирует исключение, устанавливая регистр `mcause` в специфическое значение. Этот механизм позволяет программам взаимодействовать напрямую с операционной системой.

Для успешного выполнения системного вызова необходимо следовать соглашению **ABI (Application Binary Interface)**. Этот интерфейс определяет, как именно аргументы и результаты будут передаваться между процессом и ядром. Это соглашение в многом напоминает тот механизм, который используется при вызове обычных подпрограмм.

На практике это выглядит следующим образом:
* **Номер системного вызова** помещается в регистр `a7`.
* Аргументы для этого вызова размещаются в регистрах `a0` до `a6`.
* После выполнения системного вызова, результаты будут находиться в регистрах `a0` и `a1` (или в основной памяти)

* Все регистры в этом контексте сохраняют свое состояние, что гарантирует безопасное выполнение и возврат из системных вызовов.

### Жизненный цикл процесса
<div align="center">

![](https://sun9-6.userapi.com/impg/LXDAVElMre1odebKl0AOpmJd2LjyngXgaX9xEw/vRQ5G60Eom0.jpg?size=769x189&quality=96&sign=9a096b943e41481f384f065f56752192&type=album)  
*Рис. 20. Механизм управления процессами в операционной системе.*
</div>

Операционная система поддерживает список всех процессов в системе, отслеживая их текущие статусы, такие как **"готов к выполнению" (ready)**, **"выполняется" (executing)**, **"ожидает" (waiting)**, и другие.

Когда процесс готов к выполнению, операционная система планирует его выполнение. Процесс получает определенное количество процессорного времени для выполнения своей задачи или работает до завершения.

Если процесс делает системный вызов, который не может быть немедленно удовлетворен (например, если он ждет доступа к диску или другому ресурсу), то процесс переходит в состояние **"ожидания"**. Он приостанавливается и ожидает, когда его запрос будет выполнен.

Как только запрос, ожидающий процесса, удовлетворен (например, когда ресурс становится доступным), процесс переходит обратно в состояние **"готовности"**. Теперь он готов к выполнению и ожидает своей очереди.

### Основные материалы лекции.
1. [Ссылка](https://www.youtube.com/watch?v=Q0XINgDHCZE) на видеозапись лекции
