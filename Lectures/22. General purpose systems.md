# Лекция 22. Системы общего назначения


## Микропроцессоры

Для начала мы повторим классифицирование микропроцессоров.
<div align="center">

![](Pic/lec-22-1.png)

*Рис. 1. Классификация микропроцессоров.*
</div>

**Микропроцессоры общего назначения** - нужны для решения любых задач, он не предназначен для специализированных задач. Для них мы используем **специализированные микропроцессоры**.

**Специализированные микропроцессоры** - альтернатива, которую мы можем разделить на **микроконтроллеры** и **процессоры цифровой обработки сигналов**. Про микроконтроллеры мы подробнее поговорили на прошлой лекции.

**Процессоры цифровой обработки сигналов** - фактически это те же **микроконтроллеры**, но они больше ориентированы на цифровую обработку сигналов.

В этой лекции мы рассмотрим процессоры общего назначения.

## История x86

Процессоры общего назначения - процессоры **x86**. Процессоры **x86** имеют архитектуру с полным набором команд, то есть поддерживает большое количество инструкций с разной шириной.

Впервые архитектура **x86** была представлена компанией Intel в 1978 году (Intel **8086**). Следующие версии **8086** стали совершентсвовать первую версию добавлением новых инструкций, таймеров, контроллеров, защищенныйх режимов и т.д. С полным списком можно ознакомиться на картинке.
<div align="center">

![](Pic/lec-22-2.png)

*Рис. 2. Развитие процессора Intel 8086.*
</div>

## Тик-так
Когда Intel делают свои процессоры они используют подход **"Тик-так"**. Суть его заключается в том, что они в одном году разрабатывают новую архитектуру (**тик**), а в следующем осваивают новый тех. процесс (**так**). По картинке можно увидеть как работал **"Тик-так"** до 2015 года, сейчас это работает немного "криво", но общая идея понятна.
<div align="center">

![](Pic/lec-22-3.png)

*Рис. 3. Подход Тик-так.*
</div>

## Coffee lake
Посмотрим на конкретный пример архитектуры **x86** - **Coffee lake** реализованный в 2017 году. 
Изучим его микроархитектуру. Она состоит из трех основных блоков: **подсистема памяти**, **Execution Engine**, **Front-end** (который является CISC оболочкой) 

**_Front-end_** - состоит из **кеш-инструкции**. Из **кеш-памяти** за один такт считывается сразу 16 байт (количество инструкций зависит от того сколько они будут занимать байт). Из **кеш-памяти** инструкции попадают в блок **Instruction Fetch**, где определяется в каком порядке необходимо выполнять полученные инструкции. Из этого блока выходят до 6 макро-операций CISC инструкций в блок очереди инструкций, где благодаря **Macro-Fusion** некоторые инструкции объединяются (только если это допустимо). Из **Instruction Queue** выходит 5 макро инструкций с учётом того, что некоторые могли быть объеденены в одну, и попадают в **5-секционный дешифратор**. Он преобразует макро операции CISC инструкции в RISC инструкции. Отсюда разные макро инструкции транслируются в разную последовательность микро инструкций (просто инструкции для RISC процессора). Простые инструкции попадают в **Simple Decoder** и преобразуются в одну микро инструкцию. Более сложные попадают в **Complex Decoder**. Ещё сложнее инструкции ссылаются на память микропрограмм **MicroCode Sequencer**. Помимо всего здесь подключен **Stack Engine**, чтобы меньше обращаться к основной памяти - пока этот стек не заполнен вызов подпрограмм и сохранение информации будет происходить на этом стеке. Также мы имеем **Branch Predictor**, который связан с кэшем и **Decoded Stream Buffer**, сохраняющий уже использованные инструкции, чтобы повторно их не декодировать. В блоке **MUX** мы имеем набор инструкций, которые уже нужно выполнить. От туда они попадают в **Allocation Queue**, где мы также имеем **Micro-Fusion** для дополнительной доработки микро инструкций. **Loop Stream Detector** необходим для запоминания последних 18 инструкций и определяет есть ли цикл. Из этого блока мы переходим к **Execution Engine**.
<div align="center">

![](Pic/lec-22-front.png)

*Рис. 4. Front-end Coffee Lake.*
</div>

**_Execution Engine_** - получает инструкции в **ReOrder Buffer**, который переименовывает регистры, чтобы избежать конфликтов. Из блока **ReOrder Buffer** выходят микро инструкции с известными местами куда будет сохранено, переименованными регистрами и т.д., попадают в **Scheduler Unified Reservation Station**, где происходит диспетчеризация, то есть микро инструкции раздаются на различные порты. На выходе каждого порта стоят функциональные блоки. Результаты этих блоков подключены к подсистеме **Memory Subsystem**
<div align="center">

![](Pic/lec-22-execution.png)

*Рис. 5. Execution Engine Coffee Lake.*
</div>

**Memory Subsystem** - подсистема памяти. Данные попадают в **Load Buffer** и **Store Buffer**, подключенные к кешу первого уровня **L1 Data Cache**, который в свою очередь передаёт всё в кеш второго уровня. **L2 Cache** уже является общим для команд и для данных.
<div align="center">

![](Pic/lec-22-memory.png)

*Рис. 6. Memory Subsystem Coffee Lake.*
</div>

На рисунке 7 можно увидеть связь основных блоков Coffee Lake и общую микроархитектуру.
<div align="center">

![](Pic/lec-22-4.png)

*Рис. 7. Микроархитектура Coffee Lake.*
</div>

Выше мы рассмотрели одно ядро. **Coffee Lake** может иметь 4, 6 и 8 ядер (на рисунке ниже представлен 4-ядерный процессор). Здесь используется **кольцевая шина**, идея заключается в том, что она объединена в кольцо и передача информации идёт по кругу, благодаря чему устраняются конфликты, допустим когда несколько устройств хотят завладеть шиной. В правой части находится **System Agent**. Он связан с взаимодействием с памятью, дисплеем и другими внешними устройствами.
<div align="center">

![](Pic/lec-22-5.png)

*Рис. 8. четырёхъядерный процессор Coffee Lake.*
</div>

Метод **кольцевой шины** имеет и минусы - если её расширять, то её пропускная способность падает.

## Gen9.5
**Gen9.5** - графическое ядро. Оно состоит из 
* **Command Streamer** - устройство, которое управляет потоком исполнения.
* **EU (Execution Unit)** - исполнительные устройства, производящие вычисления.
<div align="center">

![](Pic/lec-22-6.png)

*Рис. 9. Графическое ядро Gen9.5.*
</div>

## AMD Zen
Для сравнения рассмотрим микро архитектуру **AMD Zen**. Многие блоки совпадают с **Coffee Lake**, поэтому акцентируем внимание на отличиях: в данной реализации инструкции сортируются в зависимости от того целочисленные они (Integer) или с плавающей запятой (FP/SIMD). Этот пример используется в ознакомительных целях - показать, что есть и другие микро архитектуры.
<div align="center">

![](Pic/lec-22-7.png)

*Рис. 10. Микроархитектура AMD Zen.*
</div>

## Из чего состоит компьютер?
Выйдем на уровень системы. То что мы смотрели до этого - **центрально процессорное устройство (CPU)**. Сейчас же мы разберём из чего в целом состоит компьютер.
* **ЦПУ (Центрально Процессорное Устройство)**
* **Генератор тактовых импульсов**
* **Чипсет** - он состоит из одной или двух микросхем (северного и южного моста). В современных процессорах северных мост стали встраивать в **ЦПУ**, так как через него процессор общается с памятью и высокоскоростной шиной. Южный мост связан с менее быстрыми устройствами (BIOS, PCI и периферия)
<div align="center">

![](Pic/lec-22-8.png)

*Рис. 11. Материнская плата в схематичном варианте.*
</div>

Немного живого примера, чтобы вам не разбирать свой компьютер и не изучать где на материнской плате находится северный и южный мост - умная картинка. 
Как видно Северный мост находится ближе к процессору, а южный к периферии, USB и т.п. 
<div align="center">

![](Pic/lec-22-9.png)

*Рис. 12. Материнская плата.*
</div>

## Основные материалы лекции
1. [Ссылка](https://www.youtube.com/watch?v=w7CcAgTtL6k&list=PL0def37HEo5KHPjwK7A5bd4RJGg4djPVf&index=22) на видеозапись лекции