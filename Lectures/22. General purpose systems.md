# Лекция 22. Системы общего назначения


## Микропроцессоры

Для начала повторим классификацию микропроцессоров.
<div align="center">

![](Pic/lec-22-1.png)

*Рис. 1. Классификация микропроцессоров.*
</div>

**Микропроцессоры общего назначения** – нужны для решения любых задач, они не предназначен для специализированных задач. Для них мы используем **специализированные микропроцессоры**.

**Специализированные микропроцессоры** – альтернатива, которую мы можем разделить на **микроконтроллеры** и **процессоры цифровой обработки сигналов**. Про микроконтроллеры мы подробнее поговорили на прошлой лекции.

**Процессоры цифровой обработки сигналов** – фактически это те же **микроконтроллеры**, но они больше ориентированы на цифровую обработку сигналов.

В этой лекции мы рассмотрим процессоры общего назначения.

## История x86

Процессоры архитектуры **x86** имеют архитектуру с полным набором команд, то есть поддерживают большое количество инструкций с разной шириной.

Впервые архитектура **x86** была представлена компанией Intel в 1978 году (Intel **8086**). Следующие версии **8086** стали совершенствовать первую версию добавлением новых инструкций, таймеров, контроллеров, защищенных режимов и т.д. Полный список представлен в таблице 1.


| Версия      |                       Что было добавлено                        | Год выпуска |
|:------------|:---------------------------------------------------------------:|:-----------:|
| Intel 8086  |          16-битный, 98 инструкций, 7 режимов адресации          |    1978     |
| Intel 80186 |     Новые инструкции, КПДП, таймеры, контроллер прерывания      |    1982     | 
| Intel 80286 |              Защищенный режим, виртуальная память               |    1982     |
| Intel 80386 |        32-битный, страничная организация, до 4 Гб памяти        |    1985     | 
| Intel 80486 |                   Сопроцессор, 150 инструкций                   |    1989     |
| P6          | Суперскалярный CISC, RISC-ядро, предсказание условных переходов |    1995     | 
| MMX         |  **M**ulti**m**edia E**x**tensions (мультимедийные расширения)  |    1997     |


*Таблица 1. Развитие процессора Intel 8086.*


## Тик-так
Когда Intel делают свои процессоры они используют подход **"Тик-так"**. Суть его заключается в том, что они в одном году разрабатывают новую архитектуру (**тик**), а в следующем осваивают новый тех. процесс (**так**). На рисунке 2 можно увидеть как работал **"Тик-так"** до 2015 года, сейчас это работает немного "криво", но общая идея понятна.
<div align="center">

![](Pic/lec-22-3.png)

*Рис. 2. Подход Тик-так.*
</div>

## Coffee lake
Рассмотрим микроархитектуру процессора **Coffee Lake**, выпущенного в 2017-ом году. Она состоит из трех основных блоков:

- **Memory Subsystem** (подсистема памяти);
- **Execution Engine** (RISC-ядра);
- **Front-end** (CISC-оболочка поверх **Execution Engine**).

<div align="center">

![](Pic/lec-22-4.png)

*Рис. 3. Микроархитектура Coffee Lake.*
</div>

Разберём каждый блок подробнее:
### **_Front-end_** 
Из **кеш-памяти** за один такт считывается сразу 16 байт CISC-инструкций. Они могут быть разной длины, поэтому неизвестно что будет в этих 16 байт — это может быть 2 инструкции, может быть кусок инструкции с предыдущих 16-и байт, может быть кусок инструкции которая не поместилась и т.д. В блоке **Instruction Fetch** определяется, что за инструкции были получены и в каком порядке необходимо их выполнять. 


Из блока **Instruction Fetch** выходят до 6 макро-операций CISC инструкций (машинные инструкции x86) в блок очереди инструкций, где благодаря **Macro-Fusion** некоторые инструкции объединяются (то есть если пару инструкций можно выполнить как одну инструкцию).


Из **Instruction Queue** выходит 5 макро инструкций (с учётом того, что некоторые могли быть объеденины в одну, если такие инструкции были), и попадают в **5-Way Decode (пяти секционный дешифратор)**.


**Пяти секционный дешифратор** преобразует макро операции CISC инструкции в RISC инструкции. Отсюда разные макро инструкции транслируются в разную последовательность микро инструкций (инструкции для RISC процессора). Простые инструкции попадают в **Simple Decoder** и преобразуются в одну микро инструкцию. Более сложные попадают в **Complex Decoder**. Ещё сложнее инструкции ссылаются на память микропрограмм **MicroCode Sequencer**. Помимо всего здесь подключен **Stack Engine**, чтобы меньше обращаться к основной памяти - пока этот стек не заполнен вызов подпрограмм и сохранение информации будет происходить на этом стеке. Также мы имеем **Branch Predictor**, который связан с кэшем и **Decoded Stream Buffer**, сохраняющий уже использованные инструкции, чтобы повторно их не декодировать. 


В блоке **MUX** мы имеем набор инструкций, которые уже нужно выполнить. От туда они попадают в **Allocation Queue**, где мы также имеем **Micro-Fusion** для дополнительной доработки микро инструкций. **Loop Stream Detector** необходим для запоминания последних 18 инструкций и определяет есть ли цикл. Из этого блока мы переходим к **Execution Engine**.
<div align="center">

![](Pic/lec-22-front.png)

*Рис. 4. Front-end Coffee Lake.*
</div>

### **_Execution Engine_** 
**ReOrder Buffer** получает инструкции и переименовывает используемые ими регистры, чтобы избежать конфликтов (чтение после записи, попытка записи в один регистр и т.д.). Переименовывание означает использование теневых регистров из **RAT - Register Alias Table** (дополнительных регистров), они необходимы для того, чтобы не нарушать порядок записи в одну ячейку и записать результат в теневой регистр. Из блока **ReOrder Buffer** выходят микро инструкции с известными адресами куда они будут сохранены, переименованными регистрами и т.д. Они попадают в **Scheduler Unified Reservation Station**


В **Scheduler Unified Reservation Station** происходит диспетчеризация, то есть микро инструкции раздаются на различные порты. На выходе каждого порта стоят функциональные блоки (**EUs - Execution Units**). Каждый из них выполняет свои задачи - целочисленное ALU, целочисленное деление, векторные операции и т.п. Некоторые из этих блоков подключены к подсистеме памяти (**Memory Subsystem**).
<div align="center">

![](Pic/lec-22-execution.png)

*Рис. 5. Execution Engine Coffee Lake.*
</div>

**Memory Subsystem** – подсистема памяти. Данные попадают в **Load Buffer** и **Store Buffer**, подключенные к кешу первого уровня **L1 Data Cache**, который в свою очередь передаёт всё в кеш второго уровня. **L2 Cache** уже является общим для команд и для данных.
<div align="center">

![](Pic/lec-22-memory.png)

*Рис. 6. Memory Subsystem Coffee Lake.*
</div>


Выше мы рассмотрели одно ядро. **Coffee Lake** может иметь 4, 6 и 8 ядер (на рисунке 8 представлен 4-ядерный процессор). Подсистемы памяти каждого ядра объединяются в **кольцевую шину**.  **Кольцевая шина** передаёт информацию по кругу, благодаря чему устраняются конфликты, допустим когда несколько устройств хотят завладеть шиной. В правой части находится **System Agent**. Он связан с взаимодействием с памятью, дисплеем и другими внешними устройствами.
<div align="center">

![](Pic/lec-22-5.png)

*Рис. 7. четырёхъядерный процессор Coffee Lake.*
</div>

Метод **кольцевой шины** имеет и минусы – если её расширять, то её пропускная способность падает.

## Gen9.5
**Gen9.5** – графическое ядро. Оно состоит из 
* **Command Streamer** – устройство, которое управляет потоком исполнения.
* **EU (Execution Unit)** – исполнительные устройства, производящие вычисления.
<div align="center">

![](Pic/lec-22-6.png)

*Рис. 8. Графическое ядро Gen9.5.*
</div>

## AMD Zen
Для сравнения рассмотрим микро архитектуру **AMD Zen**. Многие блоки совпадают с **Coffee Lake**, поэтому акцентируем внимание на отличиях: в данной реализации инструкции сортируются в зависимости от того целочисленные они (Integer) или с плавающей запятой (FP/SIMD). Этот пример используется в ознакомительных целях - показать, что есть и другие микро архитектуры.
<div align="center">

![](Pic/lec-22-7.png)

*Рис. 9. Микроархитектура AMD Zen.*
</div>

## Из чего состоит компьютер?

Выйдем на уровень системы. То что мы смотрели в прошлых параграфах - **центрально процессорное устройство (CPU)**. Сейчас же мы разберём из чего в целом состоит компьютер:
* **ЦПУ (Центральное Процессорное Устройство)**
* **Генератор тактовых импульсов**
* **Чипсет** – набор микросхем, спроектированных для совместной работы с целью выполнения набора заданных функций, который состоит из одной или двух микросхем (северного и южного моста). Он отвечает за «общение» всей периферии и комплектующих между собой.

**Северный мост** – это контроллер-концентратор памяти, который взаимодействует с памятью и графическими адаптерами. Чтобы ускорить общение с высокоскоростной шиной в современных процессорах северных мост стали встраивать в **ЦПУ**.

**Южный мост** – контроллер-концентратор ввода-вывода, который связан с менее быстрыми устройствами (BIOS, PCI и периферия).

**BIOS** – базовая система ввода-вывода. С загрузки **BIOS** начинается включение компьютера: **BIOS** копирует свою программу в основную память и отдаёт её процессору управления, чтобы **ЦПУ** проверило какое оборудование подключено, как его необходимо сконфигурировать и в рабочем ли состоянии оно находится (т.е. сканирует и конфигурирует систему).

<div align="center">

![](Pic/lec-22-8.png)

*Рис. 10. Материнская плата в схематичном варианте.*
</div>

На рис. 11 представлена иллюстрация расположения **северного** и **южного моста** на материнской плате.
Обратите внимание на то, что **северный мост** находится ближе к процессору, а **южный** к периферии, USB и т.п. 
<div align="center">

![](Pic/lec-22-9.png)

*Рис. 11. Материнская плата.*
</div>

## Основные материалы лекции
1. [Ссылка](https://www.youtube.com/watch?v=w7CcAgTtL6k&list=PL0def37HEo5KHPjwK7A5bd4RJGg4djPVf&index=22) на видеозапись лекции