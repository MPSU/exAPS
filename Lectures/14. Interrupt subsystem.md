# Лекция 14. Подсистема прерывания

## Содержание
* [Определение](#Определение)
* [Передача управления при прерывании](#Передача-управления-при-прерывании)
* [Классификация событий прерывания](#Классификация-событий-прерывания)
* [Основные характеристики прерываний](#Основные-характеристики-прерываний)
* [Способы выявления прерывания](#Способы-выявления-прерывания)
* [Схемы реализации контроллера прерываний](#Схемы-реализации-контроллера-прерываний)
* [Control and Status Register Risc-V](#Control-and-Status-Register-Risc\-V)
* [Программа, реализующая прерывания на ассемблере](#Программа,-реализующая-прерывания-на-ассемблере)


## Определение

**Прерывание** — событие, на которое реагирует процессор. 

_Пример_: Перемещение курсора по экрану. Если бы не было прерываний, то процессор был бы вынужден постоянно обращаться к курсору с целью узнать: изменилось ли его положение или нет. А это очень ресурсоёмко. Такой подход называется [сканирование входов](#Сканирование-входов). 

## Передача управления при прерывании ###
Допустим, во время выполнения программы произошло событие прерывания. Процессор останавливает её выполнение на i-инструкции и начинает выполнять программу обработки прерывания. Завершив её, процессор возобновляет основную программу с i+1-инструкции, причём прерывание на результат выполнения не влияет.

<div align="center">
    
![](https://sun9-2.userapi.com/impg/GQiv1r_Ut17w1xVBPWhzMxbwfUWhILqp-tyTKw/zpj5WO0oYlI.jpg?size=453x241&quality=95&sign=7529a0a0e12f45f6b6a7c92fe34d5cac&type=album)

*Рис. 1. Схема передачи управления при прерывании.*
</div>


## Классификация событий прерывания ###
* **Прерывание** — события, которые происходят внутри аппаратуры. Это событие происходит _ассинхронно_ с фронтом тактового импульса. Например: изменение положения курсора.
    - Маски́руемые — прерывания, которые процессор может игнорировать. _Например_: нажатие клавиши на клавиатуре. [Аппаратная реализация](#Маскирование-прерывания) будет продемонстрированна чуть позже.
    - Немаски́руемые — прерывания, которые процессор не может игнорировать. _Например_: сигнал от датчика температуры о перегреве процессора.  
* **Исключения** — события, происходящие вследствие выполнения какой-то инструкции. Это событие происходит _синхронно_ с фронтом тактового импульса.
    - Ошибки. _Например_: обращение в несуществующую область памяти.
    - Ловушки. _Например_: деление на 0.
    - Отказы. _Например_: ситуации, которые никак нельзя устранить. Зачастую приводят к выключению/перезапуску процессора.

## Основные характеристики прерываний ###
* **Время реакции прерывания**, T<sub>реакции</sub>

  Это время, между запросом на прерывание и переходом к прерывающей программе (см. рис. 2) 

* **Затраты времени на переключение программ**, T<sub>загрузки</sub> и T<sub>востановления</sub>

  Это время, которое требуется программе выполнить сервисные инструкции (см. рис. 2). Например: узнать причину прерывания, сохранить данные на стек прерывания и др.

* **Эффективность прерывания**

  Это время эффективной работы программы. Т.е. отношение "полезных" (не сервисных) инструкций программы прерывания ко всем интсрукциям прерывания.

<div align="center">
    
![](https://sun9-32.userapi.com/impg/vMcgz-Eh73spCuy-Vx1jUEMw4uCaby6-1a54FA/_xp9ZL30BmY.jpg?size=580x202&quality=95&sign=dae8f9375c7909fa13786ccd3bc31af4&type=album)

*Рис. 2. Характеристики прерывания.*
</div>

* **Глубина прерывания**

    Это кол-во прерываний, которые могут произойти во время обработки прерывания (см. рис. 3). Например: если процессор, находясь внутри прерывания, не способен прерваться на другое, то говорят что глубина прерывания n=1. Также программы могут неограниченно прерывать друг друга, в таком случаем есть ограничение по памяти.


<div align="center">
    
![](https://sun9-77.userapi.com/impg/-GTsKOxTOTFas97itwiPCkMfpiFxy_YXJS3wTw/MMf09w31ad0.jpg?size=545x275&quality=95&sign=bacd790f453e2db6c9176270047f76c6&type=album)

*Рис. 3. Глубина прерываний.*
</div>

## Допустимые моменты прерывания программы ##

* **Метод помеченного оператора**

    Внутри какой-нибудь инструкции добавляется бит, отвечающий за прерывание. Допустим, если этот бит равен 1 и есть сигнал на прерывание, то процессор запустит обработчик прерывания.

* **Покоманднный метод**

    Этот метод относиться к [многотактным архитектурам](09.%20Multicycle%20processor.md). Процессор начинает реагировать на сигнал прерывания, только после завершения инструкции. 

* **Метод быстрого реагирования**

    Этот метод позволяет реагировать на прерывание на любом такте.

  ### Маски́рование прерывания 
  **Маска прерывания** — это регистр, отвечающий за разрешение на прерывани (см. рис. 4). Это маска побитово перемножается с запросами на прерывание других устройств/модулей и тд. Если в результате перемножения получилась хотя бы одна 1, то формируется сигнал ```interrupt```, который подаётся на блок управления процессора. 


<div align="center">
    
![]( https://sun9-74.userapi.com/impg/ScRTZGH65FMeQEivFUOssR2d2HBzIeLhcx-u2g/r7IEgx1blWM.jpg?size=470x323&quality=95&sign=efb81c5d2e2ddca8f07a0c67c3025cfe&type=album)

*Рис. 4. Аппаратная реализация маски́рования прерывания.*
</div>

## Способы выявления прерывания

* **Обзорная система прерывания**

    Каждый запрос на прерывание запускает одну и ту же подпрограмму, которая определяет кто отправил запрос, а затем запускает конкретную программу обработчика прерывания. Работает такая система сравнительно дольше, но реализация её проще.

* **Векторная система прерывания**

    В векторной системе есть участок памяти — _таблица векторов прерывания_. В таблице лежат **вектора прерывания** — адрес начала подпрограммы обработчика прерывания. После обращения к таблице будет запущена нужная подпрограмма. Работает такая система быстрее, но реализовать её сложнее.



## Схемы реализации контроллера прерываний
[**Контроллер прерывания**](#Контроллер-прерывания) — устройство, которое отвечает за передачу сигнала прерывания процессору и формирование кода причины прерывания. 

* **Цепочечная схема**

    От процессора идет сигнал подтверждения `ПДТ`, который приходит только когда процессор готов обработать какое-то прерывание (См. рис. 5.). Этот сигнал приходит вход первого устройства, которое, в случае необходимости, выдаёт сигнал на прерывание и вектор прерывания процессору. Если же в прерывании от первого устройства нет необходимости, то сигнал подтверждения передаётся на следующее устройство и т.д. Цепочечная схема проста в реализации, но очень долгая. К тому же в этой схеме некоторые устройства имеют приоритет на другими в очерёдности обработки запроса на прерывание. Также существует вероятность, что до последних устройств никогда не дойдёт сигнал подтверждения и они не смогут прервать выполнение. 

<div align="center">
    
![]( https://sun9-9.userapi.com/impg/ECurRjLX9GgWKN5Q8TqSHi7p2xEZ3zjUQqLkDQ/X3J_UUQ3SoI.jpg?size=358x281&quality=95&sign=c585c81f6acd83da3282093fba1431d2&type=album)

*Рис. 5. Цепочечная схема.*
</div>

* **Схема с циклическим опросом**

    Каждый раз, когда на счётчик ```СТ``` приходит сигнал ```C``` (тактирование), он увеличиает своё значение (см рис. 6). Затем это значение подаётся на вход дешифратору ```DC```, который только на одном выходе выдаёт 1. И каждый такт выход меняется от 0 до N. Если во время обхода всех выходов появится сигнал на прерывание, то этот сигнал отправится на RS тригер, который затем отправит ```interrupt``` сигнал процессору. А на вход ```C``` счётчика ```CT``` будет отправлен 0. В таком случае счётчик перестанет суммировать и он будет иметь значение кода номера прерывания. 
    
<div align="center">
    
![](https://sun9-23.userapi.com/impg/VaCCIXa-kjhBrWpIq202qaBFNThYb-LmEtKW4w/Rv5hs4j1JfA.jpg?size=500x327&quality=95&sign=de3ce75eaef5e81e05e4a54a5510cf90&type=album)

*Рис. 6. Циклическая схема.*
</div>
    
* **Дейзи-цепочка**
    
    Рассмотрим дейзи-цепочку (см. рисунок 7). Эта схема будет работать только тогда, когда вход "Приоритет" равен 1. Если на первый запрос пришла 1, то на соответсвующий выход y<sub>1</sub> будет подана 1, которая будет говорить о том, что именно первое устройство сделало запрос на прерывание. На выход ```INT``` также будет передана 1, которая отправится процессору для оповещения о прерывании. Т.е. на выходе y<sub>1</sub>...y<sub>n</sub> будет получена только одна 1 от запроса с наивысшим приоритетом. Дейзи-цепочка часто используется в определении наиболее приоритетного запроса.  


<div align="center">
    
![](https://sun9-55.userapi.com/impg/191tCbLsvRWn4XTQDN_ZaEygWGE9YaxFTOdJ2w/QVYvX2yJDT0.jpg?size=718x375&quality=95&sign=9e88a78f14eca5e397f4efaa9b0bde28&type=album)

*Рис. 7. Дейзи-цепочка.*
</div>

### Контроллер прерывания
Теперь рассмотрим как выглядит контроллер прерывания. (см. рис. 8) По каналу ```ПДТ``` поступает сигнал от процессора, разрешающий прерывание. Этот сигнал поступает на регистры запроса прерывания. Затем с помощью [маски прерывания](#Маски́рование-прерывания) определяются, каким устройствам разрешён запрос на прерывание. Сигналы на прерывания попадают в ```схему определения наиболее приоритетного запроса``` (_например_: дейзи-цепочка), где определяется самый приоритетный запрос.  С помощью ```формирователя номера запроса``` формируется некоторое число, отвечающее за степень приоритета запроса. В ```схеме сравнения приоритетов``` сравнивается это число с приоритетом текущего прерывания (приоритет текущего прерывания записан в регистры ```порога прерывания```). Если число, хранимое в регистрах "_порога прерывания_" меньше, то  в ```порог прерывания``` записывается новое число, а на процессор по каналу ```ЗП``` на процессор пойдёт сигнал о новом прерывании.    
    
<div align="center">
    
![](https://sun9-78.userapi.com/impg/mOhQU0GvbXsQzy07i7UmvT8LS4Vjaf9lwKm__w/8gJ67LZVPgA.jpg?size=770x427&quality=95&sign=a93df0d24e5d251b4ae437bab1a72226&type=album)

*Рис. 8. Схема контроллера прерывания.*
</div>


## Control and Status Register RISC-V
Это набор регистров, связанные с блоками процессора, с помощью которых можно управлять ими или узнавать информацию о них.  
Минимальный набор для поддержания прерывания в RISC-V нужно реализовать следующие регистры:

| Номер       | Привелегия | Имя       | Описание                                                   |
|:------------|:-----------|:----------|:-----------------------------------------------------------|
| Ox304       | MRW        | mie       | Регистр маски                                              |
| Ox305       | MRW        | mtvec     | Регистр вектора прерывания                                 |         
| Ox340       | MRW        | mscratch  | Регистр указателя на стек прерывания                       |
| Ox341       | MRW        | mepc      | Регистр адреса инструкции, на котором случилось прерывание |
| Ox342       | MRW        | mcause    | Регистр причины (кода) прерывания                          |


 Инструкции для работы с CSR: 
 
    
| Opcode    | func3 | Тип  | Инструкция          |  Описание                 | Операция                |
|:----------|:------|:-----|:--------------------|:--------------------------|:------------------------|
| 1110011   | 000   |  I   | mret                | Возврат и прерывание      | PC=merc                 |
| 1110011   | 001   |  I   | csrrw rd, csr, rs1  | Чтение/запись CSR         | rd = csr, csr=rs1       |                         
| 1110011   | 010   |  I   | csrrs rd, csr, rs1  | Чтение/установка бит CSR  | rd = csr, csr=rs1\|rs1  |
| 1110011   | 011   |  I   | csrrc rd, csr, rs1  | Чтение/очистка бит CSR    | rd=csr, csr=csr&~rs1    |


## Подсистема прерываний для RISC-V

<div align="center">
    
![](https://sun9-61.userapi.com/impg/kZ-MqJIfnuvJ2KX733lUlvs6MwH0Usbe7gFLdA/YZSPx-gaWhs.jpg?size=945x566&quality=95&sign=5e2f72be2bcce42ef41bd0a425585fd3&type=album)

*Рис. 9. Микроархитектура RISC-V с CSR.*
</div>


Теперь рассмотрим отдельно блок CSR:


<div align="center">
    
![](https://sun9-1.userapi.com/impg/s-JIOvaCNGF47sjDQ2l1vMOSFa5KCPNWA6wttQ/MwaQji6hXFw.jpg?size=599x533&quality=95&sign=32116d10136c0c7d923b9479220477b6&type=album)

*Рис. 10. Схема CSR.*
</div>

Рассмотрим схему CSR (см. рис. 10). На ней красным прямоугольником (номер 1) отмечены регистры CSR. К нему подключены мультиплексор и демультиплексор для считывания и записи данных с регистров (номер 2 и 3). С помощью входа ```A```, определяется к какому регистру будет применена запись/чтение. Теперь рассмотрим нижнюю часть схемы (см. рис. 11):

<div align="center">
    
![](https://sun9-80.userapi.com/impg/zFprYwGZAaX-qe2wgK3rNYfx6pYpYdZSeBDoQw/u1_GH0lZkcY.jpg?size=379x195&quality=95&sign=982d5a88a03188794fb77e9e0867f6cf&type=album)

*Рис. 11. Нижняя часть схемы CSR.*
</div>

Она нужна для оперативного обновления значений регистров ```mepc``` и ```mcause```. Вход ```OP[2]```  — это сигнал о возникновении прерывания. Если сигнал на прерывание равен 1, то значения mepc и mcause изменятся. Осталось рассмотреть верхнюю часть схемы (см. рис. 12):


<div align="center">
    
![](https://sun9-50.userapi.com/impg/RodLt8FYuDgvSwQ8PZUHcjBTgfim7GuRl0B5Ww/MJJIUL2YSlc.jpg?size=549x221&quality=95&sign=667d2221e1bdd119d25d1af4ddf108ca&type=album)

*Рис. 12. Верхняя часть схемы CSR.*
</div>

Она нужна для реализации инструкций для работы с CSR. В зависимости от нужной инструкции у выхода ```WD``` будет своё значение. На 0 вход мультиплексора поступают нули, если не требуется запись в регистры. 
Отдельно стоит отметить, что значение регистра причины прерывания ```mcause``` берётся из контроллера прерывания. А значение регистра маски прерывании ```mie```, которое мы устанавливаем в блоке CSR, отправляется в контроллер прерывания. Давайте рассмотрим устройство контроллера прерывания. У него будет [схема с циклическим опросом](#Схемы-реализации-контроллера-прерываний) (см. рис. 13):


<div align="center">
    
![](https://sun9-46.userapi.com/impg/8SWzd5Yv1HfZ5e1VuH4_O4OS3fzpVCOjIw9INg/wMDn4VmczR4.jpg?size=694x404&quality=95&sign=8fa27d62327165eb3f005dcb71ce270c&type=album)

*Рис. 13. Контроллер прерывания с циклическим опросом.*
</div>


На вход в контроллера прерывания подаётся регистры маски прерывания ```mie[31:0]```, запросы на прерывание ```int_req[31:0]```. Если бит маски и бит запроса будут равны 1 и в этот момент времени счётчик (красный прямоугольник на рисунке 13) будет соответствовать данному запросу на прерывание, то счётчик будет заблокирован и будет сформирован сигнал ```INT```, который сообщит о прерывании. Значение регистра mcause будет соответствовать значению остановленного счётчика.

Такое состояние будет, пока не придёт сигнал с ```INT_RST```. Также после получения сигнала ```INT_RST``` периферийному устройству, чей сигнал обрабатывался, будет передана 1 через регистр ```int_fin```, сигнализирующий о том, что обработка прерывания окончена. 

В целом схема подключения выглядит так (см. рис. 14): 

<div align="center">
    
![](https://sun9-4.userapi.com/impg/7nzXHD_xx9qqIcNxikYwEg-FRg5iIpmVkA0R3Q/Pq06PgsjTTU.jpg?size=646x465&quality=95&sign=18f37aedb3ca67cb4cf1edfcc8334299&type=album)

*Рис. 14. Схема подключения подсистемы прерывания.*
</div>


## Программа, реализующая прерывания на ассемблере

Программа обрабатывает два прерывания, имеющие коды 5 и 19. При 5 прерывании некоторое число из памяти делится на 2. При прерывании 19 к некоторому числу из памяти прибавляется 3. 

```assembly
# Инициализируем начальные значения регистров
    li    sp, 0xFFFFFFFC	# устанавливаем указатель на верхушку стека
    li    gp, 0x10000000	# устанавливаем указатель на глобальные данные
 
    li    t0, 0x00080020	# подготавливаем маску прерывания для 5 и 19 входов
    csrw  mie, t0		# загружаем маску в регистр маски
    la    t0, interrupt		# аналогично li загружает число, в данном случае - адрес
    csrw  mtvec, t0		# устанавливаем вектор прерывания
    li    t0, 0xEFFFFFFC	# готовим адрес верхушки стека прерывания
    csrw  mscratch, t0		# загружаем в указатель на верхушку стека прерывания
 
    li    t0, 1			# начальное значение глобальной переменной
    lw    t0, 0(gp)		# загружаем переменную в память 
 
while:				# бесконечный цикл, аналогичный while (1);
    beq x0, x0, while		# ничего не делаем!

interrupt:
    csrrw t0, mscratch, t0 	# меняем местами mscratch и t0
    sw    t1, 0(t0) 		# сохраняем t1 на стек mscratch
    sw    t2, 4(t0) 		# сохраняем t2 на стек mscratch  
 
		# Переключаем адрес возврата на следующую инструкцию
    csrr  t2, mepc 		# t2 = pc в момент прерывания
    addi  t2, t2, 4 		# увеличиваем pc на 4
    csrw  mepc, t2 		# mepc = mepc + 4
		
# Проверяем регистр причины и на 5-ое прерывание
    csrr  t1, mcause 		# t1 = mcause
    li    t2, 5 		# t2 = 5 (код одного из прерываний)
    bne   t1, t2, nineteen 	# если это не 5 прерывание, то проверяем 19
		# Обработчик 5-го прерывания
    lw    t2, 0(gp)		# загружаем переменную из памяти
    addi  t2, t2, 3		# прибавляем к значению 3
    sw    t2, 0(gp)		# возвращаем переменную в память
    j     done 			# идем возвращать регистры и на выход
 
nineteen:	# Проверяем на 19-ое прерывание
    li    t2, 19 		# t2 = 19 (код  другого прерывания)
    bne   t1, t2, done 		# если не 19-ое, то выходим
		# Обработчик 19-го прерывания
    lw    t2, 0(gp)		# загружаем переменную из памяти
    srli  t2, t2, 1		# делим число пополам сдвигом вправо
    sw    t2, 0(gp)		# возвращаем переменную в память
    j     done			# идем возвращать регистры и на выход
 
# Возвращаем регистры на места и выходим
done:
    lw    t1, 0(t0) 		# возвращаем t1 со стека
    lw    t2, 4(t0) 		# возвращаем t2 со стека
    csrrw t0, mscratch, t0 	# меняем обратно местами t0 и mscratch
    mret 			# возвращаем управление программе (pc = mepc)

```

### Сканирование-входов

**Сканирование входов** — последовательный программный опрос входных сигналов. Этот подход используется в супер-компьютерах, т.к. у них не развитая периферия. В таком случае подсистема прерываний не нужна. 

## Основные материалы лекции
1. [Ссылка](https://www.youtube.com/watch?v=E21EtIasiU8&t=3696s) на видеозапись лекции

## Дополнительные материалы к лекции для саморазвития

