# Лекция 16. Кэш-память.

### Содержание
* [КЭШ-память](#content0)
* [Иерархия памяти](#content0.1)
* [Пространственная и временная локальность данных](#content0.2)
* [Характеристики кэш-памяти](#content1)
* [Кэш прямого отображения](#content2)
* [Множественно-ассоциативный кэш](#content3)
* [Полностью ассоциативный кэш](#content4)
* [Алгоритмы замещения данных](#content5)
* [Основные оптимизации кэш-памяти](#content6)

### <span id="content0">КЭШ-память</span>
С 80-х годов процессоры начали превосходить по производительности память. Этот разрыв в скоростях привёл к потребности в быстром буфере памяти, который мог бы уменьшить задержку при обращении к данным. В 60-70-х годах начались эксперименты и исследования в области быстрых буферов, что привело к созданию **кэш-памяти**.  

<div align="center">

![](https://sun9-6.userapi.com/impg/RVIjPr0PmI4OEh3TaOtkyLdFLgQZ7OV9i-66Lg/f0cFnBrFPjM.jpg?size=680x371&quality=96&sign=ee2823c5524e811370c2fe0da89925d0&type=album)
</div>

**Что такое кэш память?**   
**Кэш-память** — это небольшой сегмент высокоскоростной памяти, обычно на базе SRAM(Static Random-Access Memory), расположенный непосредственно на процессоре или рядом с ним. Её главная функция — временное хранение тех данных, к которым процессор часто обращается. Основная цель такой памяти — уменьшить задержку доступа к данным, служа мостом между процессором и основной оперативной памятью.

**Для чего нужна кэш-память?**  
Основное **предназначение кэш-памяти** — ускорение доступа процессора к часто используемым данным и командам, минимизируя зависимость от более медленной основной памяти. Благодаря этому, время реакции системы сокращается, делая её более отзывчивой и эффективной.

### <span id="content0.1">Иерархия памяти</span>
**Иерархия памяти** - это объединение разных типов памяти с целью получения большой, дешевой, и быстрой памяти. Наивысший уровень иерархии (**Cache**) обычно является наиболее быстрым и наименее емким, в то время как нижний уровень обычно имеет наибольший объем, но и наибольшую задержку (**Hard Drive**).

<div align="center">

![](https://sun9-9.userapi.com/impg/KHI-Bn5z7ybI5TFSw_wY-ylDWyQbbV9ByaBfHA/mUujhu6kbZA.jpg?size=836x576&quality=96&sign=817942d70bff7946ff632706b69c2140&type=album)
</div>

**SRAM** (Static Random-Access Memory) - тип быстрой полупроводниковой памяти, который сохраняет данные без необходимости периодического обновления. Используется в кэш-памяти процессоров из-за своей высокой скорости.  
**DRAM** (Dynamic Random-Access Memory) - тип полупроводниковой памяти, который требует периодического обновления для сохранения данных.  
**SSD** (Solid-State Drive) - устройство хранения данных, работающее на основе NAND-памяти.  
**HDD** (Hard Disk Drive) - использует магнитные диски для записи и чтения данных, имеет больший объем по сравнению с SSD, но скорость доступа к данным обычно ниже.

### <span id="content0.2">Пространственная и временная локальность данных</span>
Когда процессор обращается к данным, кэш-память пытается сохранить не только эти конкретные данные, но и окружающие их, предполагая, что к ним может быть обращение из-за пространственной локальности. Таким образом, следующие запросы данных могут быть удовлетворены **кэшем**, а не более медленной основной памятью.

Кэш также хранит данные, к которым недавно обращались, рассчитывая на временную локальность, предполагая, что к этим данным будет обращение снова.

Благодаря этим принципам локальности кэш-память может значительно повысить производительность системы, предварительно загружая и храня наиболее вероятные данные для последующих запросов.

<div align="center">

![](https://sun9-64.userapi.com/impg/2sjUklJ7HXxf03PVuXJCRjTUJqfbCSfjnvMJTA/CO_Go1YGMCI.jpg?size=530x393&quality=96&sign=22df9fef0fa30274869e6868961213a5&type=album)
</div>

**Перед созданием Кэш-памяти нам нужно задаться 4-мя вопросами**:
* Где могут быть размещены данные в кэш-памяти? (<span style="color:rgb(255, 120, 0)">**[Размещение строки в разных видах кэшах-памяти](#content7)**</span>)
* Как найти данные в кэш-памяти? (<span style="color:rgb(255, 120, 0)">**[Идентификация строки](#content8)**</span>)  
* Какие данные нужно заместить, при заполненной кэш-памяти? (<span style="color:rgb(255, 120, 0)">**[Алгоритмы замещение строки](#content5)**</span>)
* Что происходит при записи в кэш-память? (<span style="color:rgb(255, 120, 0)">**[Стратегия записи](#content9)**</span>)

### <span id="content1">Характеристики кэш-памяти</span>

* Ёмкость – <span style="color:rgb(255, 120, 0)">***C***</span>  (capacity)
* Число наборов – <span style="color:rgb(255, 120, 0)">***S***</span>  (set)  
_Любая Кэш память обладает числом наборов. Каждая ячейка основной памяти может претендовать только на свой набор._
* Длина строки (блока) – <span style="color:rgb(255, 120, 0)">***b***</span>  (block)  
_Порция перемещения данных между разными уровнями иерархии памяти._
* Количество строк (блоков) – <span style="color:rgb(255, 120, 0)">***B***</span>  = C/b
* Степень ассоциативности – <span style="color:rgb(255, 120, 0)">***N***</span>  
_Количество места в кэш-памяти на которое притендует конкретная строка. Каждая ячейка может располагаться только в одном наборе, один набор может состоять из нескольких строк - это и есть степень ассоциативности._
<br><br>
* Кэш <span style="color:rgb(255, 120, 0)">***состоит из S наборов***</span>, каждый из которых содержит одну или несколько строк.
* Взаимосвязь между адресом в памяти и расположением в кэш называется <span style="color:rgb(255, 120, 0)">***отображением***</span>.
* Каждый адрес в памяти отображается в <span style="color:rgb(255, 120, 0)">***один и тот же набор кэша***</span>.  

<span id="content1">**Существует 3 вида кэш-памяти**</span>:
* [Кэш прямого отображения](#content2) – Набор S содержит только одну строку – <span style="color:rgb(255, 120, 0)">***S = B***</span>
* [Множественно-ассоциативный кэш](#content3) – Каждый набор S состоит из N строк – <span style="color:rgb(255, 120, 0)">***S = B/N***</span>
* [Полностью ассоциативный кэш](#content4) – Имеет только один набор <span style="color:rgb(255, 120, 0)">***S = 1***</span>

**Анализ производительности**
* Доля попаданий (hit rate - <span style="color:rgb(255, 120, 0)">**HR**</span>)
* Доля промахов (miss rate - <span style="color:rgb(255, 120, 0)">**MR**</span>)
* MR = <span>
  <sup>Число промахов</sup>&frasl;<sub>Общее число доступов к памяти</sub>
</span> = 1 - HR
* HR = <span>
  <sup>Число попаданий</sup>&frasl;<sub>Общее число доступов к памяти</sub>
</span> = 1 - MR
* <span style="color:rgb(255, 120, 0)">**AMAT**</span> - average memory access time
* AMAT = t<sub>cache</sub> + MR<sub>cache</sub> * (t<sub>MM</sub> + MR<sub>MM</sub> * t<sub>VM</sub>)  

Пример:

| Уровень памяти     | Время доступа в тактах | Процент промахов |
|:-------------------|:----------------------:|:----------------:|
| Кэш-память         |           1            |       10%        |
| Оперативная память |          100           |        0%        |

                                                                      
*AMAT* = 1 + 0.1 * (100) = 11
Какой должен быть MR, чтобы снизить AMAT до 1.5 тактов?  
1 + m * (100)=1.5 -> m = 0.005%

### <span id="content2">Кэш прямого отображения</span>
32-х битный адрес, основная память _memory_, 32-х битный адрес. Для примера у нас будет 8 наборов и длина строки будет одно слово.

<div align="center">

![](https://sun9-77.userapi.com/impg/iyVkc2EdM3-g2Qulzwu6E25YlatYfKfDaOmQTg/He43djKpOx4.jpg?size=875x456&quality=96&sign=770124b0123770466da000649dc1b39f&type=album)
</div>

<span id="content8">Каждая ячейка памяти претендует только на свой набор и имеет свой уникальный адрес, который делится на несколько частей</span>:

<div align="center">

![](https://sun9-3.userapi.com/impg/AnhKebLSUY5EH5Y1TfNl0wSSS_Skm_AfhGQaeA/H2BBNib77Fc.jpg?size=405x140&quality=96&sign=ffb3aada8e5606398c9ddc41769c8ba2&type=album)
</div>

где  
Первые 2 бита (**Byte Offset**) - смещение  
Следующие три бита (**Set**) указывают, на какой набор претендует ячейка памяти.  
Оставшиеся 10 бит представляют собой **Tag**, с помощью которого определяется, находится ли ячейка в кэш-памяти или нет.

**Пример:**  
```assembly
      addi $t0, $0, 5   # Инициализируем счетчик в регистре $t0 значением 5
loop: beq $t0, $0, done # Загружаем значения из памяти по адресам 0x4, 0xC и 0x8 в регистры $t1, $t2 и $t3 соответственно.  
      lw $t1, 0x4($0)
      lw $t2, 0xC($0)
      lw $t3, 0x8($0)
      addi $t0, $t0, -1 # Уменьшаем счетчик на 1.
      j loop            # Повторяем цикл, пока счетчик в регистре $t0 не достигнет нуля.
done:
```
Давайте разберём, как это работает:  
У нас есть цикл с 5 итерациями, что означает 15 обращений к памяти. При первом проходе по циклу мы сталкиваемся с промахами и записываем их в ячейки памяти. На последующих итерациях цикла у нас уже будут попадания.

<div align="center">

![](https://sun9-28.userapi.com/impg/CRJ-kAjHRxPCSwfjoUefllcML2dM_4T2Gf4kkg/kw7pBs87yEo.jpg?size=528x298&quality=96&sign=b8cba4ff9cc97a951dd144c051798fad&type=album)
</div>

В итоге из 15 обращений к памяти у нас 3 промаха. Теперь можем рассчитать **MR**:    
<div align="center">

![](https://sun9-34.userapi.com/impg/ExAPVEGyQcC96tYDK8MagZA1Z2bTjrI9TZhEvQ/6iGMfTLoRTE.jpg?size=569x83&quality=96&sign=cd0521fe112afef5572953c79dbf200c&type=album)
</div>

**Пример вытеснения (evict):**  
```assembly
      addi $t0, $0, 5   # Инициализируем счетчик в регистре $t0 значением 5
loop: beq $t0, $0, done 
      lw $t1, 0x4($0)   # Загружаем значения из памяти по адресу 0x4 в регистр $t1
      lw $t2, 0x24($0)  # Загружаем значения из памяти по адресу 0x24 в регистр $t2
      addi $t0, $t0, -1 # Уменьшаем счетчик на 1.
      j loop            # Повторяем цикл, пока счетчик в регистре $t0 не достигнет нуля.
done:
```
Загрузка двух ячеек памяти — 4 и 24 — приводит нас к проблеме. Обе эти ячейки ссылаются на один и тот же набор. Из-за этого при каждом обращении к памяти мы будем получать промах.  

<div align="center">

![](https://sun9-63.userapi.com/impg/Poo_OX7_m0YidsqjTYHy1kT2aOjX9LER2u1Raw/bEL7HKM4x5s.jpg?size=405x384&quality=96&sign=2084855c0cf9491c3dda44a4ee61a98e&type=album)
</div>

Соответственно **MR** в данном случае будет 100%:
<div align="center">

![](https://sun9-35.userapi.com/impg/bq3OviN2AOHEUyeceLemjqFQUHM2qkEr6emBlg/i6JYF6ya_hM.jpg?size=573x81&quality=96&sign=1042e084357c585b01697626151be912&type=album)
</div>

### <span id="content3">Множественно-ассоциативный кэш</span>
Идея множественно-ассоциативного кэша заключается в наличии нескольких строк внутри одного набора. Увеличив ассоциативность, мы теперь имеем двухсекционный кэш (**Way 1** и **Way 0**). Каждая ячейка памяти может претендовать на любую из этих двух секций, и, в таком случае, вытеснения не произойдет.
<div align="center">

![](https://sun9-34.userapi.com/impg/wLJWNcxKvYZS3nfuf58hG6-qACP_PPFSfMpK4Q/XMPZmW3A7TM.jpg?size=664x458&quality=96&sign=a715fbbc5cd23ba69f6717febf1f855c&type=album)
</div>

Но такой кэш сразу будет работать медленнее из-за появившегося мультиплексора на выходе, более сложен в реализации, увеличивается сложность вычислений.  
**Тот же пример:**
<div align="center">

![](https://sun9-28.userapi.com/impg/utbVI5AZI46TWtrdwTUfU104SfQDgf-b6uqQ4A/okdcDIbsiQA.jpg?size=1081x286&quality=96&sign=6545316ba3c9d87d79386b551aa1d8e7&type=album)
</div>

Теперь у нас будет два промаха в первом цикле, а уже на следующих, мы без проблем сможем обращаться к обеим ячейкам, таким образом теперь MR = 20%  

### <span id="content4">Полностью ассоциативный кэш</span>
В полностью ассоциативном кэше мы оставляем **только один набор**, то есть любая ячейка из памяти, может попасть в любую секцию, в таком варианте кэша отлично решается проблема вытеснения, но этим самым реализация становится крайне объемной и медленной, поэтому он находит применение в более специфических местах.
<div align="center">

![](https://sun9-31.userapi.com/impg/dAxwAPYVry9a-6gAblWlGFP-ISAtjBHBOniv_w/bToENdiQrBY.jpg?size=1120x125&quality=96&sign=45a4560295b6a0c41865e37524ae1a6b&type=album)
</div>



**Длина строки (блока):**
<div align="center">

![](https://sun9-1.userapi.com/impg/3gTFYpP4m2r1or3xpJvTqDq4J0VqaczGcNyy3Q/tZ4jpNHASEU.jpg?size=733x330&quality=96&sign=bf495f73d1a3c731b1e749df67febcaf&type=album)
</div>

Здесь у нас есть адрес делится на чуть большее количество секций, байтовое смещение (**Bite Offsets**) для байта внутри одного слова, смещение блока (**Block Offsets**) т.е. смещение внутри строки, бит для выбора набора (**Set**) и 27 бит под **Tag**.

**Плюсы**:
Мы сразу получаем порцию данных, если в кэше хранятся инструкции, то при обращении к первой инструкции,У нас автоматически подгружаются остальные 3 инструкции.  
**Минусы**: Пропускная способность канала между процессором и памятью. Промах с длинной строкой будет стоить дороже, чем промах с одним словом.  

**Вернемся к первому примеру:**
```assembly
      addi $t0, $0, 5
loop: beq $t0, $0, done
      lw $t1, 0x4($0)
      lw $t2, 0x24($0)
      addi $t0, $t0, -1
      j loop
done:
```
Благодаря размещению всей строки в памяти, у нас будет только один промах, а все последующие обращения приведут к попаданиям.
<div align="center">

![](https://sun9-76.userapi.com/impg/76tcxO_ODoSrBWQ1FBwZsK2DEpOpBoJw45xI6g/mDha5nxVhns.jpg?size=659x138&quality=96&sign=9d9f6c033f132cec6b9dc24f28a67de0&type=album)
</div>

И теперь мы получим более низкий MR:
<div align="center">

![](https://sun9-26.userapi.com/impg/oqXidjFbzrMAxbKoxMgLWWDPqeFsAdyrug94-w/CX2e7SPmvnE.jpg?size=585x83&quality=96&sign=27cc7121a3da553bfdbfe8d8c224324c&type=album)
</div>

### <span id="content5">Алгоритмы замещения данных</span>
* **LRU** (Least Recently Used) – наиболее давнего использования +  
  *Рассмотрим на примере двухсекционного кэша, где у нас добавляется дополнительный бит (**U** - used) куда помещается номер секции, которая сейчас не использовалась. Т.е. если сейчас мы записываем в секцию 0 то в этот бит попадает 1, и если потребуется какую то из ячеек убрать, то устройство управления этим кэшом, выберет ту ячейку, которая указана в поле U.*

<div align="center">

![](https://sun9-17.userapi.com/impg/U7_NuxzlwJTX5ClTOkOwEB_o6CzXbAbolB-bNA/4ie8dbhHI9U.jpg?size=746x236&quality=96&sign=0ac8fefe1a0a3ec9dee25a1a9a29f772&type=album)
</div>


* **PLRU** (Pseudo-Least Recently Used) – псевдо наиболее давнего использования +/–  
  *Все секции делятся пополам, которые устроены по алгоритму LRU, а внутри конкретная ячейка выбирается случайным образом.*
* **FIFO** (First In First Out) – замещение в порядке очереди  
  *Данные выходят в том же порядке, в котором заходили.*
* **LFU** (Least Frequently Used) – наименее частого использования +  
  *С каждой секцией ассоциирован счетчик, и при каждом обращении к секции, счетчик у конкретной ячейки увеличивается. Замещается ячейка с наименьшим числом счетчика.*
* **RND** (Random Replacement) – замена случайной строки –  
* **CLOCK** – циклический список с указателем +  
  *С каждой ячейкой ассоциирован бит, когда к ячейка обращаются, этот бит устанавливается в 1, а при необходимости замещения алгоритм начинает просматривать, что закреплено за конкретной секцией, если 1, то она меняется на 0 и так далее, пока снова не наткнется 0, тогда замещает эту ячейку.*

Количество промахов на 1000 обращений к памяти:
<div align="center">

![](https://sun9-39.userapi.com/impg/DWxPISIxn6om6JLzosOJB4u2Lq-Vf6_R3g5UDQ/yE5YC-Qt4QA.jpg?size=795x187&quality=96&sign=d2f14e97534c55a5873ca9516db2c952&type=album)
</div>

<span id="content9">**Стратегии чтения и записи в кэш**</span>
- Стратегии чтения
  - Чтение с параллельной выборкой (look-aside)
  - Чтение со сквозным просмотром (look-through)
- Стратегии записи
    - Сквозная запись (write-through) - пишем сразу и в кэш и в память
      - Сквозная запись с отображением
      - Сквозная запись без отображения
    - Буферизированная сквозная запись - пишем сразу и в кэш и в память, но через буфер
    - Отложенная запись (write-back) - пишем только при вытеснении из кэша
      - В среднем на 10% эффективнее сквозной записи. Чаще используется

**Многоуровневый кэш.**  
Для чего нужны уровни кэша? Давайте проверим если ли прирост производительности с помощью AMAT.
<div align="center">

![](https://sun9-80.userapi.com/impg/IpygGMzaLn-5WXsyThh7LOI-FWho3d-wflewww/5DFpootJ-TY.jpg?size=289x277&quality=96&sign=94e29513ac269616edc0a8341b8c8bd5&type=album)
</div>

Допустим:  
t<sub>L1</sub> = 1  
t<sub>L2</sub> = 10  
t<sub>MM</sub> = 100  
MR<sub>L1</sub> = 5%  
MR<sub>L2</sub> = 20%  
*AMAT* = t<sub>L1</sub> + MR<sub>L1</sub> * (t<sub>L2</sub> + MR<sub>L2</sub> * t<sub>MM</sub>) = 1 + 0.05 * (10 + 0.2 * 100) = 2.5 такта  

А теперь уберем кэш второго уровня:  
*AMAT<sub>without L2</sub>* = 1 + 0.05 * (100) = 6 тактов  
Т.е. многоуровневый кэш повышает производительность, но требует больших аппаратных затрат.

Многоуровневый кэш может быть построен по одному из двух принципов:
* Инклюзивный кэш.  
  *В более низких уровнях памяти, содержится копия тех что выше.*
* Эклюзивный кэш.  
  *На более низких уровнях памяти нет копии верхнего уровня.*

### <span id="content6">Основные оптимизации кэш-памяти</span>
* Больший размер блока для уменьшения доли промахов.
* Кэши большего объема для уменьшения доли промахов.
* Увеличение ассоциативности для уменьшения доли промахов.
* Многоуровневые кэши для уменьшения потерь на промахах.
* Предоставление приоритета промахам считывания по отношению к записям для уменьшения потерь на промахи.

### Основные материалы лекции
1. [Ссылка](https://youtu.be/1PWTr6RogZQ?list=PL0def37HEo5KHPjwK7A5bd4RJGg4djPVf) на видеозапись лекции

### Дополнительные материалы к лекции для саморазвития
