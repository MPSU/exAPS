# Лекция 16. Кэш-память.

### Содержание
* [КЭШ-память](#КЭШ-память)
* [Иерархия памяти](#Иерархия-памяти)
* [Пространственная и временная локальность данных](#Пространственная-и-временная-локальность-данных)
* [Характеристики кэш-памяти](#Характеристики-кэш-памяти)
* [Кэш прямого отображения](#Кэш-прямого-отображения)
* [Множественно-ассоциативный кэш](#Множественно-ассоциативный-кэш)
* [Полностью ассоциативный кэш](#Полностью-ассоциативный-кэш)
* [Алгоритмы замещения данных](#Алгоритмы-замещения-данных)
* [Основные оптимизации кэш-памяти](#Основные-оптимизации-кэш-памяти)

### КЭШ-память
С 80-х годов процессоры начали превосходить по производительности память. Этот разрыв в скоростях привёл к потребности в быстром буфере памяти, который мог бы уменьшить задержку при обращении к данным. В 60-70-х годах начались эксперименты и исследования в области быстрых буферов, что привело к созданию **кэш-памяти**.
<div align="center">

![](https://sun9-6.userapi.com/impg/RVIjPr0PmI4OEh3TaOtkyLdFLgQZ7OV9i-66Lg/f0cFnBrFPjM.jpg?size=680x371&quality=96&sign=ee2823c5524e811370c2fe0da89925d0&type=album)
</div>

**Что такое кэш память?**   
**Кэш-память** — это небольшой сегмент высокоскоростной памяти, обычно на базе **SRAM** ([**Static Random-Access Memory**](../15.%20Memory.md), расположенный непосредственно на процессоре или рядом с ним. Её главная функция — временное хранение тех данных, к которым процессор часто обращается. Основная цель такой памяти — уменьшить задержку доступа к данным, служа мостом между процессором и основной оперативной памятью.

**Для чего нужна кэш-память?**  
Основное **предназначение кэш-памяти** — ускорение доступа процессора к часто используемым данным и командам, минимизируя зависимость от более медленной основной памяти. Благодаря этому, время реакции системы сокращается, делая её более отзывчивой и эффективной.

### Иерархия памяти
**Иерархия памяти** - это объединение разных типов памяти с целью получения большой, дешевой, и быстрой памяти. Наивысший уровень иерархии (**Cache**) обычно является наиболее быстрым и наименее емким, в то время как нижний уровень обычно имеет наибольший объем, но и наибольшую задержку (**Secondary (external) Memory**).
<div align="center">

![](https://github.com/MPSU/APS/assets/17159587/1fae137b-8b79-477c-87f2-4562c8330753)
</div>

**SRAM** (Static Random-Access Memory) - тип быстрой полупроводниковой памяти, который сохраняет данные без необходимости периодического обновления. Используется в кэш-памяти процессоров из-за своей высокой скорости.  
**DRAM** (Dynamic Random-Access Memory) - тип полупроводниковой памяти, который требует периодического обновления для сохранения данных.  
**SSD** (Solid-State Drive) - устройство хранения данных, работающее на основе NAND-памяти.  
**HDD** (Hard Disk Drive) - устройство хранения данных, использует магнитные диски для записи и чтения данных, имеет больший объем по сравнению с SSD, но скорость доступа к данным обычно ниже.

Несмотря на то, что кэш-память во много раз быстрее основной памяти, она еще в большее число раз меньше её. Разумеется объем кэша меняется от процессора к процессору, но для определенности возьмем следующий пример: допустим, в процессорной системе кэш 32МБ, а объем оперативной памяти — 32ГБ. Получается, кэш меньше основной памяти в 1024 раза. Как же так получается, что обращаясь в кэш, процессор умудряется получать именно те данные, которые запрашивал? Ведь если вероятность того, что кэш содержит нужные процессору данные составляет 1/1024-ую, то он будет ухудшать производительность системы, а не улучшать ее. Этому способствует такое явление как **локальность данных**.

### Локальность данных

[Локальность данных](https://en.wikipedia.org/wiki/Locality_of_reference) — это набор наблюдений (закономерностей), благодаря которым процессорная система становится чуть более предсказуемой. Эта предсказуемость позволяет использовать кэш эффективно.

Существует несколько видов локальности, но в данный момент необходимо выделить два ключевых:

- **временнáя локальность**: если произошло обращение к данной ячейке памяти, высока вероятность того, что в скором времени обратятся к этой же ячейке памяти;
- **пространственная локальность**: если произошло обращение к данной ячейке памяти, высока вероятность того, что в скором времени обратятся к соседним ячейкам памяти.

![](https://sun9-64.userapi.com/impg/2sjUklJ7HXxf03PVuXJCRjTUJqfbCSfjnvMJTA/CO_Go1YGMCI.jpg?size=530x393&quality=96&sign=22df9fef0fa30274869e6868961213a5&type=album)

Рисунок <номер>. Примеры пространственной и временно́й локальности для разных типов памяти.

**Перед созданием Кэш-памяти нам нужно задаться 4-мя вопросами**:
* Где могут быть размещены данные в кэш-памяти? ([**Размещение строки в разных видах кэшах-памяти**](#Существует-3-вида-кэш-памяти))
* Как найти данные в кэш-памяти? ([**Идентификация строки**](#Идентификация-строки))
* Какие данные нужно заместить, при заполненной кэш-памяти? ([**Алгоритмы замещение строки**](#Алгоритмы-замещения-данных))
* Что происходит при записи в кэш-память? ([**Стратегия записи**](#Стратегии-чтения-и-записи-в-кэш))

### Определения и характеристики кэш-памяти

Далее в тексте будут использоваться следующие термины и характеристики:

#### Блок данных (строка)

Если процессор не находит в кэше данные той ячейки памяти, к которой он обращался, он забирает эти данные из основной памяти, одновременно перемещая их в кэш. Как вы знаете, благодаря **пространственной локальности** высока вероятность того, что вскоре процессор обратится и к соседним ячейкам памяти. Поэтому эффективно будет переместить в кэш данные не только этой ячейки памяти, но и данные ячеек памяти, лежащих рядом с ней, образуя **блок данных**. Таким образом, кэш оперирует данными не на уровне ячеек памяти (**слов**), а на уровне блоков ячеек (**строк**). В простейшем случае, в одной строке находится одно слово, т.е. кэш загружает только ту ячейку памяти, к которой он обращался.

#### Набор

Кэш дробится на подгруппы, которые называются **наборами**. Особенность наборов заключается в том, за каждой ячейкой памяти закреплен свой набор. Иными словами, ячейка памяти может быть загружена не в любое место кэша.

### Характеристики кэш-памяти

* Ёмкость – ***C*** (capacity)
* Число наборов – ***S*** (set)  
_Любая Кэш память обладает числом наборов. Каждая ячейка основной памяти может претендовать только на свой набор._
* Длина строки (блока) – ***b*** (block)  
_Порция перемещения данных между разными уровнями иерархии памяти._
* Количество строк (блоков) – ***B*** = C/b
* Степень ассоциативности – ***N***
_Количество места в кэш-памяти на которое претендует конкретная строка. Каждая ячейка может располагаться только в одном наборе, один набор может состоять из нескольких строк - это и есть степень ассоциативности._
<br><br>
* Кэш ***состоит из S наборов***, каждый из которых содержит одну или несколько строк.
* Взаимосвязь между адресом в памяти и расположением в кэш называется ***отображением***.
* Каждый адрес в памяти отображается в ***один и тот же набор кэша***.  

#### Существует 3 вида кэш-памяти:
* [Кэш прямого отображения](#Кэш-прямого-отображения) – Набор S содержит только одну строку – ***S = B***
* [Множественно-ассоциативный кэш](#Множественно-ассоциативный-кэш) – Каждый набор S состоит из N строк – ***S = B/N***
* [Полностью ассоциативный кэш](#Полностью-ассоциативный-кэш) – Имеет только один набор ***S = 1***

**Анализ производительности**
* Доля попаданий (hit rate - **HR**)
* Доля промахов (miss rate - **MR**)
* MR = <span><sup>Число промахов</sup>&frasl;<sub>Общее число доступов к памяти</sub></span> = 1 - HR
* HR = <span><sup>Число попаданий</sup>&frasl;<sub>Общее число доступов к памяти</sub></span> = 1 - MR
* **AMAT** - average memory access time
* AMAT = t<sub>cache</sub> + MR<sub>cache</sub> * (t<sub>MM</sub> + MR<sub>MM</sub> * t<sub>VM</sub>)  

Пример:

| Уровень памяти     | Время доступа в тактах | Процент промахов |
|:-------------------|:----------------------:|:----------------:|
| Кэш-память         |           1            |       10%        |
| Оперативная память |          100           |        0%        | 

*AMAT* = 1 + 0.1 * (100) = 11  
Какой должен быть MR, чтобы снизить AMAT до 1.5 тактов?  
1 + m * (100) = 1.5 -> m = 0.005%

### Кэш прямого отображения
32-х битный адрес, основная память _memory_, 32-х битный адрес. Для примера у нас будет 8 наборов и длина строки будет одно слово.
<div align="center">

![](https://sun9-77.userapi.com/impg/iyVkc2EdM3-g2Qulzwu6E25YlatYfKfDaOmQTg/He43djKpOx4.jpg?size=875x456&quality=96&sign=770124b0123770466da000649dc1b39f&type=album)
</div> 

#### Идентификация строки
Каждая ячейка памяти претендует только на свой набор и имеет свой уникальный адрес, который делится на несколько частей:
<div align="center">

![](https://sun9-3.userapi.com/impg/AnhKebLSUY5EH5Y1TfNl0wSSS_Skm_AfhGQaeA/H2BBNib77Fc.jpg?size=405x140&quality=96&sign=ffb3aada8e5606398c9ddc41769c8ba2&type=album)
</div>

где  
Первые 2 бита (**Byte Offset**) - смещение  
Следующие три бита (**Set**) указывают, на какой набор претендует ячейка памяти.  
Оставшиеся 10 бит представляют собой **Tag**, с помощью которого определяется, находится ли ячейка в кэш-памяти или нет.

**Пример:**  
```assembly
      addi $t0, $0, 5   # Инициализируем счетчик в регистре $t0 значением 5
loop: beq $t0, $0, done # Загружаем значения из памяти по адресам 0x4, 0xC и 0x8 в регистры $t1, $t2 и $t3 соответственно.  
      lw $t1, 0x4($0)
      lw $t2, 0xC($0)
      lw $t3, 0x8($0)
      addi $t0, $t0, -1 # Уменьшаем счетчик на 1.
      j loop            # Повторяем цикл, пока счетчик в регистре $t0 не достигнет нуля.
done:
```
Давайте разберём, как это работает:  
У нас есть цикл с 5 итерациями, что означает 15 обращений к памяти. При первом проходе по циклу мы сталкиваемся с промахами и записываем их в ячейки памяти. На последующих итерациях цикла у нас уже будут попадания.
<div align="center">

![](https://sun9-28.userapi.com/impg/CRJ-kAjHRxPCSwfjoUefllcML2dM_4T2Gf4kkg/kw7pBs87yEo.jpg?size=528x298&quality=96&sign=b8cba4ff9cc97a951dd144c051798fad&type=album)
</div>

В итоге из 15 обращений к памяти у нас 3 промаха. Теперь можем рассчитать **MR**:    
<div align="center">

![](https://sun9-34.userapi.com/impg/ExAPVEGyQcC96tYDK8MagZA1Z2bTjrI9TZhEvQ/6iGMfTLoRTE.jpg?size=569x83&quality=96&sign=cd0521fe112afef5572953c79dbf200c&type=album)
</div>

**Пример вытеснения (evict):**  
```assembly
      addi $t0, $0, 5   # Инициализируем счетчик в регистре $t0 значением 5
loop: beq $t0, $0, done 
      lw $t1, 0x4($0)   # Загружаем значения из памяти по адресу 0x4 в регистр $t1
      lw $t2, 0x24($0)  # Загружаем значения из памяти по адресу 0x24 в регистр $t2
      addi $t0, $t0, -1 # Уменьшаем счетчик на 1.
      j loop            # Повторяем цикл, пока счетчик в регистре $t0 не достигнет нуля.
done:
```
Загрузка двух ячеек памяти — 4 и 24 — приводит нас к проблеме. Обе эти ячейки ссылаются на один и тот же набор. Из-за этого при каждом обращении к памяти мы будем получать промах.
<div align="center">

![](https://sun9-63.userapi.com/impg/Poo_OX7_m0YidsqjTYHy1kT2aOjX9LER2u1Raw/bEL7HKM4x5s.jpg?size=405x384&quality=96&sign=2084855c0cf9491c3dda44a4ee61a98e&type=album)
</div>

Соответственно **MR** в данном случае будет 100%:
<div align="center">

![](https://sun9-35.userapi.com/impg/bq3OviN2AOHEUyeceLemjqFQUHM2qkEr6emBlg/i6JYF6ya_hM.jpg?size=573x81&quality=96&sign=1042e084357c585b01697626151be912&type=album)
</div>

### Множественно-ассоциативный кэш
Идея множественно-ассоциативного кэша заключается в наличии нескольких строк внутри одного набора. Увеличив ассоциативность, мы теперь имеем двухсекционный кэш (**Way 1** и **Way 0**). Каждая ячейка памяти может претендовать на любую из этих двух секций, и, в таком случае, вытеснения не произойдет.
<div align="center">

![](https://sun9-34.userapi.com/impg/wLJWNcxKvYZS3nfuf58hG6-qACP_PPFSfMpK4Q/XMPZmW3A7TM.jpg?size=664x458&quality=96&sign=a715fbbc5cd23ba69f6717febf1f855c&type=album)
</div>

Но такой кэш сразу будет работать медленнее из-за появившегося мультиплексора на выходе, более сложен в реализации, увеличивается сложность вычислений.  
**Тот же пример:**
<div align="center">

![](https://sun9-28.userapi.com/impg/utbVI5AZI46TWtrdwTUfU104SfQDgf-b6uqQ4A/okdcDIbsiQA.jpg?size=1081x286&quality=96&sign=6545316ba3c9d87d79386b551aa1d8e7&type=album)
</div>

Теперь у нас будет два промаха в первом цикле, а уже на следующих, мы без проблем сможем обращаться к обеим ячейкам, таким образом теперь MR = 20%  

### Полностью ассоциативный кэш
В полностью ассоциативном кэше мы оставляем **только один набор**, то есть любая ячейка из памяти, может попасть в любую секцию, в таком варианте кэша отлично решается проблема вытеснения, но этим самым реализация становится крайне объемной и медленной, поэтому он находит применение в более специфических местах.
<div align="center">

![](https://sun9-31.userapi.com/impg/dAxwAPYVry9a-6gAblWlGFP-ISAtjBHBOniv_w/bToENdiQrBY.jpg?size=1120x125&quality=96&sign=45a4560295b6a0c41865e37524ae1a6b&type=album)
</div>

**Длина строки (блока):**
<div align="center">

![](https://sun9-1.userapi.com/impg/3gTFYpP4m2r1or3xpJvTqDq4J0VqaczGcNyy3Q/tZ4jpNHASEU.jpg?size=733x330&quality=96&sign=bf495f73d1a3c731b1e749df67febcaf&type=album)
</div>

Здесь у нас есть адрес делится на чуть большее количество секций, байтовое смещение (**Bite Offsets**) для байта внутри одного слова, смещение блока (**Block Offsets**) т.е. смещение внутри строки, бит для выбора набора (**Set**) и 27 бит под **Tag**.

**Плюсы**:
При обращении к одной инструкции из кэша автоматически загружаются и следующие три инструкции, что обеспечивает быстрый доступ к большому объему данных.   
**Минусы**: Пропускная способность канала между процессором и памятью. Промах с длинной строкой будет стоить дороже, чем промах с одним словом.  

**Вернемся к первому примеру:**
```assembly
      addi $t0, $0, 5
loop: beq $t0, $0, done
      lw $t1, 0x4($0)
      lw $t2, 0x24($0)
      addi $t0, $t0, -1
      j loop
done:
```
Благодаря размещению всей строки в памяти, у нас будет только один промах, а все последующие обращения приведут к попаданиям.
<div align="center">

![](https://sun9-76.userapi.com/impg/76tcxO_ODoSrBWQ1FBwZsK2DEpOpBoJw45xI6g/mDha5nxVhns.jpg?size=659x138&quality=96&sign=9d9f6c033f132cec6b9dc24f28a67de0&type=album)
</div>

И теперь мы получим более низкий MR:
<div align="center">

![](https://sun9-26.userapi.com/impg/oqXidjFbzrMAxbKoxMgLWWDPqeFsAdyrug94-w/CX2e7SPmvnE.jpg?size=585x83&quality=96&sign=27cc7121a3da553bfdbfe8d8c224324c&type=album)
</div>

### Алгоритмы замещения данных
* **LRU** (Least Recently Used) – наиболее давнего использования +  
  *Рассмотрим на примере двухсекционного кэша, где у нас добавляется дополнительный бит (**U** - used) куда помещается номер секции, которая сейчас не использовалась. Т.е. если сейчас мы записываем в секцию 0 то в этот бит попадает 1, и если потребуется какую то из ячеек убрать, то устройство управления этим кэшем, выберет ту ячейку, которая указана в поле U.*

<div align="center">

![](https://sun9-17.userapi.com/impg/U7_NuxzlwJTX5ClTOkOwEB_o6CzXbAbolB-bNA/4ie8dbhHI9U.jpg?size=746x236&quality=96&sign=0ac8fefe1a0a3ec9dee25a1a9a29f772&type=album)
</div>

* **PLRU** (Pseudo-Least Recently Used) – псевдо наиболее давнего использования +/–  
  *Все секции делятся пополам, которые устроены по алгоритму LRU, а внутри конкретная ячейка выбирается случайным образом.*
* **FIFO** (First In First Out) – замещение в порядке очереди  
  *Данные выходят в том же порядке, в котором заходили.*
* **LFU** (Least Frequently Used) – наименее частого использования +  
  *С каждой секцией ассоциирован счетчик, и при каждом обращении к секции, счетчик у конкретной ячейки увеличивается. Замещается ячейка с наименьшим числом счетчика.*
* **RND** (Random Replacement) – замена случайной строки –  
* **CLOCK** – циклический список с указателем +  
  *С каждой ячейкой ассоциирован бит, когда к ячейка обращаются, этот бит устанавливается в 1, а при необходимости замещения алгоритм начинает просматривать, что закреплено за конкретной секцией, если 1, то она меняется на 0 и так далее, пока снова не наткнется 0, тогда замещает эту ячейку.*

Количество промахов на 1000 обращений к памяти:
<div align="center">

![](https://sun9-39.userapi.com/impg/DWxPISIxn6om6JLzosOJB4u2Lq-Vf6_R3g5UDQ/yE5YC-Qt4QA.jpg?size=795x187&quality=96&sign=d2f14e97534c55a5873ca9516db2c952&type=album)
</div>

#### Стратегии чтения и записи в кэш

- Стратегии чтения
  - Чтение с параллельной выборкой (look-aside)
  - Чтение со сквозным просмотром (look-through)
- Стратегии записи
    - Сквозная запись (write-through) - пишем сразу и в кэш и в память
      - Сквозная запись с отображением
      - Сквозная запись без отображения
    - Буферизированная сквозная запись - пишем сразу и в кэш и в память, но через буфер
    - Отложенная запись (write-back) - пишем только при вытеснении из кэша
      - В среднем на 10% эффективнее сквозной записи. Чаще используется

**Многоуровневый кэш.**  
Для чего нужны уровни кэша? Давайте проверим если ли прирост производительности с помощью AMAT.
<div align="center">

![](https://sun9-80.userapi.com/impg/IpygGMzaLn-5WXsyThh7LOI-FWho3d-wflewww/5DFpootJ-TY.jpg?size=289x277&quality=96&sign=94e29513ac269616edc0a8341b8c8bd5&type=album)
</div>

Допустим:  
t<sub>L1</sub> = 1  
t<sub>L2</sub> = 10  
t<sub>MM</sub> = 100  
MR<sub>L1</sub> = 5%  
MR<sub>L2</sub> = 20%  
*AMAT* = t<sub>L1</sub> + MR<sub>L1</sub> * (t<sub>L2</sub> + MR<sub>L2</sub> * t<sub>MM</sub>) = 1 + 0.05 * (10 + 0.2 * 100) = 2.5 такта  

А теперь уберем кэш второго уровня:  
*AMAT<sub>without L2</sub>* = 1 + 0.05 * (100) = 6 тактов  
Т.е. многоуровневый кэш повышает производительность, но требует больших аппаратных затрат.

Многоуровневый кэш может быть построен по одному из двух принципов:
* Инклюзивный кэш.  
  *В более низких уровнях памяти, содержится копия тех что выше.*
* Эксклюзивный кэш.  
  *На более низких уровнях памяти нет копии верхнего уровня.*

### Основные оптимизации кэш-памяти
* Больший размер блока для уменьшения доли промахов.
* Кэши большего объема для уменьшения доли промахов.
* Увеличение ассоциативности для уменьшения доли промахов.
* Многоуровневые кэши для уменьшения потерь на промахах.
* Предоставление приоритета промахам считывания по отношению к записям для уменьшения потерь на промахи.

### Основные материалы лекции
1. [Ссылка](https://youtu.be/1PWTr6RogZQ?list=PL0def37HEo5KHPjwK7A5bd4RJGg4djPVf) на видеозапись лекции

### Дополнительные материалы к лекции для саморазвития
