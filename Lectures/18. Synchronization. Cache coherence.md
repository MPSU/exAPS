# Лекция 18. Синхронизация. Когерентность кеш. 
## Содержание:
* [Параллелизм уровня потоков](#параллелизм-уровня-потоков)
* [Потоково-безопасное программирование](#потоково-безопасное-программирование)
* [Многоядерность](#многоядерность)
* [Когерентность кэш](#когерентность-кэш)
    * [VI,MSI,MESI](#Протокол-Valid/Invalid (VI))
## Параллелизм уровня потоков
Поток - это минимальная неделимая единица программы, которая может исполняться.
* Разделение вычислений между несколькими исполнительными потоками
    * Несколько независимых последовательных потоков, которые конкурируют за общие ресурсы, такие как память, устройства ввода/вывода
    * Несколько взаимодействующих последовательных потоков, который взаимодействуют друг с другом (в рамках одной задачи может быть несколько потоков, они могут либо конкурировать за общие ресурсы, либо дожидаться друг друга, требовать синхронизации)
* Коммуникационная модель
    * Общая память
        * Единое адресное пространство 
        * Неявная связь с помощью загрузки и сохранения в память
![](https://psv4.userapi.com/c909628/u173937392/docs/d39/785e30ec7aeb/Screenshot_64.png?extra=dLNbDXY-u0HZVRLkx6jSy7-sr5lQP5rzWf-quwpOAsTXaTUfPh2cOHb9uHZT-a3ER5MISbyy78RjYnSpTjpLXCNswQpDcqn6HvgWoQawiTZlk6flpRE5zz1dRaT9VicHBQHnhzLj-Shl_j13N9MmbGDxE5w)
    * Обмен сообщениями
        * Разделенное адресное пространство 
        * Явная связь путем отправки и получения сообщений
    
![](https://sun9-75.userapi.com/impg/39UR2gW5QP8F3h_s-6dzk9vHIetvXpZViANxDg/KC_XlI12Gew.jpg?size=261x267&quality=96&sign=8cdd5e20544a4a1f3f66d1dce913afbd&type=album)
### Синхронизация
* Необходимость в синхронизации возникает каждый раз, когда в системе существуют параллельные процессы
    * Вилки и соединения (join and fork): параллельный процесс может подождать, пока не произойдёт несколько событий
  
![](https://sun9-40.userapi.com/impg/uy645NMF96AETHJWtDPeuzNR4qf8LE2xqMwr3Q/DI9aa87Qvkg.jpg?size=212x292&quality=96&sign=efbb5774bea8e23a6ea77ec7542c156a&type=album)

Например, дальше есть событие, которое будет использовать результаты вычеслений P~1~ и P~2~. Только когда будут выполнены оба процесса может происходить дальнейшее выполнение, а значит есть необходимость их синхронизировать
    * Проиводитель-потребитель(producer-consumer): потребительский процесс должен ждать, пока процесс производителя не произведет данные (то есть потребитель не может быть запущен раньше, чем производитель произведёт какие-то данные)
![](https://sun9-29.userapi.com/impg/-SkW6buDPqkr6b8zYVAWUBsuSEnar2EkeT-EfA/s_W8OTPo0HQ.jpg?size=213x243&quality=96&sign=1539704081629c0f556f2a53a45f92bc&type=album)
    * Взаимное исключение: операционная система должна гарантировать, что ресурс используется только одним процессом в данный момент времени (например, не могут два процесса одновременно обращаться к  одной ячейке памяти)
## Потоково-безопасное программирование 
* Многопоточные программы могут выполняться на одном процессоре с помощью **таймшеринга**(технология, обеспечивающая разделение ресурсов одного большого компьютера между несколькими пользователями, выделяя каждому из них определенное время доступа к ресурсам)
    * Каждый поток выполняется некоторое время (прерывание по таймеру), а затем ОС переключается на другой поток, неоднократно
* **Потоково-безопасные** многопоточные программы ведут ведут себя одинаково независимо от того, выполняются ли они на нескольких процессорах или на одном процессоре 
    * Мы будем предполагать, что каждый поток имеет свой собственный процессор для запуска
### Синхронная связь
**Приоритет очерёдности** a⩽b,a предшествует b
* Потребитель не может использовать данные до их получения( событие send~i~ должно происходить раньше или в тот же момент времени, когда происходит rcv~i~(полуение) этих данных)
![](https://psv4.userapi.com/c909418/u173937392/docs/d40/92a2df943197/Screenshot_24.png?extra=_CtDhlt1Dz7gfOi1h_YLs9vwZUaQd-JTQNUV3IpA7s3o13D5nx8KjPSe63tjYBsAdgk8cojkrOT14Dm4Qh3foghx48IeJAfBT_cRHktX8YgUumUGsBBGhB5xovGZ51Aqcsu57RV0hP_dv8bAQ44AG5GZfQ)
* Производитель не может перезаписать данные до их использования потребителем(получение данных должно происходить раньше, чем их перезапишет следующая i+1 поссылка)
![](https://psv4.userapi.com/c237231/u173937392/docs/d48/a59a2978f692/Screenshot_25.png?extra=Lf-Al67JN7ZgVe3ODoD7lebSbC-UdLt3mVCxFuXti89ZzJ5-KAB8ui0PR8YCtA4GBbXrpLSaoUqV_bLWAlt8Xt6icMuT8XMNyTHrrteU2A1khUjwaVOMEFBNh76obtas911CSpsAKx-rMgSijOOdQKTz9g)
![](https://psv4.userapi.com/c909628/u173937392/docs/d22/d89b85403689/Screenshot_23.png?extra=F9NFE4Nr9iba1fYeLxfwLjt9ElRsBlZF_y_5NPJloY4gCYFV4RgpTgDlHWkDXX_fxRXroS3QgBHcGTgmX3OhKOT8PYm92vB54Mgfaosk7L3Wnp2yeuM2r08fjR1YryNEZeAC9iCxAfGFvHuvWlJTnZf8FQ)
Метка loop указывает на последовательность инструкций <xxx~1~>, которые генерируют данные с. После этого производитель оправляет эти данные для потребителя и потом возвращается к началу циклу и так далее. В свою очередь потребитель получает данные (receive) от производителя, выполняет над ними нужные операции и снова возвращается к началу цикла
### Буфер Fifo(First input, first output) 
![](https://psv4.userapi.com/c240331/u173937392/docs/d28/4a06d2b40265/Screenshot_26.png?extra=5p3j4mB0udmpIJtsvFqogZtOc1Q-u3kFNPVON42rtYerN1XUe8fRpBUCoCR0iBW2ClbROmvMNTDCQsIktuuCjPHZf8-tgWa8IiRcs_fDm90CiaAIyXTzAVmmSX2j7Ivc6uH7YNToYX8trVa5KISsAJvA7U4)
* Буфер Fifo ослабляет ограничения, связанные с синхронизацией. Производитель может опередить потребителя на N значений(где N - глубина данного буфера)
rcv~i~ ≤ send~i+1~
Обычно реализуется как кольцевой буфер в общей памяти:
![](https://psv4.userapi.com/c240331/u173937392/docs/d49/9888129cffde/Screenshot_28.png?extra=aeEWtzcQE4IZr2iPwBOlqYt-naqdwLdiOmG2NBKU49VlYLgEHuOb2s_e_Fliz8hEr2gA-bu2pkAhSrDt6j3DlJS1UlUyiaUgFtZL6gKyhAYBOq-z8kUFBsB5tdkHyLst1JAw_mBBk-YStUKJ7Q56Yip5O9I)
У нас есть буфер на 3 элемента(то есть наша очередь), есть два указателя, один указывает на запись(write ptr), а другой указывает откуда мы её считываем(ride ptr).Допустим происходит генерация новых данных(send c~0~), они записываются по нашему указателю, после этого указатель сдвигается на одну ячейку вправо(i+1), затем происходит то же самое и по итогу указатель сдвинулся по кругу. Далее забираем наши данные (происходит rcv()), теперь указатель ride ptr смещается вправо и так далее.

Пример буфера, который **работает неправильно**:
![](https://psv4.userapi.com/c909628/u173937392/docs/d5/b885d6c688a3/Screenshot_29.png?extra=ReSoiAelvyJeNdfJLq9OTwy5eSCe7bGqzFJ4qHBaXHztvRjjMkmMtmfWW_oO1t42HFsBuWAKdLUneWyJXogm3pbuXZay0BIPfSiwd3bOMyLnD0ehHeJOhiifg4Tx36VaaEc30tZvw5qiZgUP9Mzo1EyKg9E)
Данный буфер **не применяет никаких ограничений приоритета**(_например, rcv() может быть вызван до любой отправки_), поэтому и работает неправильно. Чтобы устранить эту проблему, нам поможет концепция _семафоров_.
### Семафоры
* Семафоры - это програмная конструкция для синхронизации
    * Новый тип данных: semaphore, число ≥ 0
    * semaphore s = К; // инициализируем s значением К
* Новые операции (определены для симофоров)
    * wait(semaphore s) - ждёт если s == 0, после чего s = s - 1
    * signal(semaphore s) - s = s + 1 (один ожидающий поток теперь может быть в состоянии продолжить)
* Семантические гарантии: семафор s инициализированный как К, применяет ограничение приоритета
    * signal(s)~i~ < wait(s)~i+K~
i-ый вызов signal(s) должен завершиться до завершения (i+K) вызова wait(s)
### Семафоры для приоритета
Нам нужно, чтобы оператор А~2~ в потоке А был завершён до того. как начнётся оператор B~4~ в потоке B
А~2~ < B~4~
![](https://psv4.userapi.com/c236331/u173937392/docs/d13/58f64a09d917/Screenshot_35.png?extra=-G6uk4eGyRgwQ5BwlUO_ZJZPEd2hP6lz02cRT1pQjpnhU_G8Yyhu-bWdxixJwNFacGJp9nInHEikYcBvkv9rmD1dNl_Bbp_KznHswGokK3rxIFFlw1Y7UXBRSdW9OvZlg6lwcTeugJIL6xLZ2xhKxD_9)
Решение:
* Объявить semaphore = 0
* signal(s) в начале стрелки (после A~2~)
* wait(s) в конце стрелки
![](https://psv4.userapi.com/c909628/u173937392/docs/d54/52b21a1f1915/Screenshot_36.png?extra=MEYNspBa7llWXFErNQe6Qi_sRUnP_oT_PfurQ5xvMfO4Zz_yJOQ0-A9h_4jBattbh2UAiCKLKmUlnqx9Uk50hrIgAvH9kq7O3mrK--hHyqx5Ne8hEAqpih13tU7FlE7yCDfzDGrLYXn6_iEJmU1IFF5q)
Если мы в потоке B придём раньше до B~4~, то s по умолчанию = 0 и мы застрянем на инструкции wait(s). В это время первый поток А доходит до signal(s), то есть увеличивает s на 1, соответсвенно внутри wait s тоже увеличилось на 1. Мы прошли этот wait и семафор снова стал нулём.Таким образом, мы получили синхронизацию, которую хотели.
### Семафоры для распределния ресурсов
Описание проблемы:
* Существует К ресурсов
* Существует множество потоков, каждый из которых нуждается в ресурсах в случайные моменты времени
* Необходимо гарантировать, что в любой момент времени используется не более К ресурсов

 Решение с использованием семафоров: 
* В основной памяти : semaphore s = K;//K ресурсов
* Используемые ресурсы
wait(s);//выделение ресурса
...//использование его некоторое время
signal(s);//возвращение ресурса

То есть если количество wait произойдет столько же раз сколько и К, то мы обнулим этот ресурс и очередной wait не даст нам повторно использовать этот ресурс.
### Буфер Fifo с семафорами
![](https://psv4.userapi.com/c909628/u173937392/docs/d20/705eab4a348a/Screenshot_37.png?extra=XZBFiFGrE_u3yTDYN-MR73-XhMz8oPviGXXAFY_2aBkmHmZ9HqmeZ1t2TFGBvmzDQMRJLezTb_kPAOGqMWOPqwGrYg9e1JXXNjS48iABRz6E4eVh5BGr3vmv4ESUKMJBlGFWMlHyhz9lncfzU2hhk14-)
* Выполняется приоритет, управляемый семафором send~i~ ≤ rev~i~
* Здесь есть один ресурс, управляемый семафором: количество символов в буфере
* Всё ещё некорректная ситуация, так как производитель может переполнить буфер
* Должны применять требование rcv~i~ ≤ send~i+1~
![](https://psv4.userapi.com/c237231/u173937392/docs/d47/239e66c95f1d/Screenshot_38.png?extra=fVK2S4nDpySZ5aZ7Fm7-gfWOzcOmVRmQ6BLlnrBpL9BN2gXYc2a1PpDmKQwn_M8bspBePDGBxWplyoODzsxTzuvUAcWaHVxOvKrbQkZGtIidhT5IBCNDmpYIAd1muizQT1dxjCINmvI2tHC9pYS_84ul)
* Ресурсы, управляемые семаформами: символы в FIFO, СВОБОДНОЕ МЕСТВО В FIFO
* Работает с одним производителем и потребителем
### Одновременные транзакции
Предположим, что вы и ваш друг посещаете банкомат в одно и то же время и снимаете 100 рублей со своего счёта. Что происходит?
![](https://psv4.userapi.com/c909628/u173937392/docs/d4/f0d49720472f/Screenshot_39.png?extra=ThdirUDE__RsutYYS8ZHtyQcFJulAUkzFqXysvmuGN1qd1udPxvAz4S_E3b5Ji9s94FKaNBDTyjahPgp70TNQ5fwpBKe183OjLK2kRzJ47Iemg_VGNDxLEV9TsNuaoaT3nGWIosbG43vOSt-dsAgh_8Y)
Результат: у вас есть 200 рублей и баланс счёта уменьшился на 200 рублей.

Представим, что когда первый поток начал выполняться, второй поток начал делать то же самое, то есть они немного перекрылись.Значит, когда потоки будут уменьшать баланс, они будут уменьшать одно и то же значение.
![](https://psv4.userapi.com/c909518/u173937392/docs/d4/098a4aa1be96/Screenshot_41.png?extra=RxJvsPtoywZCw6103KABqDfY9QqU28vCm8pqLVtSc18fcPm1pySDw9H39UXXVMOeQ9aRfi0qQSOVEAbOX0ZTRJQlJmBVvCaKQMIBJHYc4kuWLVvZtPmzoCY6XqocBYTcHB6wZToVGdfvB2t9MpXOyBuT)
Результат: у вас есть 200 рублей, а баланс счёта уменьшился на 100 рублей.

Необходимо быть осторожным при написании параллельных программ. В частности, при изменении общих данных.
Для некоторых сегментов кода, называемых критическими секциями (**critical sections**) мы хотели бы убедиться, что никакие два выполнения не перекрываются.
Это ограничение называется взаимным исключением(**mutual exclusion**).

**Решение**: внедрить в критические секции обёртки, которые гарантируют **атомарность**, то есть делают их похожими но отдельные мгновенные операции.
### Семафоры для взаимных исключений
![](https://psv4.userapi.com/c909618/u173937392/docs/d28/7941711f0e74/Screenshot_42.png?extra=9BUbSbJBk9HhdwxPbuQ6lVnfuRAV7zgLnzgwrR_F7cPszTqifQiWOpWx60h_35D0jPRwWVMHPt-p3FuSCJ-gMnTffnz_KEn4wwDxiuGdWVLhOvlmiawstdPTdU09iyVjvtLrRf7BHYFiC7HTlEqGClRn)
Нам нужно гарантировать, что двойной вызов функции debit не пересекается. То есть либо a предшествует b, либо b предшествует a (они не пересекаются!)
Для этого:
* Берём семафор semaphore lock, инициализируем его единицей
* Вначале функции ставим wait(lock), то есть вначале мы его блокируем
* Вконце ставим signal(lock), снимаем блокировку
![](https://psv4.userapi.com/c909228/u173937392/docs/d43/a52fe0f44784/Screenshot_43.png?extra=dsoZLbeuK3orrw9o3ffnWCux5ECGqQUEihxWVQyhoyAXT0RVGv0wCt3puOwmv352A9NSYwcBGJ_js9apJt-Jb6FagNIpTJKfP9HM7VLCRx3rod_PyeWIwisBcRCFhCpSYyEbT9-ZUcXAhyf-E2YlOm8P)
### Проблемы атомарности
Рассмотрим несколько потоков производителей: 
Два потока могут генерировать данные для нашего consumer и может возникнуть ситуация, когда сначала один поток поместил в общий буфер char, но ещё не успел обновить указатель, и в этот момент времени второй поток загружает свой сивмол в буфер просто перезаписав значение, то есть производители мешают друг другу, а этого не должно быть.
![](https://psv4.userapi.com/c237031/u173937392/docs/d7/72ddcce76d3e/Screenshot_44.png?extra=9AJ6nhDxMIOqeFWxdTdlqYoCWj3w2jlozHn5uVOAIiFbX8Nc09EIsJYRSxAACkRD15aQeH5QMKaXaRmbMkxSZhOgksf8SLkSO8S96xN6frLn6NagmckM9xdXlvNe_Dq5MGnO7ljJkEd8EVwUNEwJ5dB3DgE) 
Справиться с этим помогут наши блокировки: 
![](https://psv4.userapi.com/c909618/u173937392/docs/d54/ae123636d42a/Screenshot_45.png?extra=Zrd2gaADXOzENyahKvBSRvNN4oTFtYv4kIomgHdswr8pNTWRoJQjtzW3oQkttw6JQh0UjskOXWc9cfyvDUIIXLACYNoMm9qk6UzL474RhQzrHBPP9w4Svz9tyqyH8cg8kX9fJ4I1cDO4ZI4ErCipSdHyrTY)
### Мощность семафора
Семафор - это единый примитив синхронизации, обеспечивающий :
* Отношение приоритета
    * send~i~ ≤ rcv~i~ (событие send~i~ должно происходить раньше или в тот же момент времени, когда происходит rcv~i~(полуение) этих данных)
    * rcv~i~ ≤ send~i+1~ (получение данных должно происходить раньше, чем их перезапишет следующая i+1 поссылка)
* Отношение взаимного исключения
   * Защита переменных in и out
 
Пример с синхронизированными потоками(даже в том случае если один будет сильно убегать вперёд или наоборот):
![](https://psv4.userapi.com/c909418/u173937392/docs/d52/a0663cd3f4b9/Screenshot_46.png?extra=A4hgArx9M7Dr-mTJHl5ds7U9cFjYQkQrGWmeF7JVxw932z5xFkHVVpaQCMOTEzpj-P590gvMXEKYzFCqQyHwFwOX8z0p6RC0X8YTtzaB6IzbS3UrqVuVXL93E4UazBSX8WlrRWx0RxGTQo3aSL3ltAMM9wE)
### Реализация семафоров
Семафоры сами по себе являются общими данными, и для реализации операций wait и signal требуются последовательности чтения /изменения /записи, которые должны выполняться как критические секции (то есть фактически семафор это такое же число в  памяти, его нужно сначала загрузить, потом выполнить нужное действие и затем загрузить обратно в память).
Для взаимного исключения в этих конкретных критических секциях без использования семафоров можно:
* Использовать специальную инструкцию (например, "test and set"), которая выполняет атомарное чтение-изменение-запись. Зависит от атомарности выполнения одной команды. Это самый распространённый подход
* Реализуется с помощью системных вызовов. Работает только в однопроцессорных системах, где ядро бесперебойно
### Синхронизация : обратная сторона
Использование ограничений синхронизации может привести к возникновению собственного набора проблем, особенно когда потоку требуется доступ к нескольким защищенным ресурсам
Представим ситуцию, когда два человека пересылают друг другу одновременно N-ую сумму денег:
![](https://psv4.userapi.com/c909218/u173937392/docs/d14/17891096e486/Screenshot_48.png?extra=_ZJOX07RwwjV64nTpwbSqQ0iDH8MJXTlOKv5qov-00a6yqxKwR6GJEADBB52JN1rcuXhtZUnYB3JWXVGGesuSMil6jP3QO9mjX9UdpVM7z_vND-WUW0usJNm81gjGsIPA4J_XM-y_prpEYMUAlY00nnktEQ)

![](https://psv4.userapi.com/c909218/u173937392/docs/d49/b081ce69dff4/Screenshot_47.png?extra=9SWn3Qv3kh75ISCowiuFAotrQAD9HCGK_nN6suO1hD9gbt5OAJJVdfsIu97iCJ_AOGC2Kvz8yPdzlTiJZ5MxC6-bGA6DHl0HTHv2iIh7AhF9dBFekfXuB_EfmKE5Dogc6IqcTXGQlyqybly2nCx3Kzd9uls)
Что же может пойти не так?
Thread 1: wait (lock [0903]);(поток 1 блокирует 0903)
Thread 2: wait (lock [1103]);(поток 2 параллельно блокирует 1103)
Thread 1: wait (lock [1103]); //не завершиться, пока не произойдёт signal 2 потока(заблокирован, потому что предыдущий поток его уже заблокировал, кончился ресур)
Thread 1: wait (lock [0903]); //не завершиться, пока не произойдёт signal 1 потока
Ни один поток не может добиться прогресса - это называется **Тупик** или **Deadlock**
**Deadlock** — ситуация, при которой несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать свое выполнение.
### Обедающие философы
![](https://psv4.userapi.com/c237031/u173937392/docs/d18/4c838fa1c9da/Screenshot_49.png?extra=GMgfxEiYeUoZqOj7qiP9MDDwgux-DeYB-RWWximietul4EnFVuIsn8TNhtqv4nFh7UHZ7rdPGYY_ebuZbUoSkY62evHVsVOyUZc_p0XGlnpBebmWP1JgMv0qefaXBu4_oP0WjoxNF0txVf5KvBfvnPnyBqY)
Философы мыслят глубокими мыслями, но имеют простые мирские потребности. Когда вы голодны, группа из N философов будет сидеть вокруг стола с N палочками для еды, разбросанными между ними. Еда подаётся, и каждый философ наслаждается неторопливой едой, используя палочки для еды с обеих сторон.
Они очень вежливы и терпеливы, и каждый соблюдает обеденный протокол.
Алгоритмы философа:
* Взять (дождаться) ЛЕВУЮ палочку
* Взять (дождаться) ПРАВУЮ палочку
* Кушать, пока не насытится
* Заменить обе палочки

Никто не может добиться прогресса, потому что все они длут недоступного ресурса.
Условия :
1) Взаимное исключение: только один поток может содержать ресурс в данный момент времени
2) Удержание и ожидание: поток удерживает выделенные ресурсы, ожидая других
3) Отсутсвие вытеснения: ресурс не может быть удалён из потока, удерживающего его
4) Происходит круговое ожидание
### **Решение**
Назначить уникальный номер каждой палочке для еды. Запрашивать ресурсы в последовательном порядке (алгоритм Дейкстры)
Новый алгоритм:
* Взять палочку с МЕНЬШИМ номером
* Взять палочку с БОЛЬШИМ номером
* ЕСТЬ
* Заменить ОБЕ палочки
![](https://psv4.userapi.com/c237131/u173937392/docs/d7/5bf82346e14b/Screenshot_50.png?extra=y4YmR0cRDr0HR_Y4qIkn9rfGHT9ggsrOlYIY9cveZPt3TmJ_rNo3JR-SiADdmdxxq6rlqeCKPPa9CAU4u9roG35rOVO0EBWyl5hdunuRgcAzFQeKi1sixSESxE_e8ERsd-nH6FZVs2vNauT4g92nZKFNaJA)

Доказательство: Deadlock означает, что каждый философ ждёт ресурса, которым владеет какой-то другой философ. Но философ, держащий самую большую палочку для еды не может ждать какого-либо другого философа.
### Исправленный метод передачи на основе вышенаписанного алгоритма с избежанием тупика:
![](https://psv4.userapi.com/c237031/u173937392/docs/d10/5d8da66fe1a9/Screenshot_51.png?extra=KeeLxFm8AfGlz85cRpyOMSW328uI8Ve2ZYpicq-PlfN65TjqnOCUVYyc2TjGP1ScKHq0L9h4GLcwPexpulOqFeIbhhOBSPMsvTfgWPOuWuBAcwPVs1Gr_rpwFqP7rTjR9UpKSP_dgcP_gackE91x4OyaJjM)
## Мультиядерность
![](https://psv4.userapi.com/c236331/u173937392/docs/d8/a714f4b19134/Screenshot_52.png?extra=uJV9AWeP03SKmsgwJ4ScaBqsuWnB-LzzbQVc_GW4tDdJRkgUPTondDwh0sKa0pIvu9GPLBESRPtJfuK-ohFGfN6MJQ6ll4xuNbgMcOd8TLlGT9pmlNmU9Mib-7e8wKssUfvvaZ8D4dV43DKw5qFZyUYzdr4)
* Современные процессоры обычно имеют от 2 до 8 ядер, где каждое ядро имеет собственный кэш для повышения производительности
* Ядро могут использоваться совместно для ускорения работы приложения
* Ядра могут взаимодействовать друг с другом через память
## Когерентность кэш
Необходимо создать иллюзию единой общей памяти, даже если многоядерные системы имеют несколько приватных(собственных) кэшей (если они обновляют информацию, то эта информация должна быть доступна всем кэшам, которые её используют)
Проблема: 
![](https://psv4.userapi.com/c237331/u173937392/docs/d28/20056d26ee41/Screenshot_53.png?extra=10EC_KOA1oFQ4n6SDZNk0iJ7iWlL21f7gxizFCRu7C1O_tatRudaknya87hKw_h_iU5vNhmn7CnGd8IGUmoJJSB2jU-r6prB08Y8mhrcKqns3qcX_dGFQyJEoWdcTgb5JNdWUeHgdMCtKp6YlzEHDY-1NKo)
1) Ядро 0 загружает данные из памяти по адресу А число два
2) Ядро 2 выгружает в память по адресу А число три
3) Нулевое ядро после этого опять загружает данные по этому же адресу, но в кэше лежат старые данные
То есть процессор получит данные из кэша, но эти данные не соотвтветствуют действительности, так как другое ядро обновило эти данные.
Решение: протокол когерентности кэша контролирует содержимое кэша, чтобы избежать устаревших строк
Например, сделать копию А ядра 0 недействительной, прежде чем позволить ядру 2 писать в него
### Поддержание когерентности
* В когерентной памяти все загрузки и сохранения размещаются в глобальном порядке
    * Несколько копий адреса в различных кэшах могут привести к нарушению этого свойства
* Это свойство может быть обеспечно, если:
    * Только один кэш одновременно имеет разрешение на запись
    * Никакой кэш не может иметь устаревшую копию данных после того, как была выполнена запись по адресу
### Реализация когерентности
* Протоколы когернтности должны обеспечивать соблюдение двух правил:
    * Распространяющаяся запись (Write propagation): записи в конечном итоге становятся видимыми для всех процессоров (если кто-то из процессоров пишет куда-то, то нужно однозначно остальным об этом сообщить)
    * Сериализация записи (Write serialization): записи в одно и то же место сериализуются (все процессоры видят их в том же пордке)
* Как обеспечить распространение записи:
    * Write-invalidate protocols: аннулировать все другие кэшированные копии перед выполнением записи
    * Write-update protocols: обновить все другие кэшированные копии после выполнения записи
* Как обеспечить сериализацию записи:
    * Snooping-based protocls: все кэши наблюдают за действиями друг друга через общую шину
    * Directory-based protocls: каталог когерентности отслеживает содержимое частных кэшей и сериализует запросы
### Snooping-Based Coherence
Кэширует слежение за шиной (отслеживание), чтобы все процессоры могли видеть память согласованной
![](https://psv4.userapi.com/c909418/u173937392/docs/d21/123eda8df8e9/Screenshot_54.png?extra=waPljVEJN20u175_yQCRZgeUVZMn6Tlgor0xdFSVyPQqH70GTCwT9aISxj2v1MibMp13CNnBAK0Xx2S4Xlw6dB1Ce_SCo-emKqv7NJlM-8z9dksM1zjS8QnH_l56OqPkSyZsq6SSRPW9tsK5heHKZjcq)
То есть каждый раз, когда процессор обращается к кэш памяти, он выставляет информацию на общую шину. И все кэши видят когда кто-то на эту шину выставляет информацию.
* Шина обеспечивает задачу сериализации
    * Широковещательный сигнал, полностью упорядоченный
    * Каждый кэш-контроллер "шпионит" за  всеми транзакциями на шине
    * Контроллёр обновляет состояние кэша в ответ на запросы процессора и snoop-события и генерирует транзакции на шине

Snoopy кэш отличается от обычного кэша наличием дополнительного поля State (состояние) и контроллером, который следит за шиной и содержимым состояния каждой записи
В ячейку State может быть записан один дополнительный бит (0 или 1). Этот бит указывает, на валидность или не валидность записи исходя из когерентности данных в кэше
![](https://psv4.userapi.com/c909228/u173937392/docs/d38/7a1f37033b6b/Screenshot_55.png?extra=5uB6CY00lhNxED7xTFZEaskZvJcv1cw-OY3PnLeBV4gGj-q66NZ5SdXmfQC1DFKk0LzRLmohA8-dZsOccGX-_dlD1NaVn9JSZY5L42sTM6oQUuPK5f3iU_aTRT7jKUBPChkQh9qdwsVivUwYTOd47iwt)
* Snoopyпротокол (FSM) - это конечный автомат, который зависит от того что происходит на шине и обновляет значения состояния
    * Диаграмма состояний переходов
    * Действия
### Протокол Valid/Invalid (**VI**)
Поддерживается только кэшем со сквозной записью (нужно чтобы все видели что происходит на шине)
![](https://psv4.userapi.com/c235031/u173937392/docs/d18/c38b88f1f84e/Screenshot_56.png?extra=U3lXMqbZiVm3zV9jFL2UxMAlp5JVw7UXjYmhKmi3hPcZIc4CTR-Xgc34jr3yRm2FIO4mOmVGp-nOm8z7eK7yVYi5hTWM_8YT4-OdqbpJpm7JyAqLfakCgKiFXWMJvY9MeP1j6VQ8ozLk_HXob1-SCIcn)
Когда мы находимся в состоянии Invalid, и какое-то ядро запрашивает данные, то происходит Processor Read (PrRd). Затем он получает данные в свой кэш и выставляет эти данные как Valid.
В какой-то момент это ядро видит, что какое-то ядро записало по этому адресу (то есть на шине произошла запись Bus Write), тогда оно сразу меняет состояние этой ячейки на Invalid, потому что в этот момент времени у него неактуальные данные.
![](https://psv4.userapi.com/c909228/u173937392/docs/d39/3889ea42167b/Screenshot_57.png?extra=MwNcrlEcGFHbegbc60xYjySpsN21yTapvmduAWHAmaXlQ_DPjZ_o5auRWlphowkKToF-7_583Y9Uzuy7UYCqhHxCPWDyqTOtPM41CMzkzfQobpwHW4WO0fkGkTINcqS373yEhpUoO-iYI--XfVFdQcu-)
Таким образом, если мы читаем данные, то мы переходим в  состояние Valid.Если мы видим, что какое-то ядро записывает по этому адресу, то переходим в состояние Invalid
Пример:
![](https://psv4.userapi.com/c909518/u173937392/docs/d53/937ece3f2a9c/Screenshot_58.png?extra=TWQpQ7bi9dJkGXs13f7epEeGn5d6DNtEsUUxXApo6OBjBj827pB_STjZhYzSKPlp2U9rVHtO7G4z1yRCvkz_L-UquKxnY6ztCo7XbBk4hjCD6Z0MAOgBg6bnhkAqrmAZp9pSdC-i0uH9-cli45FMHvVX)
1) Допустим, ядро 0 сначала загружаю по адресу А. На шине запрашивается чтение, в кэш попадает запись с состоянием Valid.
2) Затем загружается второе ядро по адресу А, теперь там тоже запись Valid.
3) Теперь происходит запись числа в память, кэш видит это и делает Invalidate данных (обнуляет их)
4) Коргда произойдёт очередной load, он увидит, что мы находимся в состоянии Invalidate
5) Теперь просто  зачитаем обновленные данные
![](https://psv4.userapi.com/c909328/u173937392/docs/d48/e80defd5df63/Screenshot_59.png?extra=3GmPgTWJi-5hdPeRtVIas2Xkmkxeh02UymY2Nw2Q8OKgfDkLTtOY7QeutUdXDOcrIpss-K0Jg-AyL2aNorZhpgCG77rgZ6m-kvnIF6zd1Dkf3YFCWAymRnKev5tLVF4KlZb583K5Y1p1LpdppNla5VDX)
Проблемы VI:
* Каждая запись обновляет основную память
* Каждая запись требует широковещательной передачи и слежки
### Modified/Shared/Invalid (MSI) протокол
* Каждая строка в каждом кэше поддерживает MSI состояния:
    * I-кэш не содержит адреса
    * S-кэш содержит адрес, но он так же может находится в других кэшах, следовательно он может быть только прочитан
    * M-кэш содержит этот адрес, следовательно он может быть и прочитан и записан - любой другой кэш имевший этот адрес будет признан недействительным (то есть как только запишется по этому адресу все остальные аннулируют информацию об этом)
### MSI протокол FSM
Если процессор считывает данные (PrRd), то тогда на шине появляется значение, что мы читавем данные (BusRd) и мы переходим в состояние S.
Если мы увидим, что где-то происходит эксклюзивное чтение данных для записи этих данных (BusRdX), то мы перейдём в состояние Invalidate (потому что данные больше не актуальны)
Если же мы находимся в состоянии Invalidate и процессор хочет осуществить запись в какую-либо ячейку памяти, то шина об этом конечно узнает, потому что мы запрашиваем эксклюзивное пользование данными (BusRdX), и мы перейдём в состояние M. Дальше происходит чтение и запись данных. Если мы находимся в состоянии M и кто-то прочитает данные, то мы автоматически перейдём в состояние чтения (S).
![](https://psv4.userapi.com/c237031/u173937392/docs/d2/024fbe6473b1/Screenshot_60.png?extra=qTQLQMIUDJHOBqJsM-McAG1WSOJVINIZTbOccagWrwC7IumT-yn1UOcc8uf2bDGKmGmIT2fJhA9gTuWH0FdaEquSJJfZek8axZnMxDUiKP0RQmtpCvB_TdMxBIjeAbcKGEykSl6XTp863YodrHUxHqG4)
![](https://psv4.userapi.com/c237331/u173937392/docs/d11/5c15b0a2e1ce/Screenshot_61.png?extra=ct0GkKsKP8uZsL4ZtCJakroqYdc3E9Pxifcq2q4wSMLtDXX7MP9ML460bANB46xT82O8JD-0kNldX0BWuGBnMrlKSeVFxkvtko_ADSsWfns9dS3fqeerj7-7ztmC7-gKwLWuIBGFlO2ykjEacoiR3iuJ)
* Недостатки VI: каждая запись обновляет основную память, и каждая запись требует широковещательной передачи и слежки
* MSI: возможность реализации кэша с обратной записью (writeback) + удовлетворяет локальную запись
### Оптимизация MSI: состояние E
* Наблюдение: выполнение последовательной чтения-измения-записи на частных данных является обычным делом
    * В чём проблема MSI?
        * Две данные транзакции для каждого чтения-изменения-записи частных данных
* Решение: Е-состояние (Exclusive)
    * Если данные ни с кем не разделяются, то чтение переводит строку в состояние E вместо состояния S
    * Запись не вещается на шину, потому что E→M (exclusive)
### MESI: усовершенствованный
* Каждая строка в кэше содержит тег и биты состояния
    * M: Modified Exclusive
    * E: Exclusive, unmodified
    * S: Shared
    * I: Invalid
![](https://psv4.userapi.com/c909228/u173937392/docs/d17/a3c0d2a1dc19/Screenshot_62.png?extra=qfI9N7sQIea-yiEePrhOVX0DoINYVZ6oMDWLba4DQi7fSG_9IfSea2jlIEMGvZ6MotBQycncNbHDT9GUTSIKYPSseHbLBqb6JaNxo6Z14F_sjsixANxarXcRuCpTY6khirDNyP82ooV4_BGHmQjM5J0)
### Когерентность кэш и ложное совместное использование
* Строка кэша содержит более одного слова, и согласованность кэша выполняется на уровне детализации строки
![](https://psv4.userapi.com/c909618/u173937392/docs/d48/b49066d64298/Screenshot_63.png?extra=13gSLXJryWg-9jHgsvnfTjcgtu6Zso3QLvYml6DzV7dS1XIDEKhmG2O9lxGHU8_z0utnlhLAzTL5YQh-bWIQbzfYI85H4GJk2e_-7Pg18WUZ-8Pl8MYAKgSMmdtqidbn8mYoNED8k_0tCnQMKTwjuglK)
* Предоположим P~1~ записывает word~i~ и P~2~ записывает word~k~ и оба слова имеют один и тот же адрес строки
* Из-за того что присутствуют алгоритмы когерентности, будет происходить _пинг-понг_
    * Строка может быть недействительной много раз без необходимости, потому что адреса находятся в одной строке

### Основные материалы лекции
1. [Ссылка](https://www.youtube.com/watch?v=wr7KuOSPP5I&list=PL0def37HEo5KHPjwK7A5bd4RJGg4djPVf&index=26) на видеозапись лекции
2. [Ссылка](https://onedrive.live.com/?authkey=!AIXUSz0MyutL6hs&id=1FF28DEC684C2C56!81692&cid=1FF28DEC684C2C56) на лекцию в формате Power Point
