##Создание модуля

Основной цифровых схем в Verilog является модуль. Модуль — это как коробочка вашего физического устройства, например магнитофона.

У магнитофона есть входы: вход касеты, кнопки, с помощью которых можно управлять устройством, и выходы: динамики магнитофона. Поэтому и у вашего модуля обычно будут входы и выходы.

![](../../../technical/Labs/Pic/module_magnitofon.jpg)

Итак, давайте создадим свой ~~магнитофон~~ модуль! Модуль без входов и выходов — это просто коробка, которая никак не взаимодействует с внешним миром. Определим наш модуль:

![](../../../technical/Labs/Pic/module_1.png)

```verilog
module 


endmodule

```

У всякого модуля дожно быть название. Назовём его box. В круглых скобках пишутся имена портов, их направление и типы. Если модуль не имеет ни входов, ни выходов, внутри скобок ничего не пишется. После них всегда ставится точка с запятой.

![](../../../technical/Labs/Pic/module_2.png)

```verilog
module box();


endmodule

```

Подключим к модулю два входных сигнала `a, b`  и один выходной `q`.

![](../../../technical/Labs/Pic/module_3.png)

```verilog
module box(
  input a,
  input b,
  output q
);


endmodule

```
Внутри модуля могут быть объявления сигналов, параметров, констант и т.п., о которых другой модуль не узнает.  Создадим провод `c`. Подробнее о типах данных можно прочитать в ".......".

![](../../../technical/Labs/Pic/module_4.png)

```verilog
module box(
  input a,
  input b,

  output q
);

  wire c;

endmodule

```

Подключим `c` ко входу `a`. Конструкция `assign c = ` называется непрерывным присваиванием. Провод `c` всегда будет иметь то же значение, что и `a`, тип "Цепь" не хранит значение, поэтому, если входной сигнал `a` изменится, `с` изменится тоже.

![](../../../technical/Labs/Pic/module_5.png)

```verilog
module box(
  input a,
  input b,

  output q
);

  wire c;

  assign c = a;

endmodule

```

Мы также можем присвоить `с` значение выхода логического вентиля. Пусть нам нужно выполнить операцию `a ИЛИ b`, а её результат присвоить `c`. 

![](../../../technical/Labs/Pic/module_6.png)

```verilog
module box(
  input a,
  input b,

  output q
);

  wire c;

  assign c = a | b;

endmodule
```


Пусть в схеме имеется ещё один логический вентиль - Исключающее ИЛИ. На него подаётся результат операции `a ИЛИ b`, то есть `c`, а также входной сигнал `b`. Результат операции `c ИСКЛЮЧАЮЩЕЕ ИЛИ b` подаётся на выход `q` нашего модуля. 

![](../../../technical/Labs/Pic/module_7.png)

```verilog
module box(
  input a,
  input b,

  output q
);

  wire c;

  assign c = a | b;
  assign q = c ^ b;

endmodule
```
Отлично! Мы научились создавать описание модуля.
<br>
##Иерархия модулей

Модули могут подключаться друг к другу. Например, первый модуль, `inv`, инвертирует приходящее на него значение и подаёт на выход. Второй модуль, `top`, имеет два входа и один выход. Вход `а` инвертируется.

![](../../../technical/Labs/Pic/module_8.png)

Опишем `inv`:

```verilog
module inv(
  input a,
  output d
);

  assign d = ~a;
endmodule

```
Опишем `top`:

```verilog
module top(
  input a,
  input b,
  output q
);
  // подключение модуля
  inv invertor_1(    // подключаем модуль inv и даём ему имя invertor_1
    .a(a),           // вход а модуля inv подключаем ко входу a модуля top
    .d(c)            // выход d модуля inv подключаем к проводу с модуля top
  );

endmodule
```

Мы можем подключить сколько угодно модулей, если они нам нужны. Пусть `c` подаётся на логический вентиль И вместе со входом `b`. Результат операции И тоже пойдет на инвертор, а затем на выход `q` модуля top.

![](../../../technical/Labs/Pic/module_9.png)

Тогда в нашем описании добавится подключение второго модуля `inv` и провод `c`.

```verilog
module inv(
  input a,
  output d
);

  assign d = ~a;
endmodule

```

```verilog
module top(
  input a,
  input b,
  output q
);

  wire c;

  // подключение модуля 1
  inv invertor_1(    // подключаем модуль inv и даём ему имя invertor_1
    .a(a),           // подключаем вход а модуля inv ко входу a модуля top
    .d(c)            // подключаем выход d модуля inv к проводу с модуля top
  );

  // подключение модуля 2
  inv invertor_1(    // подключаем модуль inv и даём ему имя invertor_2
    .a(c & b),       // на вход а модуля inv подаём результат логической операции с ИЛИ b
    .d(q)            // подключаем выход d модуля inv к выходу q модуля top
  );
  
endmodule
```


